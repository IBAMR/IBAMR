// ========================================================================
// NACA0012 FOIL SWIMMING SIMULATION - Input Configuration
// ========================================================================
// Based on: IBAMR eel2d example (examples/ConstraintIB/eel2d/input2d)
// Reference: https://github.com/IBAMR/IBAMR/blob/master/examples/ConstraintIB/eel2d/input2d
//
// DESCRIPTION:
// This simulation models undulatory swimming using a NACA0012 airfoil profile,
// where the chord represents the spine of a swimmer at static equilibrium.
// The foil undergoes traveling wave deformations to simulate swimming motion.
//
// TWO SWIMMING MODES SUPPORTED:
// 1. ANGUILLIFORM (Eel-like): Gradual amplitude increase from head to tail
// 2. CARANGIFORM (Fish-like): Amplitude concentrated in posterior half
//
// The swimming mode is selected via the amplitude envelope function A(x/L)
// configured in the ConstraintIBKinematics section below.
// ========================================================================

// physical parameters
Re = 5609.0          // the Reynolds number
// viscosity computed from Re (MU = U*L/Re; nondimensional choices embedded in example)
MU = 0.785/Re        // the viscosity required to attain the specified Reynolds number
// fluid density
RHO = 1.0
// grid spacing parameters
// maximum number of AMR levels (0 is coarsest)
MAX_LEVELS = 3                            // maximum number of levels in locally refined grid
// refinement ratio between successive AMR levels (integer)
REF_RATIO  = 4                            // refinement ratio between levels
// number of cells in the coarsest grid in x-direction (also used to set domain resolution) 
N = 64                                    // actual    number of grid cells on coarsest grid level
// solver parameters
// delta function to use for spreading/interpolation (IB kernel)
DELTA_FUNCTION       = "IB_4"
START_TIME           = 0.0e0                      // initial simulation time
END_TIME             = 10.0                       // final simulation time
// limit on number of integrator steps (very large to effectively disable)
MAX_INTEGRATOR_STEPS = 10000000000000             // Max no of steps.
GROW_DT              = 2.0e0                      // growth factor for timesteps (safety for dt growth)
NUM_CYCLES           = 1                          // number of cycles of fixed-point iteration. For cIB set 1. 
CONVECTIVE_OP_TYPE   = "PPM"                      // convective differencing discretization type
CONVECTIVE_FORM      = "CONSERVATIVE"                // how to compute the convective terms
NORMALIZE_PRESSURE   = TRUE                      // whether to explicitly force the pressure to have mean zero
CFL_MAX              = 0.3                        // maximum CFL number for dt control 
DT_MAX               = 0.0001                      // maximum timestep size
VORTICITY_TAGGING    = TRUE                       // whether to tag cells for refinement based on vorticity thresholds
TAG_BUFFER           = 2                          // size of tag buffer used by grid generation algorithm
REGRID_CFL_INTERVAL  = 0.5                        // regrid whenever any material point could have moved 0.5 meshwidths since previous regrid
OUTPUT_U             = TRUE                       // write velocity output
OUTPUT_P             = TRUE                       // write pressure output
OUTPUT_F             = FALSE                      // write force output
OUTPUT_OMEGA         = TRUE                       // write vorticity output
OUTPUT_DIV_U         = TRUE                       // write divergence of velocity output
ENABLE_LOGGING       = TRUE                       // enable detailed logging

// Initial control volume parameters
// Defines a rectangular box used by initialization routines (e.g., to set initial hydro forces)
// Keep same size as before (2L × 1.4L follows fish)
InitHydroForceBox_0 {
   lower_left_corner  = -1.0, -0.7, 0.0
   upper_right_corner =  1.0,  0.7, 0.0
   init_velocity      =  0.0,  0.0, 0.0
}

// Velocity BC coefficient sets (space for implementing different BC types per boundary)
// Each VelocityBcCoefs_* block provides coefficient functions for boundary condition specification
VelocityBcCoefs_0 {
   // Dirichlet (fixed) boundaries
   acoef_function_0 = "1.0"    // Left boundary
   acoef_function_1 = "1.0"    // Right boundary
   acoef_function_2 = "1.0"    // Bottom boundary
   acoef_function_3 = "1.0"    // Top boundary

   bcoef_function_0 = "0.0"
   bcoef_function_1 = "0.0"
   bcoef_function_2 = "0.0"
   bcoef_function_3 = "0.0"

   gcoef_function_0 = "0.0"    // No-slip walls
   gcoef_function_1 = "0.0"
   gcoef_function_2 = "0.0"
   gcoef_function_3 = "0.0"
}

VelocityBcCoefs_1 {
   acoef_function_0 = "1.0"
   acoef_function_1 = "1.0"
   acoef_function_2 = "1.0"
   acoef_function_3 = "1.0"

   bcoef_function_0 = "0.0"
   bcoef_function_1 = "0.0"
   bcoef_function_2 = "0.0"
   bcoef_function_3 = "0.0"

   gcoef_function_0 = "0.0"
   gcoef_function_1 = "0.0"
   gcoef_function_2 = "0.0"
   gcoef_function_3 = "0.0"
}

// IB hierarchy-time integrator configuration (top-level control for AMR+IB time stepping)
IBHierarchyIntegrator {
   start_time           = START_TIME
   end_time             = END_TIME
   grow_dt              = GROW_DT
   num_cycles           = NUM_CYCLES
   regrid_cfl_interval  = REGRID_CFL_INTERVAL
   dt_max               = DT_MAX
   enable_logging       = ENABLE_LOGGING
   max_integrator_steps = MAX_INTEGRATOR_STEPS
   error_on_dt_change   = FALSE   // don't abort on dt change
   warn_on_dt_change    = FALSE   // don't warn on dt change
}

// Constraint-based immersed boundary method configuration
ConstraintIBMethod {
   delta_fcn                = DELTA_FUNCTION
   enable_logging           = ENABLE_LOGGING
   needs_divfree_projection = FALSE
   rho_solid                = RHO
   // Options to calculate the structure's momenta
   calculate_structure_linear_mom       = TRUE            // compute linear momentum of immersed structure
   calculate_structure_rotational_mom   = TRUE            // compute rotational momentum of immersed structure
   // PrintOutput controls writing of structure diagnostics (drag, torque, COM, etc.)
   PrintOutput {
   print_output          = TRUE               // enable printing of outputs
   output_interval       = 1                  // how often (in steps) to write the outputs
   output_drag           = TRUE               // write drag force
   output_torque         = TRUE               // write torque
   output_power          = FALSE              // write power (disabled to match eel2d)
   output_rig_transvel   = TRUE               // output rigid-body translational velocity
   output_rig_rotvel     = TRUE               // output rigid-body rotational velocity
   output_com_coords     = TRUE               // output center-of-mass coordinates
   output_moment_inertia = FALSE              // output moment of inertia (disabled to match eel2d)
   output_eulerian_mom   = FALSE              // output Eulerian momentum (disabled to match eel2d)
   output_dirname        = "./NACA0012Str"    // Output directory
   base_filename         = "NACA0012"         // Base filename
  }

}

// number of immersed structures used by ConstraintIB
num_structures = 1
ConstraintIBKinematics {
naca0012carangiform {
     // name of the structure (matches IBStandardInitializer and other refs)
     structure_names                  = "naca0012carangiform" 
     // level index in AMR where the Lagrangian mesh is defined (MAX_LEVELS - 1 means finest level)
     structure_levels                 =  MAX_LEVELS - 1
     // toggle calculation of translational momentum components (1 -> true)
     calculate_translational_momentum = 1,1,0  // x, y, z components
      // toggle calculation of rotational momentum components
     calculate_rotational_momentum    = 0,0,1  // roll, pitch, yaw
     // how Lagrangian positions are updated (CONSTRAINT_POSITION uses constraint-based update)
     lag_position_update_method       = "CONSTRAINT_POSITION"
     // identifier for a tagged Lagrangian point (level, relative index)
     tagged_pt_identifier             = MAX_LEVELS - 1, 0  // level, relative idx of lag point
     initial_angle_body_axis_0        = 0.0                     // initial body orientation angle (radians)

     // ===================================================================
     // NACA0012 FOIL SWIMMING KINEMATICS
     // ===================================================================
     // The NACA0012 chord represents the spine of the swimmer at static equilibrium.
     // Two swimming modes are supported - select ONE by uncommenting the appropriate block:
     //
     // 1. ANGUILLIFORM (Eel-like):
     //    - Wave amplitude increases gradually from head to tail
     //    - Large amplitude undulations along entire body
     //    - Used by: eels, lampreys, snakes
     //    - Amplitude envelope: A(x/L) = 0.0367 + 0.0323*(x/L) + 0.0310*(x/L)²
     //
     // 2. CARANGIFORM (Fish-like):
     //    - Wave amplitude concentrated in posterior half
     //    - Anterior body remains relatively rigid
     //    - Used by: tuna, mackerel, most fast-swimming fish
     //    - Amplitude envelope (Khalid et al. 2016):
     //      A(x/L) = 0.02 - 0.0825*(x/L) + 0.1625*(x/L)²
     //
     // General form:
     // Centerline displacement: y(x,t) = A(x/L) * cos[2π(x/λ - ft)]
     // Deformation velocity:    ∂y/∂t = A(x/L) * 2πf * sin[2π(x/λ - ft)]
     //
     // Variables in equations:
     //   X_0 = x/L (normalized chordwise position, 0 to 1)
     //   T = t (time)
     //   f = 1 Hz (swimming frequency)
     //   λ = L = 1 (wavelength equals body length)
     //   N_0, N_1 = normal vector components (automatically computed)
     // ===================================================================

     // ===================================================================
     // OPTION 1: CARANGIFORM MODE (Currently Active)
     // ===================================================================
     // Amplitude envelope: A(x/L) = 0.02 - 0.0825(x/L) + 0.1625(x/L)²
     // Small amplitude at head, increasing rapidly toward tail
     body_shape_equation = "(0.02 - 0.0825*X_0 + 0.1625*X_0^2) * cos(2*PI*X_0 - 2*PI*T)"

     // Deformation velocity projected onto local normal direction
     deformation_velocity_function_0  = "((0.02 - 0.0825*X_0 + 0.1625*X_0^2) * 2*PI * sin(2*PI*X_0 - 2*PI*T)) * N_0"
     deformation_velocity_function_1  = "((0.02 - 0.0825*X_0 + 0.1625*X_0^2) * 2*PI * sin(2*PI*X_0 - 2*PI*T)) * N_1"

     // ===================================================================
     // OPTION 2: ANGUILLIFORM MODE (Commented Out)
     // ===================================================================
     // To activate anguilliform mode:
     //   1. Comment out the CARANGIFORM equations above
     //   2. Uncomment the ANGUILLIFORM equations below
     //
     // Amplitude envelope: A(x/L) = 0.0367 + 0.0323*(x/L) + 0.0310*(x/L)²
     // Gradual amplitude increase from head to tail for eel-like motion
     // Reference: [7,8,30]
     //
     // body_shape_equation = "(0.0367 + 0.0323*X_0 + 0.0310*X_0^2) * cos(2*PI*X_0 - 2*PI*T)"
     //
     // deformation_velocity_function_0  = "((0.0367 + 0.0323*X_0 + 0.0310*X_0^2) * 2*PI * sin(2*PI*X_0 - 2*PI*T)) * N_0"
     // deformation_velocity_function_1  = "((0.0367 + 0.0323*X_0 + 0.0310*X_0^2) * 2*PI * sin(2*PI*X_0 - 2*PI*T)) * N_1"
     // ===================================================================
     // whether the body executes additional maneuvering motion
     body_is_maneuvering                 = FALSE       //default false. If FALSE then nothing below has any effect.
     // equation defining the maneuver axis (used if body_is_maneuvering is TRUE)
     maneuvering_axis_equation           = "sqrt(1.3^2 -(X_0 - 0.5)^2) - 1.2"     //"0.1*sin(PI*X_0)"
     // axis shape may change in time
     maneuvering_axis_is_changing_shape  = TRUE  // should be true.
     // example physical points (e.g., food) that might be used by demos/diagnostics
     food_location_in_domain_0         =  1.0
     food_location_in_domain_1         = -3.3
}

}


// initializer that places Lagrangian structures on the grid
IBStandardInitializer {
   max_levels      = MAX_LEVELS
   structure_names = "naca0012carangiform"
   naca0012carangiform {
      // level where the Lagrangian mesh for naca0012carangiform is created
      level_number = MAX_LEVELS - 1
   }
   
}

// Navier Stokes integrator (staggered grid) configuration
INSStaggeredHierarchyIntegrator {
   mu                         = MU
   rho                        = RHO
   start_time                 = START_TIME
   end_time                   = END_TIME
   grow_dt                    = GROW_DT
   convective_op_type         = CONVECTIVE_OP_TYPE
   convective_difference_form = CONVECTIVE_FORM
   normalize_pressure         = NORMALIZE_PRESSURE
   cfl                        = CFL_MAX
   dt_max                     = DT_MAX
   using_vorticity_tagging    = VORTICITY_TAGGING
   // thresholds for vorticity-based AMR tagging on successive levels (coarse->fine)
   vorticity_abs_thresh       = 0.25 , 0.5 , 1 , 2
   tag_buffer                 = TAG_BUFFER
   output_U                   = OUTPUT_U
   output_P                   = OUTPUT_P
   output_F                   = OUTPUT_F
   output_Omega               = OUTPUT_OMEGA
   output_Div_U               = OUTPUT_DIV_U
   enable_logging             = ENABLE_LOGGING

   // velocity linear solver configuration (Hypre / PFMG options in nested solvers)
   VelocityHypreSolver {
      solver_type           = "Split"
      split_solver_type     = "PFMG"
      relative_residual_tol = 1.0e-12
      max_iterations        = 1
      enable_logging        = FALSE
   }

   // multilevel (FAC) preconditioner settings for velocity
   VelocityFACSolver {
      num_pre_sweeps  = 0
      num_post_sweeps = 1
      coarse_solver_choice = "hypre"
      coarse_solver_tolerance = 1.0e-12
      coarse_solver_max_iterations = 1
      prolongation_method = "CONSTANT_REFINE"
      restriction_method  = "CONSERVATIVE_COARSEN"
      hypre_solver {
         solver_type           = "Split"
         split_solver_type     = "PFMG"
         relative_residual_tol = 1.0e-12
         max_iterations        = 1
         enable_logging        = FALSE
      }
   }

   // pressure solver config (Hypre PFMG settings)
   PressureHypreSolver {
      solver_type           = "PFMG"
      rap_type              = 0
      relax_type            = 2
      skip_relax            = 1
      num_pre_relax_steps   = 2
      num_post_relax_steps  = 2
      relative_residual_tol = 1.0e-2
      max_iterations        = 100
      enable_logging        = FALSE
   }

   // FAC preconditioner for pressure with nested hypre options
   PressureFACSolver {
      num_pre_sweeps  = 0
      num_post_sweeps = 3
      coarse_solver_choice = "hypre"
      coarse_solver_tolerance = 1.0e-12
      coarse_solver_max_iterations = 1
      prolongation_method = "LINEAR_REFINE"
      restriction_method  = "CONSERVATIVE_COARSEN"
      hypre_solver {
         solver_type           = "PFMG"
         rap_type              = 0
         relax_type            = 2
         skip_relax            = 1
         num_pre_relax_steps   = 0
         num_post_relax_steps  = 3
         relative_residual_tol = 1.0e-12
         max_iterations        = 1
         enable_logging        = FALSE
      }
   }
}

// Main block: runtime output, dumps, and timers
Main {

// log file parameters
   log_file_name               = "IB2dNACA0012Str.log"
   log_all_nodes               = FALSE

// visualization dump parameters
   viz_writer                  = "VisIt","Silo"
   viz_dump_interval           = 40                     // zero to turn off
   viz_dump_dirname            = "viz_naca0012_Str"
   visit_number_procs_per_file = 1
// restart dump parameters
   restart_dump_interval       = 150                     // zero to turn off
   restart_dump_dirname        = "restart_IB2dStrDiv"
// hierarchy data dump parameters
   data_dump_interval          = 0                     // zero to turn off
   data_dump_dirname           = "hier_data_IB2dStr"
// timer dump parameters
   timer_dump_interval         = 100                     // zero to turn off
}
// ========================================================================
// COMPUTATIONAL DOMAIN (Matched to eel2d reference)
// ========================================================================
// Domain: 8L × 4L (swimmer length L=1)
// NACA0012 foil centered near origin, spans x ∈ [-0.5, 0.5], y ∈ [-0.06, 0.06]
// Provides ~6.5L upstream, ~1.5L downstream, ±1.5L lateral clearance
// Both dimensions are PERIODIC to match eel2d reference
// ========================================================================
// Cartesian geometry and domain specification
CartesianGeometry {
   // domain_boxes use cell indices: here coarse grid extents in x and y
   domain_boxes = [ (0,0) , (2*N - 1 , N - 1) ] // (2*N - 1, N - 1) are the upper bounds for the grid in x and y; N is the number of coarse grid cells in x
   // Domain: 8L × 4L maintains 2:1 aspect ratio matching grid (same as eel2d reference)
   // NACA0012 foil (length L=1) centered near origin with room to swim
   x_lo = -6.52, -1.52           // lower end of computational domain
   x_up =  1.48,  2.48           // upper end of computational domain
   // periodicity flags for each dimension (1 -> periodic). Both dimensions are periodic (matches eel2d).
   periodic_dimension = 1, 1
}

// AMR grid generation details
GriddingAlgorithm {
   max_levels = MAX_LEVELS           // Maximum number of levels in hierarchy.
   // refinement ratios specified for each level relative to the next coarser
   ratio_to_coarser {
      level_1 = REF_RATIO, REF_RATIO  // vector ratio to next coarser level
      level_2 = REF_RATIO, REF_RATIO
      level_3 = REF_RATIO, REF_RATIO
      level_4 = REF_RATIO, REF_RATIO
      level_5 = REF_RATIO, REF_RATIO
      level_6 = REF_RATIO, REF_RATIO
      level_7 = REF_RATIO, REF_RATIO
   }

   // largest allowed patch size on each level (level_0 sets a template)
   largest_patch_size {
      level_0 = 512, 512 // largest patch allowed in hierarchy // all finer levels will use same values as level_0...
   }

   // smallest allowed patch size on each level (level_0 sets a template)
   smallest_patch_size {
      level_0 =  8,  8 // smallest patch allowed in hierarchy // all finer levels will use same values as level_0...
   }

   // allow patches slightly smaller than the minimum to avoid overlapping boxes during box-chopping
   allow_patches_smaller_than_minimum_size_to_prevent_overlaps = TRUE
   // target efficiency for patch creation (fraction of flagged cells in a patch)
   efficiency_tolerance   = 0.6e0    // min % of tag cells in new patch level
   // combine boxes if the smaller boxes' total volume is not efficient
   combine_efficiency     = 0.8e0    // chop box if sum of volumes of smaller // boxes < efficiency * vol of large box
}

// Tagging method used for AMR (gradient detector typically picks up shear/vorticity regions)
StandardTagAndInitialize {
   tagging_method = "GRADIENT_DETECTOR"
}

// Load balancer settings for parallel runs (spatial bin packing)
LoadBalancer {
   bin_pack_method     = "SPATIAL"
   max_workload_factor = 1
}

// Timer printing options to help profile IBAMR/IBTK routines
TimerManager{
   print_exclusive = TRUE
   print_total = FALSE
   print_threshold = 0
   print_percentage = TRUE
   timer_list = "IBAMR::*::*", "IBTK::*::*" , "*::*::*", "*::ConstraintIBMethod::*"
}
