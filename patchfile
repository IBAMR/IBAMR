diff --git a/examples/IBFE/explicit/ex5/example.cpp b/examples/IBFE/explicit/ex5/example.cpp
index c83f55796..403c8398d 100644
--- a/examples/IBFE/explicit/ex5/example.cpp
+++ b/examples/IBFE/explicit/ex5/example.cpp
@@ -117,6 +117,9 @@ struct TetherData
     }
 };
 
+bool use_boundary_mesh 			  = false;
+bool compute_fluid_traction 	  = false;
+
 // Tether (penalty) stress function.
 void
 PK1_stress_function(TensorValue<double>& PP,
@@ -160,7 +163,7 @@ tether_force_function(VectorValue<double>& F,
 void
 tether_force_function(VectorValue<double>& F,
                       const VectorValue<double>& n,
-                      const VectorValue<double>& /*N*/,
+                      const VectorValue<double>& N,
                       const TensorValue<double>& /*FF*/,
                       const libMesh::Point& x,
                       const libMesh::Point& X,
@@ -173,19 +176,21 @@ tether_force_function(VectorValue<double>& F,
 {
     const TetherData* const tether_data = reinterpret_cast<TetherData*>(ctx);
 
-    VectorValue<double> D = X - x;
-    VectorValue<double> D_n = (D * n) * n;
-    VectorValue<double> U;
-    for (unsigned int d = 0; d < NDIM; ++d) U(d) = (*var_data[0])[d];
-    VectorValue<double> U_t = U - (U * n) * n;
-    F = tether_data->kappa_s_surface * D - tether_data->eta_s_surface * U;
+	const std::vector<double>& U = *var_data[0];
+    double u_bndry_n = 0.0;
+    for (unsigned int d = 0; d < NDIM; ++d) u_bndry_n += n(d) * U[d];
+
+	for (unsigned int d = 0; d < NDIM; ++d)
+		F(d) = tether_data->kappa_s_surface * (X(d) - x(d)) - tether_data->eta_s_surface * u_bndry_n * n(d);
     return;
 } // tether_force_function
 } // namespace ModelData
 using namespace ModelData;
 
 // Function prototypes
-static ofstream drag_stream, lift_stream, U_L1_norm_stream, U_L2_norm_stream, U_max_norm_stream;
+static ofstream drag_F_stream, lift_F_stream, drag_TAU_stream, lift_TAU_stream, U_L1_norm_stream, U_L2_norm_stream,
+    U_max_norm_stream;
+
 void postprocess_data(Pointer<Database> input_db,
                       Pointer<PatchHierarchy<NDIM> > patch_hierarchy,
                       Pointer<INSHierarchyIntegrator> navier_stokes_integrator,
@@ -247,8 +252,6 @@ main(int argc, char* argv[])
         const bool dump_restart_data = app_initializer->dumpRestartData();
         const int restart_dump_interval = app_initializer->getRestartDumpInterval();
         const string restart_dump_dirname = app_initializer->getRestartDumpDirectory();
-        const string restart_read_dirname = app_initializer->getRestartReadDirectory();
-        const int restart_restore_num = app_initializer->getRestartRestoreNumber();
 
         const bool dump_postproc_data = app_initializer->dumpPostProcessingData();
         const int postproc_data_dump_interval = app_initializer->getPostProcessingDataDumpInterval();
@@ -266,7 +269,7 @@ main(int argc, char* argv[])
         const double dx = input_db->getDouble("DX");
         const double ds = input_db->getDouble("MFAC") * dx;
         string elem_type = input_db->getString("ELEM_TYPE");
-        const double R = 0.5;
+        const double R = input_db->getDouble("R");
         if (NDIM == 2 && (elem_type == "TRI3" || elem_type == "TRI6"))
         {
 #ifdef LIBMESH_HAVE_TRIANGLE
@@ -319,7 +322,10 @@ main(int argc, char* argv[])
         solid_mesh.boundary_info->sync(boundary_mesh);
         boundary_mesh.prepare_for_use();
 
-        bool use_boundary_mesh = input_db->getBoolWithDefault("USE_BOUNDARY_MESH", false);
+        use_boundary_mesh = input_db->getBoolWithDefault("USE_BOUNDARY_MESH", false);
+
+        compute_fluid_traction = input_db->getBoolWithDefault("COMPUTE_FLUID_TRACTION", false);
+
         Mesh& mesh = use_boundary_mesh ? boundary_mesh : solid_mesh;
 
         // Create major algorithm and data objects that comprise the
@@ -346,27 +352,17 @@ main(int argc, char* argv[])
         }
         Pointer<IBStrategy> ib_ops;
         if (use_boundary_mesh)
-        {
             ib_ops = new IBFESurfaceMethod(
-                "IBFEMethod",
-                app_initializer->getComponentDatabase("IBFEMethod"),
+                "IBFESurfaceMethod",
+                app_initializer->getComponentDatabase("IBFESurfaceMethod"),
                 &mesh,
-                app_initializer->getComponentDatabase("GriddingAlgorithm")->getInteger("max_levels"),
-                /*register_for_restart*/ true,
-                restart_read_dirname,
-                restart_restore_num);
-        }
+                app_initializer->getComponentDatabase("GriddingAlgorithm")->getInteger("max_levels"));
         else
-        {
             ib_ops =
                 new IBFEMethod("IBFEMethod",
                                app_initializer->getComponentDatabase("IBFEMethod"),
                                &mesh,
-                               app_initializer->getComponentDatabase("GriddingAlgorithm")->getInteger("max_levels"),
-                               /*register_for_restart*/ true,
-                               restart_read_dirname,
-                               restart_restore_num);
-        }
+                               app_initializer->getComponentDatabase("GriddingAlgorithm")->getInteger("max_levels"));
         Pointer<IBHierarchyIntegrator> time_integrator =
             new IBExplicitHierarchyIntegrator("IBHierarchyIntegrator",
                                               app_initializer->getComponentDatabase("IBHierarchyIntegrator"),
@@ -388,16 +384,16 @@ main(int argc, char* argv[])
                                         error_detector,
                                         box_generator,
                                         load_balancer);
-
         // Configure the IBFE solver.
         TetherData tether_data(input_db);
         void* const tether_data_ptr = reinterpret_cast<void*>(&tether_data);
         EquationSystems* equation_systems;
         std::vector<int> vars(NDIM);
         for (unsigned int d = 0; d < NDIM; ++d) vars[d] = d;
-        vector<SystemData> sys_data(1, SystemData(IBFEMethod::VELOCITY_SYSTEM_NAME, vars));
+
         if (use_boundary_mesh)
         {
+            vector<SystemData> sys_data(1, SystemData(IBFESurfaceMethod::VELOCITY_SYSTEM_NAME, vars));
             Pointer<IBFESurfaceMethod> ibfe_ops = ib_ops;
             ibfe_ops->initializeFEEquationSystems();
             equation_systems = ibfe_ops->getFEDataManager()->getEquationSystems();
@@ -407,6 +403,7 @@ main(int argc, char* argv[])
         }
         else
         {
+            vector<SystemData> sys_data(1, SystemData(IBFEMethod::VELOCITY_SYSTEM_NAME, vars));
             Pointer<IBFEMethod> ibfe_ops = ib_ops;
             ibfe_ops->initializeFEEquationSystems();
             equation_systems = ibfe_ops->getFEDataManager()->getEquationSystems();
@@ -483,13 +480,6 @@ main(int argc, char* argv[])
         }
         std::unique_ptr<ExodusII_IO> exodus_io(uses_exodus ? new ExodusII_IO(mesh) : NULL);
 
-        // Check to see if this is a restarted run to append current exodus files
-        if (uses_exodus)
-        {
-            const bool from_restart = RestartManager::getManager()->isFromRestart();
-            exodus_io->append(from_restart);
-        }
-
         // Initialize hierarchy configuration and data on all patches.
         if (use_boundary_mesh)
         {
@@ -532,14 +522,18 @@ main(int argc, char* argv[])
         // velocity.
         if (SAMRAI_MPI::getRank() == 0)
         {
-            drag_stream.open("C_D.curve", ios_base::out | ios_base::trunc);
-            lift_stream.open("C_L.curve", ios_base::out | ios_base::trunc);
+            drag_F_stream.open("C_F_D.curve", ios_base::out | ios_base::trunc);
+            lift_F_stream.open("C_F_L.curve", ios_base::out | ios_base::trunc);
+            drag_TAU_stream.open("C_T_D.curve", ios_base::out | ios_base::trunc);
+            lift_TAU_stream.open("C_T_L.curve", ios_base::out | ios_base::trunc);
             U_L1_norm_stream.open("U_L1.curve", ios_base::out | ios_base::trunc);
             U_L2_norm_stream.open("U_L2.curve", ios_base::out | ios_base::trunc);
             U_max_norm_stream.open("U_max.curve", ios_base::out | ios_base::trunc);
 
-            drag_stream.precision(10);
-            lift_stream.precision(10);
+            drag_F_stream.precision(10);
+            lift_F_stream.precision(10);
+            drag_TAU_stream.precision(10);
+            lift_TAU_stream.precision(10);
             U_L1_norm_stream.precision(10);
             U_L2_norm_stream.precision(10);
             U_max_norm_stream.precision(10);
@@ -591,15 +585,6 @@ main(int argc, char* argv[])
             {
                 pout << "\nWriting restart files...\n\n";
                 RestartManager::getManager()->writeRestartFile(restart_dump_dirname, iteration_num);
-                if (use_boundary_mesh)
-                {
-                    dynamic_cast<IBFESurfaceMethod&>(*ib_ops).writeFEDataToRestartFile(restart_dump_dirname,
-                                                                                       iteration_num);
-                }
-                else
-                {
-                    dynamic_cast<IBFEMethod&>(*ib_ops).writeFEDataToRestartFile(restart_dump_dirname, iteration_num);
-                }
             }
             if (dump_timer_data && (iteration_num % timer_dump_interval == 0 || last_step))
             {
@@ -622,8 +607,10 @@ main(int argc, char* argv[])
         // Close the logging streams.
         if (SAMRAI_MPI::getRank() == 0)
         {
-            drag_stream.close();
-            lift_stream.close();
+            drag_F_stream.close();
+            lift_F_stream.close();
+            drag_TAU_stream.close();
+            lift_TAU_stream.close();
             U_L1_norm_stream.close();
             U_L2_norm_stream.close();
             U_max_norm_stream.close();
@@ -636,6 +623,7 @@ main(int argc, char* argv[])
     } // cleanup dynamically allocated objects prior to shutdown
 
     SAMRAIManager::shutdown();
+    return true;
 } // main
 
 void
@@ -653,19 +641,46 @@ postprocess_data(Pointer<Database> input_db,
 
     const unsigned int dim = mesh.mesh_dimension();
     double F_integral[NDIM];
-    for (unsigned int d = 0; d < NDIM; ++d) F_integral[d] = 0.0;
+    double T_integral[NDIM];
+    for (unsigned int d = 0; d < NDIM; ++d)
+    {
+        F_integral[d] = 0.0;
+        T_integral[d] = 0.0;
+    }
+    System* x_system;
+    System* U_system;
 
-    System& x_system = equation_systems->get_system(IBFEMethod::COORDS_SYSTEM_NAME);
-    System& U_system = equation_systems->get_system(IBFEMethod::VELOCITY_SYSTEM_NAME);
-    NumericVector<double>* x_vec = x_system.solution.get();
-    NumericVector<double>* x_ghost_vec = x_system.current_local_solution.get();
+    if (use_boundary_mesh)
+    {
+        x_system = &equation_systems->get_system(IBFESurfaceMethod::COORDS_SYSTEM_NAME);
+        U_system = &equation_systems->get_system(IBFESurfaceMethod::VELOCITY_SYSTEM_NAME);
+    }
+    else
+    {
+        x_system = &equation_systems->get_system(IBFEMethod::COORDS_SYSTEM_NAME);
+        U_system = &equation_systems->get_system(IBFEMethod::VELOCITY_SYSTEM_NAME);
+    }
+    NumericVector<double>* x_vec = x_system->solution.get();
+    NumericVector<double>* x_ghost_vec = x_system->current_local_solution.get();
     x_vec->localize(*x_ghost_vec);
-    NumericVector<double>* U_vec = U_system.solution.get();
-    NumericVector<double>* U_ghost_vec = U_system.current_local_solution.get();
+    NumericVector<double>* U_vec = U_system->solution.get();
+    NumericVector<double>* U_ghost_vec = U_system->current_local_solution.get();
     U_vec->localize(*U_ghost_vec);
-    const DofMap& dof_map = x_system.get_dof_map();
+    const DofMap& dof_map = x_system->get_dof_map();
     std::vector<std::vector<unsigned int> > dof_indices(NDIM);
 
+    NumericVector<double>& X_vec = x_system->get_vector("INITIAL_COORDINATES");
+
+    std::vector<std::vector<unsigned int> > WSS_o_dof_indices(NDIM);
+    System* TAU_system;
+    NumericVector<double>* TAU_ghost_vec = NULL;
+    if (compute_fluid_traction)
+    {
+        TAU_system = &equation_systems->get_system(IBFESurfaceMethod::TAU_OUT_SYSTEM_NAME);
+
+        TAU_ghost_vec = TAU_system->current_local_solution.get();
+    }
+
     std::unique_ptr<FEBase> fe(FEBase::build(dim, dof_map.variable_type(0)));
     std::unique_ptr<QBase> qrule = QBase::build(QGAUSS, dim, SEVENTH);
     fe->attach_quadrature_rule(qrule.get());
@@ -689,8 +704,9 @@ postprocess_data(Pointer<Database> input_db,
     std::vector<const std::vector<libMesh::VectorValue<double> >*> grad_var_data;
 
     TensorValue<double> FF, FF_inv_trans;
-    boost::multi_array<double, 2> x_node, U_node;
-    VectorValue<double> F, N, U, n, x;
+    boost::multi_array<double, 2> x_node, X_node, U_node, TAU_node;
+
+    VectorValue<double> F, N, U, n, x, X, TAU;
 
     const MeshBase::const_element_iterator el_begin = mesh.active_local_elements_begin();
     const MeshBase::const_element_iterator el_end = mesh.active_local_elements_end();
@@ -704,58 +720,88 @@ postprocess_data(Pointer<Database> input_db,
         }
         get_values_for_interpolation(x_node, *x_ghost_vec, dof_indices);
         get_values_for_interpolation(U_node, *U_ghost_vec, dof_indices);
+        get_values_for_interpolation(X_node, X_vec, dof_indices);
+        if (compute_fluid_traction)
+            get_values_for_interpolation(TAU_node, *TAU_ghost_vec, dof_indices);
 
         const unsigned int n_qp = qrule->n_points();
         for (unsigned int qp = 0; qp < n_qp; ++qp)
         {
+            interpolate(X, qp, X_node, phi);
             interpolate(x, qp, x_node, phi);
             jacobian(FF, qp, x_node, dphi);
             interpolate(U, qp, U_node, phi);
+            if (compute_fluid_traction) interpolate(TAU, qp, TAU_node, phi);
             for (unsigned int d = 0; d < NDIM; ++d)
             {
                 U_qp_vec[d] = U(d);
             }
-            tether_force_function(F, FF, x, q_point[qp], elem, var_data, grad_var_data, loop_time, tether_data_ptr);
+            if (use_boundary_mesh)
+                tether_force_function(F, n, N, FF, x, X, elem, 0, var_data, grad_var_data, loop_time, tether_data_ptr);
+            else
+                tether_force_function(F, n, x, q_point[qp], elem, var_data, grad_var_data, loop_time, tether_data_ptr);
+
             for (int d = 0; d < NDIM; ++d)
             {
                 F_integral[d] += F(d) * JxW[qp];
+                if (compute_fluid_traction) T_integral[d] += TAU(d) * JxW[qp];
+
             }
         }
-        for (unsigned short int side = 0; side < elem->n_sides(); ++side)
+        if (!use_boundary_mesh)
         {
-            if (elem->neighbor_ptr(side)) continue;
-            fe_face->reinit(elem, side);
-            const unsigned int n_qp_face = qrule_face->n_points();
-            for (unsigned int qp = 0; qp < n_qp_face; ++qp)
+            for (unsigned short int side = 0; side < elem->n_sides(); ++side)
             {
-                interpolate(x, qp, x_node, phi_face);
-                jacobian(FF, qp, x_node, dphi_face);
-                interpolate(U, qp, U_node, phi_face);
-                for (unsigned int d = 0; d < NDIM; ++d)
+                if (elem->neighbor_ptr(side)) continue;
+                fe_face->reinit(elem, side);
+                const unsigned int n_qp_face = qrule_face->n_points();
+                for (unsigned int qp = 0; qp < n_qp_face; ++qp)
                 {
-                    U_qp_vec[d] = U(d);
-                }
-                N = normal_face[qp];
-                tensor_inverse_transpose(FF_inv_trans, FF, NDIM);
-                n = (FF_inv_trans * N).unit();
-
-                tether_force_function(
-                    F, n, N, FF, x, q_point_face[qp], elem, side, var_data, grad_var_data, loop_time, tether_data_ptr);
-                for (int d = 0; d < NDIM; ++d)
-                {
-                    F_integral[d] += F(d) * JxW_face[qp];
+                    interpolate(x, qp, x_node, phi_face);
+                    jacobian(FF, qp, x_node, dphi_face);
+                    interpolate(U, qp, U_node, phi_face);
+                    for (unsigned int d = 0; d < NDIM; ++d)
+                    {
+                        U_qp_vec[d] = U(d);
+                    }
+                    N = normal_face[qp];
+                    tensor_inverse_transpose(FF_inv_trans, FF, NDIM);
+                    n = (FF_inv_trans * N).unit();
+
+                    tether_force_function(F,
+                                          n,
+                                          N,
+                                          FF,
+                                          x,
+                                          q_point_face[qp],
+                                          elem,
+                                          side,
+                                          var_data,
+                                          grad_var_data,
+                                          loop_time,
+                                          tether_data_ptr);
+                    for (int d = 0; d < NDIM; ++d)
+                    {
+                        F_integral[d] += F(d) * JxW_face[qp];
+                    }
                 }
             }
         }
     }
     SAMRAI_MPI::sumReduction(F_integral, NDIM);
+    SAMRAI_MPI::sumReduction(T_integral, NDIM);
     static const double rho = 1.0;
     static const double U_max = 1.0;
     static const double D = 1.0;
     if (SAMRAI_MPI::getRank() == 0)
     {
-        drag_stream << loop_time << " " << -F_integral[0] / (0.5 * rho * U_max * U_max * D) << endl;
-        lift_stream << loop_time << " " << -F_integral[1] / (0.5 * rho * U_max * U_max * D) << endl;
+        drag_F_stream << loop_time << " " << -F_integral[0] / (0.5 * rho * U_max * U_max * D) << endl;
+        lift_F_stream << loop_time << " " << -F_integral[1] / (0.5 * rho * U_max * U_max * D) << endl;
+        if (compute_fluid_traction)
+        {
+            drag_TAU_stream << loop_time << " " << T_integral[0] / (0.5 * rho * U_max * U_max * D) << endl;
+            lift_TAU_stream << loop_time << " " << T_integral[1] / (0.5 * rho * U_max * U_max * D) << endl;
+        }
     }
     return;
 } // postprocess_data
diff --git a/examples/IBFE/explicit/ex5/input2d b/examples/IBFE/explicit/ex5/input2d
index b77de95a6..aada69288 100644
--- a/examples/IBFE/explicit/ex5/input2d
+++ b/examples/IBFE/explicit/ex5/input2d
@@ -2,7 +2,7 @@
 Re = 200.0
 MU = 1.0/Re
 RHO = 1.0
-
+R = 0.5        											// radius of the cylinder
 // grid spacing parameters
 L = 16.0                                       // width of computational domain
 MAX_LEVELS = 6                                 // maximum number of levels in locally refined grid
@@ -228,6 +228,5 @@ TimerManager{
    print_exclusive = FALSE
    print_total = TRUE
    print_threshold = 0.1
-
    timer_list = "IBAMR::*::*","IBTK::*::*","*::*::*"
 }
diff --git a/examples/IBFE/explicit/ex5/input2d.iim b/examples/IBFE/explicit/ex5/input2d.iim
new file mode 100644
index 000000000..b20d034e8
--- /dev/null
+++ b/examples/IBFE/explicit/ex5/input2d.iim
@@ -0,0 +1,244 @@
+// physical parameters
+Re = 200.0
+MU = 1.0/Re
+RHO = 1.0
+R = 0.5        								   // radius of the cylinder
+U_MAX = 2.0
+
+// grid spacing parameters
+L = 16.0                                       // width of computational domain
+MAX_LEVELS = 6                                 // maximum number of levels in locally refined grid
+REF_RATIO  = 2                                 // refinement ratio between levels
+N = 16                                         // actual    number of grid cells on coarsest grid level
+NFINEST = (REF_RATIO^(MAX_LEVELS - 1))*N       // effective number of grid cells on finest   grid level
+DX0 = L/N                                      // mesh width on coarsest grid level
+DX  = L/NFINEST                                // mesh width on finest   grid level
+MFAC = 2.0                                     // ratio of Lagrangian mesh width to Cartesian mesh width
+ELEM_TYPE = "TRI3"                             // type of element to use for structure discretization
+PK1_DEV_QUAD_ORDER = "SEVENTH"
+PK1_DIL_QUAD_ORDER = "FIFTH"
+USE_BOUNDARY_MESH = TRUE
+
+// solver parameters
+IB_DELTA_FUNCTION            = "IB_3"            // the type of smoothed delta function to use for Lagrangian-Eulerian interaction
+SPLIT_FORCES                 = TRUE              // whether to split interior and boundary forces
+USE_PRESSURE_JUMP_CONDITIONS = TRUE   		     // whether to impose pressure jumps at fluid-structure interfaces
+USE_VELOCITY_JUMP_CONDITIONS = TRUE              // whether to impose the velocity jumps at fluid-structure interfaces
+COMPUTE_FLUID_TRACTION 	     = TRUE              // whether to compute the exterior fluid traction
+WSS_CALC_WIDTH 		         = 1.05              // ratio multiplied by the diagonal side of the grid spacing to calculate wss
+P_CALC_WIDTH 		         = 1.3               // ratio multiplied by the diogonal side of the grid spacing to calculate the pressure
+USE_CONSISTENT_MASS_MATRIX   = TRUE              // whether to use a consistent or lumped mass matrix
+IB_POINT_DENSITY             = 4.0               // approximate density of IB quadrature points for Lagrangian-Eulerian interaction
+SOLVER_TYPE                  = "STAGGERED"       // the fluid solver to use (STAGGERED or COLLOCATED)
+CFL_MAX                      = 0.4               // maximum CFL number
+DT                           = 0.25*CFL_MAX*DX   // maximum timestep size
+START_TIME                   = 0.0e0             // initial simulation time
+END_TIME                     = 100               // final simulation time
+GROW_DT                      = 2.0e0             // growth factor for timesteps
+CONVECTIVE_TS_TYPE           = "ADAMS_BASHFORTH" // convective time stepping type
+CONVECTIVE_OP_TYPE           = "STABILIZED_PPM"  // convective differencing discretization type
+CONVECTIVE_FORM              = "ADVECTIVE"       // how to compute the convective terms
+NORMALIZE_PRESSURE           = FALSE             // whether to explicitly force the pressure to have mean zero
+ERROR_ON_DT_CHANGE           = TRUE              // whether to emit an error message if the time step size changes
+VORTICITY_TAGGING            = TRUE              // whether to tag cells for refinement based on vorticity thresholds
+TAG_BUFFER                   = 4                 // size of tag buffer used by grid generation algorithm
+REGRID_CFL_INTERVAL          = 0.5               // regrid whenever any material point could have moved 0.5 meshwidths since previous regrid
+OUTPUT_U                     = TRUE
+OUTPUT_P                     = TRUE
+OUTPUT_F                     = TRUE
+OUTPUT_OMEGA                 = TRUE
+OUTPUT_DIV_U                 = TRUE
+ENABLE_LOGGING               = TRUE
+
+
+// model parameters
+KAPPA_S_SURFACE = 0.0015/DT^2
+ETA_S_SURFACE = 0.005/DT
+KAPPA_S_BODY = 0.0
+ETA_S_BODY = 0.0
+C1_S = 0.0
+
+
+
+// collocated solver parameters
+PROJECTION_METHOD_TYPE = "PRESSURE_UPDATE"
+SECOND_ORDER_PRESSURE_UPDATE = TRUE
+
+VelocityBcCoefs_0 {
+   t_half = 0.5
+   tau = 0.25
+
+   acoef_function_0 = "1.0"
+   acoef_function_1 = "0.0"
+   acoef_function_2 = "0.0"
+   acoef_function_3 = "0.0"
+
+   bcoef_function_0 = "0.0"
+   bcoef_function_1 = "1.0"
+   bcoef_function_2 = "1.0"
+   bcoef_function_3 = "1.0"
+
+   gcoef_function_0 = "(tanh(t/2-t_half/tau)+tanh(t_half/tau))/(1+tanh(t_half/tau))"
+   gcoef_function_1 = "0.0"
+   gcoef_function_2 = "0.0"
+   gcoef_function_3 = "0.0"
+}
+
+VelocityBcCoefs_1 {
+
+   L = L
+
+   acoef_function_0 = "1.0"
+   acoef_function_1 = "0.0"
+   acoef_function_2 = "1.0"
+   acoef_function_3 = "1.0"
+
+   bcoef_function_0 = "0.0"
+   bcoef_function_1 = "1.0"
+   bcoef_function_2 = "0.0"
+   bcoef_function_3 = "0.0"
+
+   gcoef_function_0 = "cos(pi*X_1/L)*exp(-2.0*t)"
+   gcoef_function_1 = "0.0"
+   gcoef_function_2 = "0.0"
+   gcoef_function_3 = "0.0"
+}
+
+IBHierarchyIntegrator {
+   start_time          = START_TIME
+   end_time            = END_TIME
+   grow_dt             = GROW_DT
+   regrid_cfl_interval = REGRID_CFL_INTERVAL
+   dt_max              = DT
+   error_on_dt_change  = ERROR_ON_DT_CHANGE
+   enable_logging      = ENABLE_LOGGING
+}
+
+IBFESurfaceMethod {
+   IB_delta_fcn                 = IB_DELTA_FUNCTION
+   split_forces                 = SPLIT_FORCES
+   use_pressure_jump_conditions = USE_PRESSURE_JUMP_CONDITIONS
+   use_velocity_jump_conditions = USE_VELOCITY_JUMP_CONDITIONS
+   use_consistent_mass_matrix   = USE_CONSISTENT_MASS_MATRIX
+   IB_point_density             = IB_POINT_DENSITY
+   p_calc_width				    = P_CALC_WIDTH
+   wss_calc_width			    = WSS_CALC_WIDTH
+   compute_fluid_traction       = COMPUTE_FLUID_TRACTION
+   min_ghost_cell_width 		= 6
+}
+
+INSCollocatedHierarchyIntegrator {
+   mu                            = MU
+   rho                           = RHO
+   start_time                    = START_TIME
+   end_time                      = END_TIME
+   grow_dt                       = GROW_DT
+   convective_time_stepping_type = CONVECTIVE_TS_TYPE
+   convective_op_type            = CONVECTIVE_OP_TYPE
+   convective_difference_form    = CONVECTIVE_FORM
+   normalize_pressure            = NORMALIZE_PRESSURE
+   cfl                           = CFL_MAX
+   dt_max                        = DT
+   using_vorticity_tagging       = VORTICITY_TAGGING
+   vorticity_abs_thresh          = 0.125,0.25,0.5,1,2
+   tag_buffer                    = TAG_BUFFER
+   output_U                      = OUTPUT_U
+   output_P                      = OUTPUT_P
+   output_F                      = OUTPUT_F
+   output_Omega                  = OUTPUT_OMEGA
+   output_Div_U                  = OUTPUT_DIV_U
+   enable_logging                = ENABLE_LOGGING
+   projection_method_type        = PROJECTION_METHOD_TYPE
+   use_2nd_order_pressure_update = SECOND_ORDER_PRESSURE_UPDATE
+}
+
+INSStaggeredHierarchyIntegrator {
+   mu                            = MU
+   rho                           = RHO
+   start_time                    = START_TIME
+   end_time                      = END_TIME
+   grow_dt                       = GROW_DT
+   convective_time_stepping_type = CONVECTIVE_TS_TYPE
+   convective_op_type            = CONVECTIVE_OP_TYPE
+   convective_difference_form    = CONVECTIVE_FORM
+   normalize_pressure            = NORMALIZE_PRESSURE
+   cfl                           = CFL_MAX
+   dt_max                        = DT
+   using_vorticity_tagging       = VORTICITY_TAGGING
+   vorticity_abs_thresh          = 0.125,0.25,0.5,1
+   tag_buffer                    = TAG_BUFFER
+   output_U                      = OUTPUT_U
+   output_P                      = OUTPUT_P
+   output_F                      = OUTPUT_F
+   output_Omega                  = OUTPUT_OMEGA
+   output_Div_U                  = OUTPUT_DIV_U
+   enable_logging                = ENABLE_LOGGING
+}
+
+Main {
+   solver_type = SOLVER_TYPE
+
+// log file parameters
+   log_file_name               = "IIM_2d.log"
+   log_all_nodes               = FALSE
+
+// visualization dump parameters
+   viz_writer                  = "VisIt","ExodusII"
+   viz_dump_interval           = int(1/DT)
+   viz_dump_dirname            = "viz_IIM_2d"
+   visit_number_procs_per_file = 1
+
+// restart dump parameters
+   restart_dump_interval       = 0
+   restart_dump_dirname        = "restart_IIM2d"
+
+// hierarchy data dump parameters
+   data_dump_interval          = 1
+   data_dump_dirname           = "hier_data_IIM2d"
+// timer dump parameters
+   timer_dump_interval         = 0
+}
+
+CartesianGeometry {
+   domain_boxes = [ (0,0),(N - 1,N - 1) ]
+   x_lo = -0.25*L,-0.5*L
+   x_up =  0.75*L, 0.5*L
+   periodic_dimension = 0,0
+}
+
+GriddingAlgorithm {
+   max_levels = MAX_LEVELS
+   ratio_to_coarser {
+      level_1 = REF_RATIO,REF_RATIO
+      level_2 = REF_RATIO,REF_RATIO
+      level_3 = REF_RATIO,REF_RATIO
+      level_4 = REF_RATIO,REF_RATIO
+      level_5 = REF_RATIO,REF_RATIO
+      level_6 = REF_RATIO,REF_RATIO
+      level_7 = REF_RATIO,REF_RATIO
+   }
+   largest_patch_size {
+      level_0 = 512,512  // all finer levels will use same values as level_0
+   }
+   smallest_patch_size {
+      level_0 =   8,  8  // all finer levels will use same values as level_0
+   }
+   efficiency_tolerance = 0.80e0  // min % of tag cells in new patch level
+   combine_efficiency   = 0.80e0  // chop box if sum of volumes of smaller boxes < efficiency * vol of large box
+}
+
+StandardTagAndInitialize {
+   tagging_method = "GRADIENT_DETECTOR"
+}
+
+LoadBalancer {
+   bin_pack_method     = "SPATIAL"
+   max_workload_factor = 1
+}
+
+TimerManager{
+   print_exclusive = FALSE
+   print_total     = TRUE
+   print_threshold = 0.1
+   timer_list = "IBAMR::*::*","IBTK::*::*","*::*::*"
+}
diff --git a/examples/IBFE/explicit/ex5/input3d b/examples/IBFE/explicit/ex5/input3d
index 6592460ec..a0dd77757 100644
--- a/examples/IBFE/explicit/ex5/input3d
+++ b/examples/IBFE/explicit/ex5/input3d
@@ -2,7 +2,7 @@
 Re = 400.0
 MU = 1.0/Re
 RHO = 1.0
-
+R = 0.5        											// radius of the cylinder
 // grid spacing parameters
 L = 16.0                                       // width of computational domain
 MAX_LEVELS = 6                                 // maximum number of levels in locally refined grid
@@ -261,6 +261,5 @@ TimerManager{
    print_exclusive = FALSE
    print_total = TRUE
    print_threshold = 0.1
-
    timer_list = "IBAMR::*::*","IBTK::*::*","*::*::*"
 }
diff --git a/examples/IBFE/explicit/ex5/input3d.iim b/examples/IBFE/explicit/ex5/input3d.iim
new file mode 100644
index 000000000..14837f734
--- /dev/null
+++ b/examples/IBFE/explicit/ex5/input3d.iim
@@ -0,0 +1,276 @@
+// physical parameters
+Re = 200.0
+MU = 1.0/Re
+RHO = 1.0
+R = 0.5        											// radius of the cylinder
+U_MAX = 2.0
+// grid spacing parameters
+L = 16.0 //60.0                                       // width of computational domain
+MAX_LEVELS = 6                                 // maximum number of levels in locally refined grid
+REF_RATIO  = 2                                 // refinement ratio between levels
+N = 32                                         // actual    number of grid cells on coarsest grid level
+NFINEST = (REF_RATIO^(MAX_LEVELS - 1))*N       // effective number of grid cells on finest   grid level
+DX0 = L/N                                      // mesh width on coarsest grid level
+DX  = L/NFINEST                                // mesh width on finest   grid level
+MFAC = 2.0                                     // ratio of Lagrangian mesh width to Cartesian mesh width
+ELEM_TYPE = "HEX8"                            // type of element to use for structure discretization
+USE_BOUNDARY_MESH = TRUE
+
+// solver parameters
+IB_DELTA_FUNCTION            = "IB_3"            // the type of smoothed delta function to use for Lagrangian-Eulerian interaction
+SPLIT_FORCES                 = TRUE              // whether to split interior and boundary forces
+USE_PRESSURE_JUMP_CONDITIONS = TRUE   		     // whether to impose pressure jumps at fluid-structure interfaces
+USE_VELOCITY_JUMP_CONDITIONS = TRUE             // whether to impose the velocity jumps at fluid-structure interfaces
+COMPUTE_FLUID_TRACTION 	     = TRUE             // whether to compute the exterior fluid traction
+USE_L2_LAGRANGE_FAMILY       = FALSE  		     // Whether to use L2_Lagrange family for the calc of jump variables and traction
+WSS_CALC_WIDTH 		         = 1.05               // ratio multiplied by the diagonal side of the grid spacing to calculate wss
+P_CALC_WIDTH 		         = 1.5               // ratio multiplied by the diogonal side of the grid spacing to calculate the pressure
+USE_CONSISTENT_MASS_MATRIX   = TRUE              // whether to use a consistent or lumped mass matrix
+IB_POINT_DENSITY             = 4.0               // approximate density of IB quadrature points for Lagrangian-Eulerian interaction
+SOLVER_TYPE                  = "STAGGERED"       // the fluid solver to use (STAGGERED or COLLOCATED)
+CFL_MAX                      = 0.1               // maximum CFL number
+DT                           = CFL_MAX*DX/U_MAX   // maximum timestep size
+START_TIME                   = 0.0e0             // initial simulation time
+END_TIME                     = 200               // final simulation time
+GROW_DT                      = 2.0e0             // growth factor for timesteps
+CONVECTIVE_TS_TYPE           = "ADAMS_BASHFORTH" // convective time stepping type
+CONVECTIVE_OP_TYPE           = "STABILIZED_PPM"  // convective differencing discretization type
+CONVECTIVE_FORM              = "ADVECTIVE"       // how to compute the convective terms
+NORMALIZE_PRESSURE           = FALSE             // whether to explicitly force the pressure to have mean zero
+ERROR_ON_DT_CHANGE           = TRUE              // whether to emit an error message if the time step size changes
+VORTICITY_TAGGING            = TRUE              // whether to tag cells for refinement based on vorticity thresholds
+TAG_BUFFER                   = 1                 // size of tag buffer used by grid generation algorithm
+REGRID_CFL_INTERVAL          = 0.5               // regrid whenever any material point could have moved 0.5 meshwidths since previous regrid
+OUTPUT_U                     = TRUE
+OUTPUT_P                     = TRUE
+OUTPUT_F                     = TRUE
+OUTPUT_OMEGA                 = TRUE
+OUTPUT_DIV_U                 = TRUE
+ENABLE_LOGGING               = TRUE
+
+// model parameters
+ETA_S_BODY = 0.0
+KAPPA_S_BODY = 0.0
+KAPPA_S_SURFACE = 1000 // 0.05*DX/DT^2 //0.0183*DX/DT^2 // 7.5*DX/DT^2
+ETA_S_SURFACE = 0.0 //1.5*DX/DT
+C1_S = 0.0
+
+
+// collocated solver parameters
+PROJECTION_METHOD_TYPE = "PRESSURE_UPDATE"
+SECOND_ORDER_PRESSURE_UPDATE = TRUE
+
+VelocityBcCoefs_0 {
+   t_half = 0.5
+   tau = 0.25
+   L = L
+
+   acoef_function_0 = "1.0"
+   acoef_function_1 = "0.0"
+   acoef_function_2 = "0.0"
+   acoef_function_3 = "0.0"
+   acoef_function_4 = "0.0"
+   acoef_function_5 = "0.0"
+
+   bcoef_function_0 = "0.0"
+   bcoef_function_1 = "1.0"
+   bcoef_function_2 = "1.0"
+   bcoef_function_3 = "1.0"
+   bcoef_function_4 = "1.0"
+   bcoef_function_5 = "1.0"
+
+   gcoef_function_0 = "(tanh(t/10-t_half/tau)+tanh(t_half/tau))/(1+tanh(t_half/tau))"
+   gcoef_function_1 = "0.0"
+   gcoef_function_2 = "0.0"
+   gcoef_function_3 = "0.0"
+   gcoef_function_4 = "0.0"
+   gcoef_function_5 = "0.0"
+}
+
+VelocityBcCoefs_1 {
+
+   L = L
+   acoef_function_0 = "1.0"
+   acoef_function_1 = "0.0"
+   acoef_function_2 = "1.0"
+   acoef_function_3 = "1.0"
+   acoef_function_4 = "0.0"
+   acoef_function_5 = "0.0"
+
+   bcoef_function_0 = "0.0"
+   bcoef_function_1 = "1.0"
+   bcoef_function_2 = "0.0"
+   bcoef_function_3 = "0.0"
+   bcoef_function_4 = "1.0"
+   bcoef_function_5 = "1.0"
+
+   gcoef_function_0 = "cos(pi*X_1/L)*exp(-2.0*t)"
+   gcoef_function_1 = "0.0"
+   gcoef_function_2 = "0.0"
+   gcoef_function_3 = "0.0"
+   gcoef_function_4 = "0.0"
+   gcoef_function_5 = "0.0"
+}
+
+VelocityBcCoefs_2 {
+	L = L
+   acoef_function_0 = "1.0"
+   acoef_function_1 = "0.0"
+   acoef_function_2 = "0.0"
+   acoef_function_3 = "0.0"
+   acoef_function_4 = "1.0"
+   acoef_function_5 = "1.0"
+
+   bcoef_function_0 = "0.0"
+   bcoef_function_1 = "1.0"
+   bcoef_function_2 = "1.0"
+   bcoef_function_3 = "1.0"
+   bcoef_function_4 = "0.0"
+   bcoef_function_5 = "0.0"
+
+   gcoef_function_0 = "cos(pi*X_1/L)*exp(-2.0*t)"
+   gcoef_function_1 = "0.0"
+   gcoef_function_2 = "0.0"
+   gcoef_function_3 = "0.0"
+   gcoef_function_4 = "0.0"
+   gcoef_function_5 = "0.0"
+}
+
+IBHierarchyIntegrator {
+   start_time          = START_TIME
+   end_time            = END_TIME
+   grow_dt             = GROW_DT
+   regrid_cfl_interval = REGRID_CFL_INTERVAL
+   dt_max              = DT
+   error_on_dt_change  = ERROR_ON_DT_CHANGE
+   enable_logging      = ENABLE_LOGGING
+}
+
+IBFESurfaceMethod {
+   IB_delta_fcn                 = IB_DELTA_FUNCTION
+   split_forces                 = SPLIT_FORCES
+   use_pressure_jump_conditions = USE_PRESSURE_JUMP_CONDITIONS
+   use_velocity_jump_conditions = USE_VELOCITY_JUMP_CONDITIONS
+   use_l2_lagrange_family       = USE_L2_LAGRANGE_FAMILY
+   use_consistent_mass_matrix   = USE_CONSISTENT_MASS_MATRIX
+   IB_point_density             = IB_POINT_DENSITY
+   p_calc_width				    = P_CALC_WIDTH
+   wss_calc_width			    = WSS_CALC_WIDTH
+   compute_fluid_traction       = COMPUTE_FLUID_TRACTION
+   min_ghost_cell_width 		= 6
+}
+
+INSCollocatedHierarchyIntegrator {
+   mu                            = MU
+   rho                           = RHO
+   start_time                    = START_TIME
+   end_time                      = END_TIME
+   grow_dt                       = GROW_DT
+   convective_time_stepping_type = CONVECTIVE_TS_TYPE
+   convective_op_type            = CONVECTIVE_OP_TYPE
+   convective_difference_form    = CONVECTIVE_FORM
+   normalize_pressure            = NORMALIZE_PRESSURE
+   cfl                           = CFL_MAX
+   dt_max                        = DT
+   using_vorticity_tagging       = VORTICITY_TAGGING
+   vorticity_abs_thresh          = 0.125,0.25,0.5,1,2
+   tag_buffer                    = TAG_BUFFER
+   output_U                      = OUTPUT_U
+   output_P                      = OUTPUT_P
+   output_F                      = OUTPUT_F
+   output_Omega                  = OUTPUT_OMEGA
+   output_Div_U                  = OUTPUT_DIV_U
+   enable_logging                = ENABLE_LOGGING
+   projection_method_type        = PROJECTION_METHOD_TYPE
+   use_2nd_order_pressure_update = SECOND_ORDER_PRESSURE_UPDATE
+}
+
+INSStaggeredHierarchyIntegrator {
+   mu                            = MU
+   rho                           = RHO
+   start_time                    = START_TIME
+   end_time                      = END_TIME
+   grow_dt                       = GROW_DT
+   convective_time_stepping_type = CONVECTIVE_TS_TYPE
+   convective_op_type            = CONVECTIVE_OP_TYPE
+   convective_difference_form    = CONVECTIVE_FORM
+   normalize_pressure            = NORMALIZE_PRESSURE
+   cfl                           = CFL_MAX
+   dt_max                        = DT
+   using_vorticity_tagging       = VORTICITY_TAGGING
+   vorticity_abs_thresh          = 0.125,0.25,0.5,1,2
+   tag_buffer                    = TAG_BUFFER
+   output_U                      = OUTPUT_U
+   output_P                      = OUTPUT_P
+   output_F                      = OUTPUT_F
+   output_Omega                  = OUTPUT_OMEGA
+   output_Div_U                  = OUTPUT_DIV_U
+   enable_logging                = ENABLE_LOGGING
+}
+
+Main {
+   solver_type = SOLVER_TYPE
+
+// log file parameters
+   log_file_name               = "IIM_3D.log"
+   log_all_nodes               = FALSE
+
+// visualization dump parameters
+   viz_writer                  = "VisIt","ExodusII"
+   viz_dump_interval           = int(0.05/DT)
+   viz_dump_dirname            = "viz_IIM_3D"
+   visit_number_procs_per_file = 1
+
+// restart dump parameters
+   restart_dump_interval       = 0
+   restart_dump_dirname        = "restart_IIM_3d"
+
+// hierarchy data dump parameters
+   data_dump_interval          = 1
+   data_dump_dirname           = "hier_data_IIM_3d"
+
+// timer dump parameters
+   timer_dump_interval         = 0
+}
+
+CartesianGeometry {
+   domain_boxes = [ (0,0,0),(N - 1,N - 1,N - 1) ]
+   x_lo = -0.25*L,-0.5*L,-0.5*L
+   x_up =  0.75*L, 0.5*L, 0.5*L
+   periodic_dimension = 0,0,0
+}
+
+GriddingAlgorithm {
+   max_levels = MAX_LEVELS
+   ratio_to_coarser {
+      level_1 = REF_RATIO,REF_RATIO,REF_RATIO
+      level_2 = REF_RATIO,REF_RATIO,REF_RATIO
+      level_3 = REF_RATIO,REF_RATIO,REF_RATIO
+      level_4 = REF_RATIO,REF_RATIO,REF_RATIO
+      level_5 = REF_RATIO,REF_RATIO,REF_RATIO
+   }
+   largest_patch_size {
+      level_0 = 512,512,512  // all finer levels will use same values as level_0
+   }
+   smallest_patch_size {
+      level_0 =   32,  32,  32  // all finer levels will use same values as level_0
+   }
+   efficiency_tolerance = 0.80e0  // min % of tag cells in new patch level
+   combine_efficiency   = 0.80e0  // chop box if sum of volumes of smaller boxes < efficiency * vol of large box
+}
+
+StandardTagAndInitialize {
+   tagging_method = "GRADIENT_DETECTOR"
+}
+
+LoadBalancer {
+   bin_pack_method     = "SPATIAL"
+   max_workload_factor = 1
+}
+
+TimerManager{
+   print_exclusive = FALSE
+   print_total = TRUE
+   print_threshold = 0.1
+   timer_list = "IBAMR::*::*","IBTK::*::*","*::*::*"
+}
diff --git a/ibtk/src/lagrangian/FEDataManager.cpp b/ibtk/src/lagrangian/FEDataManager.cpp
index f5dc7db2f..2369e6258 100644
--- a/ibtk/src/lagrangian/FEDataManager.cpp
+++ b/ibtk/src/lagrangian/FEDataManager.cpp
@@ -2885,20 +2885,78 @@ FEDataManager::updateQuadPointCountData(const int coarsest_ln, const int finest_
     return;
 } // updateQuadPointCountData
 
+
 std::vector<std::pair<Point, Point> >*
 FEDataManager::computeActiveElementBoundingBoxes()
 {
+    // Get the necessary FE data.
     const MeshBase& mesh = d_fe_data->d_es->get_mesh();
-    const System& X_system = d_fe_data->d_es->get_system(COORDINATES_SYSTEM_NAME);
+    const unsigned int n_elem = mesh.max_elem_id() + 1;
+    System& X_system = d_fe_data->d_es->get_system(COORDINATES_SYSTEM_NAME);
+    const unsigned int X_sys_num = X_system.number();
+    NumericVector<double>& X_vec = *X_system.solution;
+    NumericVector<double>& X_ghost_vec = *X_system.current_local_solution;
+    copy_and_synch(X_vec, X_ghost_vec, /*close_v_in*/ false);
+
+    // Compute the lower and upper bounds of all active local elements in the
+    // mesh.  Assumes nodal basis functions.
+    d_active_elem_bboxes.resize(n_elem);
+    std::fill(d_active_elem_bboxes.begin(), d_active_elem_bboxes.end(), std::make_pair(Point::Zero(), Point::Zero()));
+    std::vector<unsigned int> dof_indices;
+    MeshBase::const_element_iterator el_it = mesh.active_local_elements_begin();
+    const MeshBase::const_element_iterator el_end = mesh.active_local_elements_end();
+    for (; el_it != el_end; ++el_it)
+    {
+        const Elem* const elem = *el_it;
+        const unsigned int elem_id = elem->id();
+        Point& elem_lower_bound = d_active_elem_bboxes[elem_id].first;
+        Point& elem_upper_bound = d_active_elem_bboxes[elem_id].second;
+        elem_lower_bound = Point::Constant(std::numeric_limits<double>::max());
+        elem_upper_bound = Point::Constant(-std::numeric_limits<double>::max());
+
+        const unsigned int n_nodes = elem->n_nodes();
+        dof_indices.clear();
+        for (unsigned int k = 0; k < n_nodes; ++k)
+        {
+            const Node* const node = elem->node_ptr(k);
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                TBOX_ASSERT(node->n_dofs(X_sys_num, d) == 1);
+                dof_indices.push_back(node->dof_number(X_sys_num, d, 0));
+            }
+        }
+        std::vector<double> X_node;
+        X_ghost_vec.get(dof_indices, X_node);
+        for (unsigned int k = 0; k < n_nodes; ++k)
+        {
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                const double& X = X_node[k * NDIM + d];
+                elem_lower_bound[d] = std::min(elem_lower_bound[d], X);
+                elem_upper_bound[d] = std::max(elem_upper_bound[d], X);
+            }
+        }
+    }
 
-    const auto bboxes = get_global_active_element_bounding_boxes(mesh, X_system);
-    d_active_elem_bboxes.resize(bboxes.size());
-    for (std::size_t i = 0; i < bboxes.size(); ++i)
+    // Parallel sum elem_lower_bound and elem_upper_bound so that each process
+    // has access to the bounding box data for each active element in the mesh.
+    std::vector<double> d_active_elem_bboxes_flattened(2 * NDIM * n_elem);
+    for (unsigned int e = 0; e < n_elem; ++e)
+    {
+        for (unsigned int d = 0; d < NDIM; ++d)
+        {
+            d_active_elem_bboxes_flattened[2 * e * NDIM + d] = d_active_elem_bboxes[e].first[d];
+            d_active_elem_bboxes_flattened[(2 * e + 1) * NDIM + d] = d_active_elem_bboxes[e].second[d];
+        }
+    }
+    SAMRAI_MPI::sumReduction(&d_active_elem_bboxes_flattened[0],
+                             static_cast<int>(d_active_elem_bboxes_flattened.size()));
+    for (unsigned int e = 0; e < n_elem; ++e)
     {
-        for (int d = 0; d < NDIM; ++d)
+        for (unsigned int d = 0; d < NDIM; ++d)
         {
-            d_active_elem_bboxes[i].first[d] = bboxes[i].first(d);
-            d_active_elem_bboxes[i].second[d] = bboxes[i].second(d);
+            d_active_elem_bboxes[e].first[d] = d_active_elem_bboxes_flattened[2 * e * NDIM + d];
+            d_active_elem_bboxes[e].second[d] = d_active_elem_bboxes_flattened[(2 * e + 1) * NDIM + d];
         }
     }
     return &d_active_elem_bboxes;
diff --git a/include/ibamr/IBFESurfaceMethod.h b/include/ibamr/IBFESurfaceMethod.h
index 7e1b0b4d4..e4aa6c970 100644
--- a/include/ibamr/IBFESurfaceMethod.h
+++ b/include/ibamr/IBFESurfaceMethod.h
@@ -82,6 +82,16 @@ namespace IBAMR
  * \brief Class IBFESurfaceMethod is an implementation of the abstract base
  * class IBStrategy that provides functionality required by the IB method with
  * a finite element representation of a surface mesh.
+ * Additionally an immersed interface method (IIM) has been implemented with calculations
+ * of shear stress, pressure and total fluid traction.
+ *
+ * References:
+ * Kolahdouz et al., <A HREF="https://arxiv.org/abs/1812.06840"> An Immersed Interface
+ * Method for Faceted Surfaces
+ *
+ * \note To achieve best accuracy with IIM, using a tight relative convergence threshold
+ * of 1.0e-10 is recommended for both the Krylov solver of
+ * the $L^2$ projection steps as well as the subdomain Stokes solve of the NS solver.
  */
 class IBFESurfaceMethod : public IBStrategy
 {
@@ -92,7 +102,17 @@ public:
     static const std::string NORMAL_VELOCITY_SYSTEM_NAME;
     static const std::string PRESSURE_JUMP_SYSTEM_NAME;
     static const std::string TANGENTIAL_VELOCITY_SYSTEM_NAME;
+    static const std::array<std::string, NDIM> VELOCITY_JUMP_SYSTEM_NAME;
     static const std::string VELOCITY_SYSTEM_NAME;
+    static const std::string WSS_IN_SYSTEM_NAME;
+    static const std::string WSS_OUT_SYSTEM_NAME;
+    static const std::string PRESSURE_IN_SYSTEM_NAME;
+    static const std::string PRESSURE_OUT_SYSTEM_NAME;
+    static const std::string TAU_IN_SYSTEM_NAME;
+    static const std::string TAU_OUT_SYSTEM_NAME;
+
+    SAMRAI::tbox::Pointer<SAMRAI::pdat::CellVariable<NDIM, double> > p_var;
+    int p_scratch_idx, p_new_idx, p_current_idx;
 
     /*!
      * \brief Constructor.
@@ -276,6 +296,7 @@ public:
     /*!
      * Interpolate the Eulerian velocity to the curvilinear mesh at the
      * specified time within the current time interval.
+     * \note WSS is computed if the jump(s) in the fluid shear stress is applied.
      */
     void interpolateVelocity(
         int u_data_idx,
@@ -283,6 +304,21 @@ public:
         const std::vector<SAMRAI::tbox::Pointer<SAMRAI::xfer::RefineSchedule<NDIM> > >& u_ghost_fill_scheds,
         double data_time) override;
 
+    /*!
+     * Compute the fluid traction if all jump conditions are applied.
+     */
+    void computeFluidTraction(double current_time, unsigned int part = 0);
+
+    /*!
+     * Compute the interior/exterior pressure used in the calculation of the fluid traction (pressure jump condition needs to be applied).
+     */
+    void extrapolatePressureForTraction(int p_data_idx, double data_time, unsigned int part = 0);
+
+    /*!
+     * A wrapper to compute the interfacial pressure and fluid traction from the jumps.
+     */
+    void calculateInterfacialFluidForces(double data_time);
+
     /*!
      * Advance the positions of the Lagrangian structure using the forward Euler
      * method.
@@ -453,14 +489,29 @@ public:
 
 protected:
     /*!
-     * Impose (pressure) jump conditions.
+     * Impose the jump conditions.
      */
     void imposeJumpConditions(const int f_data_idx,
-                              libMesh::PetscVector<double>& DP_ghost_vec,
+                              libMesh::PetscVector<double>& P_jump_ghost_vec,
+                              std::array<libMesh::PetscVector<double>*, NDIM>& DU_jump_ghost_vec,
                               libMesh::PetscVector<double>& X_ghost_vec,
                               const double data_time,
                               const unsigned int part);
-
+    /*!
+     * \brief Helper function for checking possible double-counting
+     *  intesection points
+     */
+    void checkDoubleCountingIntersection(int axis,
+                                         const double* dx,
+                                         libMesh::VectorValue<double> n,
+                                         const libMesh::Point x,
+                                         const libMesh::Point& xi,
+                                         const SAMRAI::pdat::SideIndex<NDIM> i_s,
+                                         const SAMRAI::pdat::SideIndex<NDIM> i_s_prime,
+                                         const std::vector<libMesh::Point> candidate_coords,
+                                         const std::vector<libMesh::Point> candidate_ref_coords,
+                                         const std::vector<libMesh::VectorValue<double> > candidate_normals,
+                                         bool found_same_intersection_point);
     /*!
      * \brief Initialize the physical coordinates using the supplied coordinate
      * mapping function.  If no function is provided, the initial coordinates
@@ -507,6 +558,19 @@ protected:
 
     /*
      * FE data associated with this object.
+     * d_X_systems: coordinates system
+     * d_F_systems: IB force system
+     * d_U_systems: velocity system
+     * d_U_n_systems: normal velocity system
+     * d_U_t_systems: tangential velocity system
+     * d_P_jump_systems: pressure jump system [[p]] = - F(X,t).n(x,t)/J(X,t)
+     * d_DU_jump_systems:
+     * d_WSS_in_systems: one sided interior shear stress system
+     * d_WSS_out_systems: one sided exterior shear stress system
+     * d_P_in_systems: one sided interior pressure system
+     * d_P_out_systems: one sided exterior pressure system
+     * d_TAU_in_systems: interior fluid traction system
+     * d_TAU_out_systems: exterior fluid traction system
      */
     std::vector<libMesh::MeshBase*> d_meshes;
     int d_max_level_number;
@@ -515,14 +579,24 @@ protected:
     const unsigned int d_num_parts = 1;
     std::vector<IBTK::FEDataManager*> d_fe_data_managers;
     SAMRAI::hier::IntVector<NDIM> d_ghosts = 0;
-    std::vector<libMesh::System*> d_X_systems, d_U_systems, d_U_n_systems, d_U_t_systems, d_F_systems, d_DP_systems;
+    std::vector<libMesh::System*> d_X_systems, d_U_systems, d_U_n_systems, d_U_t_systems, d_F_systems, d_P_jump_systems,
+        d_WSS_in_systems, d_WSS_out_systems, d_P_in_systems, d_P_out_systems, d_TAU_in_systems, d_TAU_out_systems;
+    std::vector<std::array<libMesh::System*, NDIM> > d_DU_jump_systems;
     std::vector<libMesh::PetscVector<double>*> d_X_current_vecs, d_X_new_vecs, d_X_half_vecs, d_X0_vecs,
         d_X_IB_ghost_vecs;
     std::vector<libMesh::PetscVector<double>*> d_U_current_vecs, d_U_new_vecs, d_U_half_vecs;
     std::vector<libMesh::PetscVector<double>*> d_U_n_current_vecs, d_U_n_new_vecs, d_U_n_half_vecs;
     std::vector<libMesh::PetscVector<double>*> d_U_t_current_vecs, d_U_t_new_vecs, d_U_t_half_vecs;
+
     std::vector<libMesh::PetscVector<double>*> d_F_half_vecs, d_F_IB_ghost_vecs;
-    std::vector<libMesh::PetscVector<double>*> d_DP_half_vecs, d_DP_IB_ghost_vecs;
+    std::vector<libMesh::PetscVector<double>*> d_P_jump_half_vecs, d_P_jump_IB_ghost_vecs;
+    std::vector<libMesh::PetscVector<double>*> d_P_in_half_vecs, d_P_in_IB_ghost_vecs;
+    std::vector<libMesh::PetscVector<double>*> d_P_out_half_vecs, d_P_out_IB_ghost_vecs;
+    std::vector<std::array<libMesh::PetscVector<double>*, NDIM> > d_DU_jump_half_vecs, d_DU_jump_IB_ghost_vecs;
+    std::vector<libMesh::PetscVector<double>*> d_WSS_in_half_vecs, d_WSS_in_IB_ghost_vecs;
+    std::vector<libMesh::PetscVector<double>*> d_WSS_out_half_vecs, d_WSS_out_IB_ghost_vecs;
+    std::vector<libMesh::PetscVector<double>*> d_TAU_in_half_vecs, d_TAU_in_IB_ghost_vecs;
+    std::vector<libMesh::PetscVector<double>*> d_TAU_out_half_vecs, d_TAU_out_IB_ghost_vecs;
 
     bool d_fe_equation_systems_initialized = false, d_fe_data_initialized = false;
 
@@ -534,7 +608,11 @@ protected:
     IBTK::FEDataManager::WorkloadSpec d_default_workload_spec;
     std::vector<IBTK::FEDataManager::InterpSpec> d_interp_spec;
     std::vector<IBTK::FEDataManager::SpreadSpec> d_spread_spec;
-    bool d_use_jump_conditions = false;
+    bool d_use_pressure_jump_conditions = false;
+    bool d_use_velocity_jump_conditions = false;
+    bool d_use_l2_lagrange_family = false;
+    bool d_compute_fluid_traction = false;
+    bool d_traction_interior_side = false;
     bool d_perturb_fe_mesh_nodes = true;
     bool d_normalize_pressure_jump = false;
     std::vector<libMesh::FEFamily> d_fe_family;
@@ -543,6 +621,9 @@ protected:
     std::vector<libMesh::Order> d_default_quad_order;
     bool d_use_consistent_mass_matrix = true;
     bool d_use_direct_forcing = false;
+    double d_wss_calc_width = 0.0;
+    double d_p_calc_width = 0.0;
+    double d_traction_activation_time = 0.0;
 
     /*
      * Functions used to compute the initial coordinates of the Lagrangian mesh.
diff --git a/src/IB/IBFESurfaceMethod.cpp b/src/IB/IBFESurfaceMethod.cpp
index 848d1ece1..655b15844 100644
--- a/src/IB/IBFESurfaceMethod.cpp
+++ b/src/IB/IBFESurfaceMethod.cpp
@@ -143,13 +143,28 @@ libmesh_restart_file_name(const std::string& restart_dump_dirname,
 }
 } // namespace
 
-const std::string IBFESurfaceMethod::COORDS_SYSTEM_NAME = "IB coordinates system";
-const std::string IBFESurfaceMethod::COORD_MAPPING_SYSTEM_NAME = "IB coordinate mapping system";
+const std::string IBFESurfaceMethod::COORDS_SYSTEM_NAME = "coordinates system";
+const std::string IBFESurfaceMethod::COORD_MAPPING_SYSTEM_NAME = "coordinate mapping system";
 const std::string IBFESurfaceMethod::FORCE_SYSTEM_NAME = "IB force system";
-const std::string IBFESurfaceMethod::NORMAL_VELOCITY_SYSTEM_NAME = "IB normal velocity system";
-const std::string IBFESurfaceMethod::PRESSURE_JUMP_SYSTEM_NAME = "IB [[p]] system";
-const std::string IBFESurfaceMethod::TANGENTIAL_VELOCITY_SYSTEM_NAME = "IB tangential velocity system";
-const std::string IBFESurfaceMethod::VELOCITY_SYSTEM_NAME = "IB velocity system";
+const std::string IBFESurfaceMethod::VELOCITY_SYSTEM_NAME = "velocity system";
+const std::string IBFESurfaceMethod::NORMAL_VELOCITY_SYSTEM_NAME = "normal velocity system";
+const std::string IBFESurfaceMethod::TANGENTIAL_VELOCITY_SYSTEM_NAME = "tangential velocity system";
+const std::string IBFESurfaceMethod::PRESSURE_JUMP_SYSTEM_NAME = "[[p]] system";
+const std::string IBFESurfaceMethod::WSS_IN_SYSTEM_NAME = "One sided interior wall shear stress system";
+const std::string IBFESurfaceMethod::WSS_OUT_SYSTEM_NAME = "One sided exterior wall shear stress system";
+const std::string IBFESurfaceMethod::PRESSURE_IN_SYSTEM_NAME = "One sided interior pressure system";
+const std::string IBFESurfaceMethod::PRESSURE_OUT_SYSTEM_NAME = "One sided exterior pressure system";
+const std::string IBFESurfaceMethod::TAU_IN_SYSTEM_NAME = "Interior traction system";
+const std::string IBFESurfaceMethod::TAU_OUT_SYSTEM_NAME = "Exterior traction system";
+const std::array<std::string, NDIM> IBFESurfaceMethod::VELOCITY_JUMP_SYSTEM_NAME = {
+    { "velocity [[du]] jump system",
+      "velocity [[dv]] jump system"
+#if (NDIM == 3)
+      ,
+      "velocity [[dw]] jump system"
+#endif
+    }
+};
 
 /////////////////////////////// PUBLIC ///////////////////////////////////////
 
@@ -163,7 +178,7 @@ IBFESurfaceMethod::IBFESurfaceMethod(const std::string& object_name,
 {
     commonConstructor(object_name,
                       input_db,
-                      std::vector<MeshBase*>(1, mesh),
+                      std::vector<MeshBase*>(d_num_parts, mesh),
                       max_level_number,
                       register_for_restart,
                       restart_read_dirname,
@@ -315,9 +330,37 @@ IBFESurfaceMethod::preprocessIntegrateData(double current_time, double new_time,
     d_F_half_vecs.resize(d_num_parts);
     d_F_IB_ghost_vecs.resize(d_num_parts);
 
-    d_DP_systems.resize(d_num_parts);
-    d_DP_half_vecs.resize(d_num_parts);
-    d_DP_IB_ghost_vecs.resize(d_num_parts);
+    d_P_jump_systems.resize(d_num_parts);
+    d_P_jump_half_vecs.resize(d_num_parts);
+    d_P_jump_IB_ghost_vecs.resize(d_num_parts);
+
+    d_P_in_systems.resize(d_num_parts);
+    d_P_in_half_vecs.resize(d_num_parts);
+    d_P_in_IB_ghost_vecs.resize(d_num_parts);
+    
+    d_P_out_systems.resize(d_num_parts);
+    d_P_out_half_vecs.resize(d_num_parts);
+    d_P_out_IB_ghost_vecs.resize(d_num_parts);
+
+    d_DU_jump_systems.resize(d_num_parts);
+    d_DU_jump_half_vecs.resize(d_num_parts);
+    d_DU_jump_IB_ghost_vecs.resize(d_num_parts);
+
+    d_WSS_in_systems.resize(d_num_parts);
+    d_WSS_in_half_vecs.resize(d_num_parts);
+    d_WSS_in_IB_ghost_vecs.resize(d_num_parts);
+    
+    d_WSS_out_systems.resize(d_num_parts);
+    d_WSS_out_half_vecs.resize(d_num_parts);
+    d_WSS_out_IB_ghost_vecs.resize(d_num_parts);
+
+    d_TAU_in_systems.resize(d_num_parts);
+    d_TAU_in_half_vecs.resize(d_num_parts);
+    d_TAU_in_IB_ghost_vecs.resize(d_num_parts);
+    
+    d_TAU_out_systems.resize(d_num_parts);
+    d_TAU_out_half_vecs.resize(d_num_parts);
+    d_TAU_out_IB_ghost_vecs.resize(d_num_parts);
 
     for (unsigned int part = 0; part < d_num_parts; ++part)
     {
@@ -358,94 +401,266 @@ IBFESurfaceMethod::preprocessIntegrateData(double current_time, double new_time,
         d_F_IB_ghost_vecs[part] = dynamic_cast<PetscVector<double>*>(
             d_fe_data_managers[part]->buildGhostedSolutionVector(FORCE_SYSTEM_NAME, /*localize_data*/ false));
 
-        if (d_use_jump_conditions)
+        if (d_use_pressure_jump_conditions)
         {
-            d_DP_systems[part] = &d_equation_systems[part]->get_system(PRESSURE_JUMP_SYSTEM_NAME);
-            d_DP_half_vecs[part] = dynamic_cast<PetscVector<double>*>(d_DP_systems[part]->current_local_solution.get());
-            d_DP_IB_ghost_vecs[part] =
+            d_P_jump_systems[part] = &d_equation_systems[part]->get_system(PRESSURE_JUMP_SYSTEM_NAME);
+            d_P_jump_half_vecs[part] =
+                dynamic_cast<PetscVector<double>*>(d_P_jump_systems[part]->current_local_solution.get());
+            d_P_jump_IB_ghost_vecs[part] =
                 dynamic_cast<PetscVector<double>*>(d_fe_data_managers[part]->buildGhostedSolutionVector(
                     PRESSURE_JUMP_SYSTEM_NAME, /*localize_data*/ false));
+
+            d_P_in_systems[part] = &d_equation_systems[part]->get_system(PRESSURE_IN_SYSTEM_NAME);
+            d_P_in_half_vecs[part] = dynamic_cast<PetscVector<double>*>(d_P_in_systems[part]->current_local_solution.get());
+            d_P_in_IB_ghost_vecs[part] = dynamic_cast<PetscVector<double>*>(
+                d_fe_data_managers[part]->buildGhostedSolutionVector(PRESSURE_IN_SYSTEM_NAME, /*localize_data*/ false));
+
+            d_P_out_systems[part] = &d_equation_systems[part]->get_system(PRESSURE_OUT_SYSTEM_NAME);
+            d_P_out_half_vecs[part] = dynamic_cast<PetscVector<double>*>(d_P_out_systems[part]->current_local_solution.get());
+            d_P_out_IB_ghost_vecs[part] = dynamic_cast<PetscVector<double>*>(
+                d_fe_data_managers[part]->buildGhostedSolutionVector(PRESSURE_OUT_SYSTEM_NAME, /*localize_data*/ false));
+        }
+
+        if (d_use_velocity_jump_conditions)
+        {
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                d_DU_jump_systems[part][d] = &d_equation_systems[part]->get_system(VELOCITY_JUMP_SYSTEM_NAME[d]);
+                d_DU_jump_half_vecs[part][d] =
+                    dynamic_cast<PetscVector<double>*>(d_DU_jump_systems[part][d]->current_local_solution.get());
+                d_DU_jump_IB_ghost_vecs[part][d] =
+                    dynamic_cast<PetscVector<double>*>(d_fe_data_managers[part]->buildGhostedSolutionVector(
+                        VELOCITY_JUMP_SYSTEM_NAME[d], /*localize_data*/ false));
+            }
+            d_WSS_in_systems[part] = &d_equation_systems[part]->get_system(WSS_IN_SYSTEM_NAME);
+            d_WSS_in_half_vecs[part] =
+                dynamic_cast<PetscVector<double>*>(d_WSS_in_systems[part]->current_local_solution.get());
+            d_WSS_in_IB_ghost_vecs[part] = dynamic_cast<PetscVector<double>*>(
+                d_fe_data_managers[part]->buildGhostedSolutionVector(WSS_IN_SYSTEM_NAME, /*localize_data*/ false));
+                
+            d_WSS_out_systems[part] = &d_equation_systems[part]->get_system(WSS_OUT_SYSTEM_NAME);
+            d_WSS_out_half_vecs[part] =
+                dynamic_cast<PetscVector<double>*>(d_WSS_out_systems[part]->current_local_solution.get());
+            d_WSS_out_IB_ghost_vecs[part] = dynamic_cast<PetscVector<double>*>(
+                d_fe_data_managers[part]->buildGhostedSolutionVector(WSS_OUT_SYSTEM_NAME, /*localize_data*/ false));
+        }
+        if (d_use_velocity_jump_conditions && d_use_pressure_jump_conditions)
+        {
+            d_TAU_in_systems[part] = &d_equation_systems[part]->get_system(TAU_IN_SYSTEM_NAME);
+            d_TAU_in_half_vecs[part] =
+                dynamic_cast<PetscVector<double>*>(d_TAU_in_systems[part]->current_local_solution.get());
+            d_TAU_in_IB_ghost_vecs[part] = dynamic_cast<PetscVector<double>*>(
+                d_fe_data_managers[part]->buildGhostedSolutionVector(TAU_IN_SYSTEM_NAME, /*localize_data*/ false));
+                
+            d_TAU_out_systems[part] = &d_equation_systems[part]->get_system(TAU_OUT_SYSTEM_NAME);
+            d_TAU_out_half_vecs[part] =
+                dynamic_cast<PetscVector<double>*>(d_TAU_out_systems[part]->current_local_solution.get());
+            d_TAU_out_IB_ghost_vecs[part] = dynamic_cast<PetscVector<double>*>(
+                d_fe_data_managers[part]->buildGhostedSolutionVector(TAU_OUT_SYSTEM_NAME, /*localize_data*/ false));
         }
 
         // Initialize X^{n+1/2} and X^{n+1} to equal X^{n}, and initialize
         // U^{n+1/2} and U^{n+1} to equal U^{n}.
-        d_X_systems[part]->solution->close();
-        d_X_systems[part]->solution->localize(*d_X_current_vecs[part]);
-        d_X_systems[part]->solution->localize(*d_X_new_vecs[part]);
-        d_X_systems[part]->solution->localize(*d_X_half_vecs[part]);
+        *d_X_current_vecs[part] = *d_X_systems[part]->solution;
+        *d_X_new_vecs[part] = *d_X_current_vecs[part];
+        *d_X_half_vecs[part] = *d_X_current_vecs[part];
+
+        *d_U_current_vecs[part] = *d_U_systems[part]->solution;
+        *d_U_new_vecs[part] = *d_U_current_vecs[part];
+        *d_U_half_vecs[part] = *d_U_current_vecs[part];
+
+        *d_U_n_current_vecs[part] = *d_U_n_systems[part]->solution;
+        *d_U_n_new_vecs[part] = *d_U_n_current_vecs[part];
+        *d_U_n_half_vecs[part] = *d_U_n_current_vecs[part];
 
-        d_U_systems[part]->solution->close();
-        d_U_systems[part]->solution->localize(*d_U_current_vecs[part]);
-        d_U_systems[part]->solution->localize(*d_U_new_vecs[part]);
-        d_U_systems[part]->solution->localize(*d_U_half_vecs[part]);
+        *d_U_t_current_vecs[part] = *d_U_t_systems[part]->solution;
+        *d_U_t_new_vecs[part] = *d_U_t_current_vecs[part];
+        *d_U_t_half_vecs[part] = *d_U_t_current_vecs[part];
 
-        d_U_n_systems[part]->solution->close();
-        d_U_n_systems[part]->solution->localize(*d_U_n_current_vecs[part]);
-        d_U_n_systems[part]->solution->localize(*d_U_n_new_vecs[part]);
-        d_U_n_systems[part]->solution->localize(*d_U_n_half_vecs[part]);
+        *d_F_half_vecs[part] = *d_F_systems[part]->solution;
 
-        d_U_t_systems[part]->solution->close();
-        d_U_t_systems[part]->solution->localize(*d_U_t_current_vecs[part]);
-        d_U_t_systems[part]->solution->localize(*d_U_t_new_vecs[part]);
-        d_U_t_systems[part]->solution->localize(*d_U_t_half_vecs[part]);
+        if (d_use_pressure_jump_conditions)
+        {
+            *d_P_jump_half_vecs[part] = *d_P_jump_systems[part]->solution;
+            *d_P_in_half_vecs[part] = *d_P_in_systems[part]->solution;
+            *d_P_out_half_vecs[part] = *d_P_out_systems[part]->solution;
+        }
 
-        d_F_systems[part]->solution->close();
-        d_F_systems[part]->solution->localize(*d_F_half_vecs[part]);
+        if (d_use_velocity_jump_conditions)
+        {
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                *d_DU_jump_half_vecs[part][d] = *d_DU_jump_systems[part][d]->solution;
+            }
 
-        if (d_use_jump_conditions)
+            *d_WSS_in_half_vecs[part] = *d_WSS_in_systems[part]->solution;
+            *d_WSS_out_half_vecs[part] = *d_WSS_out_systems[part]->solution;
+        }
+        if (d_use_velocity_jump_conditions && d_use_pressure_jump_conditions)
         {
-            d_DP_systems[part]->solution->close();
-            d_DP_systems[part]->solution->localize(*d_DP_half_vecs[part]);
+            *d_TAU_in_half_vecs[part] = *d_TAU_in_systems[part]->solution;
+            *d_TAU_out_half_vecs[part] = *d_TAU_out_systems[part]->solution;
         }
     }
     return;
 } // preprocessIntegrateData
 
+void
+IBFESurfaceMethod::calculateInterfacialFluidForces(double data_time)
+{
+
+    for (unsigned part = 0; part < d_num_parts; ++part)
+    {
+        if ((!d_use_pressure_jump_conditions || !d_use_velocity_jump_conditions) && d_compute_fluid_traction)
+        {
+            TBOX_ERROR(
+                d_object_name << ": To compute the traction both velocity and preussure jumps need to be turned on!"
+                              << std::endl);
+        }
+
+        if (d_use_pressure_jump_conditions && d_use_velocity_jump_conditions)
+        {
+            const int coarsest_ln = 0;
+            const int finest_ln = d_hierarchy->getFinestLevelNumber();
+            VariableDatabase<NDIM>* var_db = VariableDatabase<NDIM>::getDatabase();
+            const int p_data_idx = var_db->mapVariableAndContextToIndex(
+                getINSHierarchyIntegrator()->getPressureVariable(), getINSHierarchyIntegrator()->getScratchContext());
+            for (int ln = coarsest_ln; ln <= finest_ln; ++ln)
+            {
+                const Pointer<PatchLevel<NDIM> > level = d_hierarchy->getPatchLevel(ln);
+                if (!level->checkAllocated(p_scratch_idx)) level->allocatePatchData(p_scratch_idx);
+            }
+
+            HierarchyCellDataOpsReal<NDIM, double> hier_cc_data_ops(d_hierarchy, coarsest_ln, finest_ln);
+            hier_cc_data_ops.copyData(p_scratch_idx, p_data_idx, /*interior only*/ false);
+
+            RefineAlgorithm<NDIM> ghost_fill_alg_p;
+            ghost_fill_alg_p.registerRefine(p_scratch_idx, p_scratch_idx, p_scratch_idx, NULL);
+            Pointer<RefineSchedule<NDIM> > ghost_fill_schd_p =
+                ghost_fill_alg_p.createSchedule(d_hierarchy->getPatchLevel(finest_ln));
+            ghost_fill_schd_p->fillData(data_time);
+            extrapolatePressureForTraction(p_scratch_idx, data_time, part);
+
+            if (d_compute_fluid_traction && d_traction_activation_time <= data_time)
+            {
+                computeFluidTraction(data_time, part);
+            }
+        }
+    }
+
+} // calculateInterfacialFluidForces
+
 void
 IBFESurfaceMethod::postprocessIntegrateData(double /*current_time*/, double /*new_time*/, int /*num_cycles*/)
 {
+
+    batch_vec_ghost_update({ d_X_new_vecs,
+                             d_U_new_vecs,
+                             d_U_n_new_vecs,
+                             d_U_t_new_vecs,
+                             d_F_half_vecs,
+                             d_WSS_in_half_vecs,
+                             d_WSS_out_half_vecs,
+                             d_P_in_half_vecs,
+                             d_P_out_half_vecs,
+                             d_P_jump_half_vecs,
+                             d_TAU_in_half_vecs,
+                             d_TAU_out_half_vecs },
+                           INSERT_VALUES,
+                           SCATTER_FORWARD);
+                           
+                           
+
     for (unsigned part = 0; part < d_num_parts; ++part)
     {
+        if ((!d_use_pressure_jump_conditions || !d_use_velocity_jump_conditions) && d_compute_fluid_traction)
+        {
+            TBOX_ERROR(
+                d_object_name << ": To compute the traction both velocity and preussure jumps need to be turned on!"
+                              << std::endl);
+        }
+
+        if (d_use_pressure_jump_conditions && d_use_velocity_jump_conditions)
+        {
+            const int coarsest_ln = 0;
+            const int finest_ln = d_hierarchy->getFinestLevelNumber();
+            VariableDatabase<NDIM>* var_db = VariableDatabase<NDIM>::getDatabase();
+            const int p_data_idx = var_db->mapVariableAndContextToIndex(
+                getINSHierarchyIntegrator()->getPressureVariable(), getINSHierarchyIntegrator()->getScratchContext());
+            for (int ln = coarsest_ln; ln <= finest_ln; ++ln)
+            {
+                const Pointer<PatchLevel<NDIM> > level = d_hierarchy->getPatchLevel(ln);
+                if (!level->checkAllocated(p_scratch_idx)) level->allocatePatchData(p_scratch_idx);
+            }
+
+            HierarchyCellDataOpsReal<NDIM, double> hier_cc_data_ops(d_hierarchy, coarsest_ln, finest_ln);
+            hier_cc_data_ops.copyData(p_scratch_idx, p_data_idx, /*interior only*/ false);
+
+            RefineAlgorithm<NDIM> ghost_fill_alg_p;
+            ghost_fill_alg_p.registerRefine(p_scratch_idx, p_scratch_idx, p_scratch_idx, NULL);
+            Pointer<RefineSchedule<NDIM> > ghost_fill_schd_p =
+                ghost_fill_alg_p.createSchedule(d_hierarchy->getPatchLevel(finest_ln));
+            ghost_fill_schd_p->fillData(d_new_time);
+            extrapolatePressureForTraction(p_scratch_idx, d_new_time, part);
+
+            if (d_compute_fluid_traction && d_traction_activation_time <= d_current_time)
+            {
+                computeFluidTraction(d_new_time, part);
+            }
+        }
+
         // Reset time-dependent Lagrangian data.
-        d_X_new_vecs[part]->close();
         *d_X_systems[part]->solution = *d_X_new_vecs[part];
-        d_X_systems[part]->solution->close();
-        d_X_systems[part]->solution->localize(*d_X_systems[part]->current_local_solution);
+        *d_X_systems[part]->current_local_solution = *d_X_new_vecs[part];
         delete d_X_new_vecs[part];
         delete d_X_half_vecs[part];
 
-        d_U_new_vecs[part]->close();
         *d_U_systems[part]->solution = *d_U_new_vecs[part];
-        d_U_systems[part]->solution->close();
-        d_U_systems[part]->solution->localize(*d_U_systems[part]->current_local_solution);
+        *d_U_systems[part]->current_local_solution = *d_U_new_vecs[part];
         delete d_U_new_vecs[part];
         delete d_U_half_vecs[part];
 
-        d_U_n_new_vecs[part]->close();
         *d_U_n_systems[part]->solution = *d_U_n_new_vecs[part];
-        d_U_n_systems[part]->solution->close();
-        d_U_n_systems[part]->solution->localize(*d_U_n_systems[part]->current_local_solution);
+        *d_U_n_systems[part]->current_local_solution = *d_U_n_new_vecs[part];
         delete d_U_n_new_vecs[part];
         delete d_U_n_half_vecs[part];
 
-        d_U_t_new_vecs[part]->close();
         *d_U_t_systems[part]->solution = *d_U_t_new_vecs[part];
-        d_U_t_systems[part]->solution->close();
-        d_U_t_systems[part]->solution->localize(*d_U_t_systems[part]->current_local_solution);
+        *d_U_t_systems[part]->current_local_solution = *d_U_t_new_vecs[part];
         delete d_U_t_new_vecs[part];
         delete d_U_t_half_vecs[part];
 
-        d_F_half_vecs[part]->close();
         *d_F_systems[part]->solution = *d_F_half_vecs[part];
-        d_F_systems[part]->solution->close();
-        d_F_systems[part]->solution->localize(*d_F_systems[part]->current_local_solution);
+        *d_F_systems[part]->current_local_solution = *d_F_half_vecs[part];
+
+        if (d_use_pressure_jump_conditions)
+        {
+            *d_P_jump_systems[part]->solution = *d_P_jump_half_vecs[part];
+            *d_P_jump_systems[part]->current_local_solution = *d_P_jump_half_vecs[part];
+            *d_P_in_systems[part]->solution = *d_P_in_half_vecs[part];
+            *d_P_in_systems[part]->current_local_solution = *d_P_in_half_vecs[part];
+            *d_P_out_systems[part]->solution = *d_P_out_half_vecs[part];
+            *d_P_out_systems[part]->current_local_solution = *d_P_out_half_vecs[part];
+        }
 
-        if (d_use_jump_conditions)
+        if (d_use_velocity_jump_conditions)
+        {
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                *d_DU_jump_systems[part][d]->solution = *d_DU_jump_half_vecs[part][d];
+                *d_DU_jump_systems[part][d]->current_local_solution = *d_DU_jump_half_vecs[part][d];
+            }
+            *d_WSS_in_systems[part]->solution = *d_WSS_in_half_vecs[part];
+            *d_WSS_in_systems[part]->current_local_solution = *d_WSS_in_half_vecs[part];
+            *d_WSS_out_systems[part]->solution = *d_WSS_out_half_vecs[part];
+            *d_WSS_out_systems[part]->current_local_solution = *d_WSS_out_half_vecs[part];
+        }
+        if (d_use_pressure_jump_conditions && d_use_velocity_jump_conditions)
         {
-            d_DP_half_vecs[part]->close();
-            *d_DP_systems[part]->solution = *d_DP_half_vecs[part];
-            d_DP_systems[part]->solution->close();
-            d_DP_systems[part]->solution->localize(*d_DP_systems[part]->current_local_solution);
+            *d_TAU_in_systems[part]->solution = *d_TAU_in_half_vecs[part];
+            *d_TAU_in_systems[part]->current_local_solution = *d_TAU_in_half_vecs[part];
+            *d_TAU_out_systems[part]->solution = *d_TAU_out_half_vecs[part];
+            *d_TAU_out_systems[part]->current_local_solution = *d_TAU_out_half_vecs[part];
         }
 
         // Update the coordinate mapping dX = X - s.
@@ -477,9 +692,37 @@ IBFESurfaceMethod::postprocessIntegrateData(double /*current_time*/, double /*ne
     d_F_half_vecs.clear();
     d_F_IB_ghost_vecs.clear();
 
-    d_DP_systems.clear();
-    d_DP_half_vecs.clear();
-    d_DP_IB_ghost_vecs.clear();
+    d_P_jump_systems.clear();
+    d_P_jump_half_vecs.clear();
+    d_P_jump_IB_ghost_vecs.clear();
+
+    d_DU_jump_systems.clear();
+    d_DU_jump_half_vecs.clear();
+    d_DU_jump_IB_ghost_vecs.clear();
+
+    d_WSS_in_systems.clear();
+    d_WSS_in_half_vecs.clear();
+    d_WSS_in_IB_ghost_vecs.clear();
+    
+    d_WSS_out_systems.clear();
+    d_WSS_out_half_vecs.clear();
+    d_WSS_out_IB_ghost_vecs.clear();
+
+    d_P_in_systems.clear();
+    d_P_in_half_vecs.clear();
+    d_P_in_IB_ghost_vecs.clear();
+    
+    d_P_out_systems.clear();
+    d_P_out_half_vecs.clear();
+    d_P_out_IB_ghost_vecs.clear();
+
+    d_TAU_in_systems.clear();
+    d_TAU_in_half_vecs.clear();
+    d_TAU_in_IB_ghost_vecs.clear();
+    
+    d_TAU_out_systems.clear();
+    d_TAU_out_half_vecs.clear();
+    d_TAU_out_IB_ghost_vecs.clear();
 
     // Reset the current time step interval.
     d_current_time = std::numeric_limits<double>::quiet_NaN();
@@ -494,6 +737,15 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
                                        const std::vector<Pointer<RefineSchedule<NDIM> > >& u_ghost_fill_scheds,
                                        const double data_time)
 {
+    const double mu = getINSHierarchyIntegrator()->getStokesSpecifications()->getMu();
+
+    // Communicate ghost data.
+    for (const auto& u_ghost_fill_sched : u_ghost_fill_scheds)
+    {
+        if (u_ghost_fill_sched) u_ghost_fill_sched->fillData(data_time);
+    }
+    
+
     for (unsigned int part = 0; part < d_num_parts; ++part)
     {
         NumericVector<double>* U_vec = nullptr;
@@ -501,6 +753,7 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
         NumericVector<double>* U_t_vec = nullptr;
         NumericVector<double>* X_vec = nullptr;
         NumericVector<double>* X_ghost_vec = d_X_IB_ghost_vecs[part];
+        const std::array<PetscVector<double>*, NDIM>& DU_jump_ghost_vec = d_DU_jump_IB_ghost_vecs[part];
         if (MathUtilities<double>::equalEps(data_time, d_current_time))
         {
             U_vec = d_U_current_vecs[part];
@@ -522,7 +775,10 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
             U_t_vec = d_U_t_new_vecs[part];
             X_vec = d_X_new_vecs[part];
         }
-        X_vec->localize(*X_ghost_vec);
+        copy_and_synch(*X_vec, *X_ghost_vec);
+
+        NumericVector<double>* WSS_in_vec = d_WSS_in_half_vecs[part];
+        NumericVector<double>* WSS_out_vec = d_WSS_out_half_vecs[part];
 
         // Extract the mesh.
         EquationSystems* equation_systems = d_fe_data_managers[part]->getEquationSystems();
@@ -539,52 +795,102 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
         const DofMap& X_dof_map = X_system.get_dof_map();
         FEDataManager::SystemDofMapCache& X_dof_map_cache =
             *d_fe_data_managers[part]->getDofMapCache(COORDS_SYSTEM_NAME);
+        std::vector<std::vector<unsigned int> > U_dof_indices(NDIM);
+        std::vector<std::vector<unsigned int> > X_dof_indices(NDIM);
         FEType U_fe_type = U_dof_map.variable_type(0);
         for (unsigned d = 0; d < NDIM; ++d) TBOX_ASSERT(U_dof_map.variable_type(d) == U_fe_type);
         FEType X_fe_type = X_dof_map.variable_type(0);
         for (unsigned d = 0; d < NDIM; ++d) TBOX_ASSERT(X_dof_map.variable_type(d) == X_fe_type);
         TBOX_ASSERT(U_fe_type == X_fe_type);
-        FEType fe_type = U_fe_type;
-        std::unique_ptr<FEBase> fe = FEBase::build(dim, fe_type);
-        const std::vector<double>& JxW = fe->get_JxW();
-        const std::vector<std::vector<double> >& phi = fe->get_phi();
-        std::array<const std::vector<std::vector<double> >*, NDIM - 1> dphi_dxi;
-        dphi_dxi[0] = &fe->get_dphidxi();
-        if (NDIM > 2) dphi_dxi[1] = &fe->get_dphideta();
 
-        // Communicate any unsynchronized ghost data and extract the underlying
-        // solution data.
-        for (const auto& u_ghost_fill_sched : u_ghost_fill_scheds)
+        std::array<System*, NDIM> DU_jump_system;
+        std::array<const DofMap*, NDIM> DU_jump_dof_map;
+        std::array<FEDataManager::SystemDofMapCache*, NDIM> DU_jump_dof_map_cache;
+        std::array<std::vector<std::vector<unsigned int> >, NDIM> DU_jump_dof_indices;
+        FEType DU_jump_fe_type;
+        std::vector<std::vector<unsigned int> > WSS_out_dof_indices(NDIM);
+        System* WSS_out_system;
+        const DofMap* WSS_out_dof_map = NULL;
+        FEDataManager::SystemDofMapCache* WSS_out_dof_map_cache = NULL;
+
+        std::vector<std::vector<unsigned int> > WSS_in_dof_indices(NDIM);
+        System* WSS_in_system;
+        const DofMap* WSS_in_dof_map = NULL;
+        FEDataManager::SystemDofMapCache* WSS_in_dof_map_cache = NULL;
+
+        if (d_use_velocity_jump_conditions)
         {
-            if (u_ghost_fill_sched) u_ghost_fill_sched->fillData(data_time);
+            for (unsigned int i = 0; i < NDIM; ++i)
+            {
+                DU_jump_system[i] = &equation_systems->get_system(VELOCITY_JUMP_SYSTEM_NAME[i]);
+                DU_jump_dof_map[i] = &DU_jump_system[i]->get_dof_map();
+                DU_jump_dof_map_cache[i] = d_fe_data_managers[part]->getDofMapCache(VELOCITY_JUMP_SYSTEM_NAME[i]);
+                DU_jump_fe_type = DU_jump_dof_map[i]->variable_type(0);
+                for (unsigned int j = 0; j < NDIM; ++j)
+                {
+                    TBOX_ASSERT(DU_jump_dof_map[i]->variable_type(j) == DU_jump_fe_type);
+                }
+                DU_jump_dof_indices[i].resize(NDIM);
+            }
+
+            WSS_out_system = &equation_systems->get_system(WSS_OUT_SYSTEM_NAME);
+            WSS_out_dof_map = &WSS_out_system->get_dof_map();
+            WSS_out_dof_map_cache = d_fe_data_managers[part]->getDofMapCache(WSS_OUT_SYSTEM_NAME);
+            FEType WSS_out_fe_type = WSS_out_dof_map->variable_type(0);
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                TBOX_ASSERT(WSS_out_dof_map->variable_type(d) == WSS_out_fe_type);
+            }
+
+            WSS_in_system = &equation_systems->get_system(WSS_IN_SYSTEM_NAME);
+            WSS_in_dof_map = &WSS_in_system->get_dof_map();
+            WSS_in_dof_map_cache = d_fe_data_managers[part]->getDofMapCache(WSS_IN_SYSTEM_NAME);
+            FEType WSS_in_fe_type = WSS_in_dof_map->variable_type(0);
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                TBOX_ASSERT(WSS_in_dof_map->variable_type(d) == WSS_in_fe_type);
+            }
         }
+        FEType fe_type = U_fe_type;
+        std::unique_ptr<FEBase> fe_X = FEBase::build(dim, fe_type);
+        const std::vector<double>& JxW = fe_X->get_JxW();
+        const std::vector<std::vector<double> >& phi_X = fe_X->get_phi();
+        std::array<const std::vector<std::vector<double> >*, NDIM - 1> dphi_dxi;
+        dphi_dxi[0] = &fe_X->get_dphidxi();
+        if (NDIM > 2) dphi_dxi[1] = &fe_X->get_dphideta();
+
+        FEType fe_DU_jump_type = DU_jump_fe_type;
+        std::unique_ptr<FEBase> fe_DU_jump = FEBase::build(dim, fe_DU_jump_type);
+        const std::vector<double>& JxW_jump = fe_DU_jump->get_JxW();
+        const std::vector<std::vector<double> >& phi_DU_jump = fe_DU_jump->get_phi();
 
         X_ghost_vec->close();
-        auto X_petsc_vec = static_cast<PetscVector<double>*>(X_ghost_vec);
-        Vec X_global_vec = X_petsc_vec->vec();
-        Vec X_local_vec;
-        VecGhostGetLocalForm(X_global_vec, &X_local_vec);
-        double* X_local_soln;
-        VecGetArray(X_local_vec, &X_local_soln);
-        std::unique_ptr<NumericVector<double> > X0_vec = X_petsc_vec->clone();
-        X_system.get_vector("INITIAL_COORDINATES").localize(*X0_vec);
-        X0_vec->close();
 
         // Loop over the patches to interpolate values to the element quadrature
         // points from the grid, then use these values to compute the projection
         // of the interpolated velocity field onto the FE basis functions.
-        std::unique_ptr<NumericVector<double> > U_rhs_vec = U_vec->zero_clone();
+        UniquePtr<NumericVector<double> > U_rhs_vec = U_vec->zero_clone();
         std::vector<DenseVector<double> > U_rhs_e(NDIM);
-        std::unique_ptr<NumericVector<double> > U_n_rhs_vec = U_n_vec->zero_clone();
+        UniquePtr<NumericVector<double> > U_n_rhs_vec = U_n_vec->zero_clone();
         std::vector<DenseVector<double> > U_n_rhs_e(NDIM);
-        std::unique_ptr<NumericVector<double> > U_t_rhs_vec = U_t_vec->zero_clone();
+        UniquePtr<NumericVector<double> > U_t_rhs_vec = U_t_vec->zero_clone();
         std::vector<DenseVector<double> > U_t_rhs_e(NDIM);
-        boost::multi_array<double, 2> X_node, x_node;
-        std::vector<double> U_qp, x_qp;
-        VectorValue<double> U, U_n, U_t, N, n;
-        std::array<VectorValue<double>, 2> dX_dxi, dx_dxi;
 
-        std::vector<libMesh::dof_id_type> dof_id_scratch;
+        UniquePtr<NumericVector<double> > WSS_out_rhs_vec =
+            (d_use_velocity_jump_conditions ? WSS_out_vec->zero_clone() : UniquePtr<NumericVector<double> >());
+        DenseVector<double> WSS_out_rhs_e[NDIM];
+
+        UniquePtr<NumericVector<double> > WSS_in_rhs_vec =
+            (d_use_velocity_jump_conditions ? WSS_in_vec->zero_clone() : UniquePtr<NumericVector<double> >());
+        DenseVector<double> WSS_in_rhs_e[NDIM];
+
+        boost::multi_array<double, 2> x_node;
+        std::array<boost::multi_array<double, 2>, NDIM> DU_jump_node;
+        std::vector<double> U_qp, U_in_qp, U_out_qp, WSS_in_qp, WSS_out_qp, n_qp, x_qp, x_in_qp, x_out_qp;
+        std::array<std::vector<double>, NDIM> DU_jump_qp;
+        VectorValue<double> U, WSS_in, WSS_out, U_n, U_t, n;
+        std::array<VectorValue<double>, 2> dx_dxi;
+
         Pointer<PatchLevel<NDIM> > level = d_hierarchy->getPatchLevel(d_fe_data_managers[part]->getLevelNumber());
         int local_patch_num = 0;
         for (PatchLevel<NDIM>::Iterator p(level); p; p++, ++local_patch_num)
@@ -594,27 +900,64 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
                 d_fe_data_managers[part]->getActivePatchElementMap()[local_patch_num];
             const size_t num_active_patch_elems = patch_elems.size();
             if (!num_active_patch_elems) continue;
-
             const Pointer<Patch<NDIM> > patch = level->getPatch(p());
+            const Box<NDIM>& patch_box = patch->getBox();
             const Pointer<CartesianPatchGeometry<NDIM> > patch_geom = patch->getPatchGeometry();
             const double* const patch_dx = patch_geom->getDx();
             const double patch_dx_min = *std::min_element(patch_dx, patch_dx + NDIM);
+            const double* const patch_x_lower = patch_geom->getXLower();
+            const double* const patch_x_upper = patch_geom->getXUpper();
+
+            double diag_dis = 0.0;
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                diag_dis += patch_dx[d] * patch_dx[d];
+            }
+            const double dh = d_wss_calc_width * sqrt(diag_dis);
+            const int u_ghost_num = static_cast<int>(ceil(2.0 * dh / patch_dx_min));
+            std::array<double, NDIM> x_lower_gh, x_upper_gh;
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                x_lower_gh[d] = patch_x_lower[d] - (static_cast<double>(u_ghost_num)) * patch_dx[d];
+                x_upper_gh[d] = patch_x_upper[d] + (static_cast<double>(u_ghost_num)) * patch_dx[d];
+            }
+            double* x_upper_ghost = &x_upper_gh[0];
+            double* x_lower_ghost = &x_lower_gh[0];
 
-            // Setup vectors to store the values of F and X at the quadrature
-            // points.
-            unsigned int n_qp_patch = 0;
+            // Setup vectors to store the values of U, DU_j, x, and n at the
+            // quadrature points.
+            unsigned int n_qpoints_patch = 0;
             for (unsigned int e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
             {
                 Elem* const elem = patch_elems[e_idx];
-                const auto& X_dof_indices = X_dof_map_cache.dof_indices(elem);
-                get_values_for_interpolation(x_node, *X_petsc_vec, X_local_soln, X_dof_indices);
+                for (unsigned int axis = 0; axis < NDIM; ++axis)
+                {
+                    X_dof_map_cache.dof_indices(elem, X_dof_indices[axis], axis);
+                }
+                get_values_for_interpolation(x_node, *X_ghost_vec, X_dof_indices);
                 FEDataManager::updateInterpQuadratureRule(qrule, d_default_interp_spec, elem, x_node, patch_dx_min);
-                n_qp_patch += qrule->n_points();
+                n_qpoints_patch += qrule->n_points();
+            }
+
+            if (!n_qpoints_patch) continue;
+            U_qp.resize(NDIM * n_qpoints_patch);
+            WSS_in_qp.resize(NDIM * n_qpoints_patch);
+            WSS_out_qp.resize(NDIM * n_qpoints_patch);
+            U_in_qp.resize(NDIM * n_qpoints_patch);
+            U_out_qp.resize(NDIM * n_qpoints_patch);
+            x_qp.resize(NDIM * n_qpoints_patch);
+            x_in_qp.resize(NDIM * n_qpoints_patch);
+            x_out_qp.resize(NDIM * n_qpoints_patch);
+            n_qp.resize(NDIM * n_qpoints_patch);
+            for (unsigned int axis = 0; axis < NDIM; ++axis)
+            {
+                DU_jump_qp[axis].resize(NDIM * n_qpoints_patch);
             }
-            if (!n_qp_patch) continue;
-            U_qp.resize(NDIM * n_qp_patch);
-            x_qp.resize(NDIM * n_qp_patch);
             std::fill(U_qp.begin(), U_qp.end(), 0.0);
+            std::fill(U_in_qp.begin(), U_in_qp.end(), 0.0);
+            std::fill(U_out_qp.begin(), U_out_qp.end(), 0.0);
+            std::fill(WSS_in_qp.begin(), WSS_in_qp.end(), 0.0);
+            std::fill(WSS_out_qp.begin(), WSS_out_qp.end(), 0.0);
 
             // Loop over the elements and compute the positions of the quadrature points.
             qrule.reset();
@@ -622,30 +965,98 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
             for (unsigned int e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
             {
                 Elem* const elem = patch_elems[e_idx];
-                const auto& X_dof_indices = X_dof_map_cache.dof_indices(elem);
-                get_values_for_interpolation(x_node, *X_petsc_vec, X_local_soln, X_dof_indices);
+                for (unsigned int d = 0; d < NDIM; ++d)
+                {
+                    X_dof_map_cache.dof_indices(elem, X_dof_indices[d], d);
+                }
+                get_values_for_interpolation(x_node, *X_ghost_vec, X_dof_indices);
+                if (d_use_velocity_jump_conditions)
+                {
+                    for (unsigned int axis = 0; axis < NDIM; ++axis)
+                    {
+                        for (unsigned int d = 0; d < NDIM; ++d)
+                        {
+                            DU_jump_dof_map_cache[axis]->dof_indices(elem, DU_jump_dof_indices[axis][d], d);
+                        }
+                        get_values_for_interpolation(
+                            DU_jump_node[axis], *DU_jump_ghost_vec[axis], DU_jump_dof_indices[axis]);
+                    }
+                }
                 const bool qrule_changed =
                     FEDataManager::updateInterpQuadratureRule(qrule, d_default_interp_spec, elem, x_node, patch_dx_min);
-                if (qrule_changed) fe->attach_quadrature_rule(qrule.get());
-                fe->reinit(elem);
-                const unsigned int n_node = elem->n_nodes();
-                const unsigned int n_qp = qrule->n_points();
+                if (qrule_changed) fe_X->attach_quadrature_rule(qrule.get());
+                fe_X->reinit(elem);
+                if (d_use_velocity_jump_conditions)
+                {
+                    if (qrule_changed) fe_DU_jump->attach_quadrature_rule(qrule.get());
+                    fe_DU_jump->reinit(elem);
+                }
+                const unsigned int n_nodes = elem->n_nodes();
+                const unsigned int n_qpoints = qrule->n_points();
+
+                // Zero out the values prior to accumulation.
                 double* x_begin = &x_qp[NDIM * qp_offset];
-                std::fill(x_begin, x_begin + NDIM * n_qp, 0.0);
-                for (unsigned int k = 0; k < n_node; ++k)
+                std::fill(x_begin, x_begin + NDIM * n_qpoints, 0.0);
+
+                double* x_in_begin = &x_in_qp[NDIM * qp_offset];
+                std::fill(x_in_begin, x_in_begin + NDIM * n_qpoints, 0.0);
+
+                double* x_out_begin = &x_out_qp[NDIM * qp_offset];
+                std::fill(x_out_begin, x_out_begin + NDIM * n_qpoints, 0.0);
+                
+                double* n_begin = &n_qp[NDIM * qp_offset];
+                std::fill(n_begin, n_begin + NDIM * n_qpoints, 0.0);
+
+                for (unsigned int axis = 0; axis < NDIM; ++axis)
+                {
+                    double* DU_jump_begin = &DU_jump_qp[axis][NDIM * qp_offset];
+                    std::fill(DU_jump_begin, DU_jump_begin + NDIM * n_qpoints, 0.0);
+                }
+                // Interpolate x, du, and dv at the quadrature points via
+                // accumulation, e.g., x(qp) = sum_k x_k * phi_k(qp) for each
+                // qp.
+                for (unsigned int k = 0; k < n_nodes; ++k)
                 {
-                    for (unsigned int qp = 0; qp < n_qp; ++qp)
+                    for (unsigned int qp = 0; qp < n_qpoints; ++qp)
                     {
-                        const double& p = phi[k][qp];
+                        const double& p = phi_X[k][qp];
                         for (unsigned int d = 0; d < NDIM; ++d)
                         {
                             x_qp[NDIM * (qp_offset + qp) + d] += x_node[k][d] * p;
                         }
+                        if (d_use_velocity_jump_conditions)
+                        {
+                            const double& p2 = phi_DU_jump[k][qp];
+                            for (unsigned int axis = 0; axis < NDIM; ++axis)
+                            {
+                                for (unsigned int d = 0; d < NDIM; ++d)
+                                {
+                                    DU_jump_qp[axis][NDIM * (qp_offset + qp) + d] += DU_jump_node[axis][k][d] * p2;
+                                }
+                            }
+                        }
+                    }
+                }
+                for (unsigned int qp = 0; qp < n_qpoints; ++qp)
+                {
+                    for (unsigned int l = 0; l < NDIM - 1; ++l)
+                    {
+                        interpolate(dx_dxi[l], qp, x_node, *dphi_dxi[l]);
+                    }
+                    if (NDIM == 2)
+                    {
+                        dx_dxi[1] = VectorValue<double>(0.0, 0.0, 1.0);
+                    }
+                    n = (dx_dxi[0].cross(dx_dxi[1])).unit();
+                    for (unsigned int d = 0; d < NDIM; ++d)
+                    {
+                        n_qp[NDIM * (qp_offset + qp) + d] = n(d);
+                        x_in_qp[NDIM * (qp_offset + qp) + d] = x_qp[NDIM * (qp_offset + qp) + d] - n(d) * dh;
+                        x_out_qp[NDIM * (qp_offset + qp) + d] = x_qp[NDIM * (qp_offset + qp) + d] + n(d) * dh;
                     }
                 }
-                qp_offset += n_qp;
+                qp_offset += n_qpoints;
             }
-
             // Interpolate values from the Cartesian grid patch to the
             // quadrature points.
             //
@@ -653,6 +1064,9 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
             // that are within the patch interior.
             const Box<NDIM>& interp_box = patch->getBox();
             Pointer<PatchData<NDIM> > u_data = patch->getPatchData(u_data_idx);
+
+            const Box<NDIM> ghost_box = Box<NDIM>::grow(patch->getBox(), IntVector<NDIM>(u_ghost_num));
+
             Pointer<CellData<NDIM, double> > u_cc_data = u_data;
             if (u_cc_data)
             {
@@ -660,58 +1074,292 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
                     U_qp, NDIM, x_qp, NDIM, u_cc_data, patch, interp_box, d_default_interp_spec.kernel_fcn);
             }
             Pointer<SideData<NDIM, double> > u_sc_data = u_data;
-            if (u_sc_data)
+            if (u_sc_data && !d_use_velocity_jump_conditions)
             {
                 LEInteractor::interpolate(
                     U_qp, NDIM, x_qp, NDIM, u_sc_data, patch, interp_box, d_default_interp_spec.kernel_fcn);
             }
+            else if (u_sc_data && d_use_velocity_jump_conditions)
+            {
+                LEInteractor::interpolate(
+                    U_in_qp, NDIM, x_in_qp, NDIM, u_sc_data, patch, ghost_box, d_default_interp_spec.kernel_fcn);
+                    
+                LEInteractor::interpolate(
+                    U_out_qp, NDIM, x_out_qp, NDIM, u_sc_data, patch, ghost_box, d_default_interp_spec.kernel_fcn);
+
+                const IntVector<NDIM>& u_gcw = u_sc_data->getGhostCellWidth();
+                const int u_depth = u_sc_data->getDepth();
+                TBOX_ASSERT(u_depth == 1);
+
+                // Keep the quadrature points that are inside the interpolation box.
+                std::vector<int> local_indices;
+                for (unsigned int k = 0; k < n_qpoints_patch; ++k)
+                {
+                    const double* const x = &x_qp[NDIM * k];
+                    const Index<NDIM> i = IndexUtilities::getCellIndex(x, patch_geom, patch_box);
+                    if (interp_box.contains(i)) local_indices.push_back(k);
+
+                    const double* const x_in = &x_in_qp[NDIM * k];
+                    const Index<NDIM> in = IndexUtilities::getCellIndex(
+                        x_in, x_lower_ghost, x_upper_ghost, patch_geom->getDx(), ghost_box.lower(), ghost_box.upper());
+                        
+                    const double* const x_out = &x_out_qp[NDIM * k];
+                    const Index<NDIM> out = IndexUtilities::getCellIndex(
+                        x_out, x_lower_ghost, x_upper_ghost, patch_geom->getDx(), ghost_box.lower(), ghost_box.upper());
+
+                    // Some kind of assertation can be applied here using the indices of the cells away from the
+                    // interfce
+                }
+                if (local_indices.empty()) continue;
+                Index<NDIM> ic_lower, ic_upper, ic_center;
+                std::array<std::array<double, 2>, NDIM> w, wr;
+                std::vector<double> U_axis(n_qpoints_patch, 0.0);
+                std::vector<double> U_axis_o(n_qpoints_patch, 0.0);
+                Box<NDIM> side_boxes[NDIM];
+
+                for (int axis = 0; axis < NDIM; ++axis)
+                {
+                    side_boxes[axis] = SideGeometry<NDIM>::toSideBox(patch_box, axis);
+                }
+                for (unsigned int axis = 0; axis < NDIM; ++axis)
+                {
+                    IBTK::Point x_lower_axis, x_upper_axis;
+
+                    for (unsigned int d = 0; d < NDIM; ++d)
+                    {
+                        x_lower_axis[d] = patch_x_lower[d];
+                        x_upper_axis[d] = patch_x_upper[d];
+                    }
+                    x_lower_axis[axis] -= 0.5 * patch_dx[axis];
+                    x_upper_axis[axis] += 0.5 * patch_dx[axis];
+
+                    const Index<NDIM>& ilower = side_boxes[axis].lower();
+                    const Index<NDIM>& iupper = side_boxes[axis].upper();
+
+                    typedef boost::multi_array_types::extent_range range;
+                    boost::const_multi_array_ref<double, NDIM> u_sc_data_array(
+                        u_sc_data->getPointer(axis),
+                        (boost::extents[range(ilower[0] - u_gcw[0], iupper[0] + u_gcw[0] + 1)]
+                                       [range(ilower[1] - u_gcw[1], iupper[1] + u_gcw[1] + 1)]
+#if (NDIM == 3)
+                                       [range(ilower[2] - u_gcw[2], iupper[2] + u_gcw[2] + 1)]
+#endif
+                         ),
+                        boost::fortran_storage_order());
+
+                    for (unsigned int k = 0; k < local_indices.size(); ++k)
+                    {
+                        const int s = local_indices[k];
+                        IBTK::Point x, x_cell, xo, x_cell_o;
+                        const double* const dx = patch_dx;
+                        for (unsigned int d = 0; d < NDIM; ++d)
+                        {
+                            x[d] = x_qp[s * NDIM + d];
+                            ic_center[d] = ilower[d] + boost::math::iround((x[d] - x_lower_axis[d]) / dx[d] - 0.5);
+                            x_cell[d] = x_lower_axis[d] + ((ic_center[d] - ilower[d]) + 0.5) * dx[d];
+                            if (x[d] <= x_cell[d])
+                            {
+                                ic_lower[d] = ic_center[d] - 1;
+                                ic_upper[d] = ic_center[d];
+                            }
+                            else
+                            {
+                                ic_lower[d] = ic_center[d];
+                                ic_upper[d] = ic_center[d] + 1;
+                            }
+
+                            if (x[d] <= x_cell[d])
+                            {
+                                w[d][0] = (x_cell[d] - x[d]) / dx[d];
+                            }
+                            else
+                            {
+                                w[d][0] = 1.0 + (x_cell[d] - x[d]) / dx[d];
+                            }
+                            w[d][1] = 1.0 - w[d][0];
+                            wr[d][0] = +w[d][0];
+                            wr[d][1] = -w[d][1];
+                        }
+
+                        boost::multi_array<double, NDIM + 1> Ujump(
+                            boost::extents[range(ic_lower[0], ic_upper[0] + 1)][range(ic_lower[1], ic_upper[1] + 1)]
+#if (NDIM == 3)
+                                          [range(ic_lower[2], ic_upper[2] + 1)]
+#endif
+                                          [range(0, NDIM)]);
+
+                        boost::multi_array<double, NDIM + 1> interpCoeff(
+                            boost::extents[range(ic_lower[0], ic_upper[0] + 1)][range(ic_lower[1], ic_upper[1] + 1)]
+#if (NDIM == 3)
+                                          [range(ic_lower[2], ic_upper[2] + 1)]
+#endif
+                                          [range(0, NDIM)]);
+
+                        VectorValue<double> norm_vec, du_jump, coeff_vec, wrc;
+                        // Loop over indices to calculate the interp coefficients (Lower=0, Upper=1)
+
+                        for (int d = 0; d < NDIM; ++d) norm_vec(d) = n_qp[s * NDIM + d];
 
+                        Box<NDIM> stencil_box(ic_lower, ic_upper);
+
+                        for (int d = 0; d < NDIM; ++d)
+                        {
+                            for (BoxIterator<NDIM> b(stencil_box); b; b++)
+                            {
+                                const Index<NDIM>& ic = b();
+                                for (int j = 0; j < NDIM; ++j) wrc(j) = wr[j][ic_upper[j] - ic[j]];
+#if (NDIM == 2)
+                                interpCoeff[ic[0]][ic[1]][d] = (norm_vec * wrc) * norm_vec(d);
+#endif
+#if (NDIM == 3)
+                                interpCoeff[ic[0]][ic[1]][ic[2]][d] = (norm_vec * wrc) * norm_vec(d);
+#endif
+                            }
+                        }
+
+                        for (int d = 0; d < NDIM; ++d)
+                        {
+                            for (BoxIterator<NDIM> b(stencil_box); b; b++)
+                            {
+                                const Index<NDIM>& ic = b();
+                                for (int j = 0; j < NDIM; ++j) du_jump(j) = DU_jump_qp[d][s * NDIM + j];
+#if (NDIM == 2)
+                                coeff_vec =
+                                    VectorValue<double>(interpCoeff[ic[0]][ic[1]][0], interpCoeff[ic[0]][ic[1]][1]);
+                                Ujump[ic[0]][ic[1]][d] = dx[0] * w[0][ic[0] - ic_lower[0]] * w[1][ic[1] - ic_lower[1]] *
+                                                         (coeff_vec * du_jump);
+#endif
+
+#if (NDIM == 3)
+                                coeff_vec = VectorValue<double>(interpCoeff[ic[0]][ic[1]][ic[2]][0],
+                                                                interpCoeff[ic[0]][ic[1]][ic[2]][1],
+                                                                interpCoeff[ic[0]][ic[1]][ic[2]][2]);
+                                Ujump[ic[0]][ic[1]][ic[2]][d] = dx[0] * w[0][ic[0] - ic_lower[0]] *
+                                                                w[1][ic[1] - ic_lower[1]] * w[2][ic[2] - ic_lower[2]] *
+                                                                (coeff_vec * du_jump);
+#endif
+                            }
+                        }
+                        // Accumulate the value of U at the current location.
+                        U_axis[s] = 0.0;
+
+                        for (BoxIterator<NDIM> b(stencil_box); b; b++)
+                        {
+                            const Index<NDIM>& ic = b();
+#if (NDIM == 2)
+
+                            U_axis[s] +=
+                                w[0][ic[0] - ic_lower[0]] * w[1][ic[1] - ic_lower[1]] * u_sc_data_array[ic[0]][ic[1]];
+                            const double nproj = n_qp[s * NDIM + 0] * wr[0][ic_upper[0] - ic[0]] +
+                                                 n_qp[s * NDIM + 1] * wr[1][ic_upper[1] - ic[1]];
+                            if (d_use_velocity_jump_conditions)
+                            {
+                                const double CC = (nproj > 0.0) ? Ujump[ic[0]][ic[1]][axis] : 0.0;
+                                U_axis[s] -= CC / mu;
+                            }
+#endif
+#if (NDIM == 3)
+
+                            U_axis[s] += w[0][ic[0] - ic_lower[0]] * w[1][ic[1] - ic_lower[1]] *
+                                         w[2][ic[2] - ic_lower[2]] * u_sc_data_array[ic[0]][ic[1]][ic[2]];
+                            const double nproj = n_qp[s * NDIM + 0] * wr[0][ic_upper[0] - ic[0]] +
+                                                 n_qp[s * NDIM + 1] * wr[1][ic_upper[1] - ic[1]] +
+                                                 n_qp[s * NDIM + 2] * wr[2][ic_upper[2] - ic[2]];
+                            if (d_use_velocity_jump_conditions)
+                            {
+                                const double CC = (nproj > 0.0) ? Ujump[ic[0]][ic[1]][ic[2]][axis] : 0.0;
+                                U_axis[s] -= CC / mu;
+                            }
+#endif
+                        }
+                    }
+                    if (d_use_velocity_jump_conditions)
+                    {
+						for (unsigned int k = 0; k < local_indices.size(); ++k)
+						{
+							U_qp[NDIM * local_indices[k] + axis] = U_axis[local_indices[k]];
+							if (dh != 0.0)
+							{
+								WSS_in_qp[NDIM * local_indices[k] + axis] =
+									 mu * (1.0 / dh) * ( U_in_qp[NDIM * local_indices[k] + axis] - U_qp[NDIM * local_indices[k] + axis]);
+									
+								WSS_out_qp[NDIM * local_indices[k] + axis] =
+									mu * (1.0 / dh) * (U_out_qp[NDIM * local_indices[k] + axis] - U_qp[NDIM * local_indices[k] + axis]);
+							}
+							else
+							{
+								TBOX_ERROR(d_object_name << ": The width for the wall shear stress hasn't been set up!"
+														 << std::endl);
+							}
+						}
+					}
+                }
+            }
             // Loop over the elements and accumulate the right-hand-side values.
             qrule.reset();
             qp_offset = 0;
             for (unsigned int e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
             {
                 Elem* const elem = patch_elems[e_idx];
-                const auto& U_dof_indices = U_dof_map_cache.dof_indices(elem);
-                const auto& X_dof_indices = X_dof_map_cache.dof_indices(elem);
                 for (unsigned int d = 0; d < NDIM; ++d)
                 {
+                    U_dof_map_cache.dof_indices(elem, U_dof_indices[d], d);
                     U_rhs_e[d].resize(static_cast<int>(U_dof_indices[d].size()));
                     U_n_rhs_e[d].resize(static_cast<int>(U_dof_indices[d].size()));
                     U_t_rhs_e[d].resize(static_cast<int>(U_dof_indices[d].size()));
+                    X_dof_map_cache.dof_indices(elem, X_dof_indices[d], d);
+                    if (d_use_velocity_jump_conditions)
+                    {
+                        WSS_out_dof_map_cache->dof_indices(elem, WSS_out_dof_indices[d], d);
+                        WSS_out_rhs_e[d].resize(static_cast<int>(WSS_out_dof_indices[d].size()));
+
+                        WSS_in_dof_map_cache->dof_indices(elem, WSS_in_dof_indices[d], d);
+                        WSS_in_rhs_e[d].resize(static_cast<int>(WSS_in_dof_indices[d].size()));
+                    }
                 }
-                get_values_for_interpolation(X_node, *X0_vec, X_dof_indices);
-                get_values_for_interpolation(x_node, *X_petsc_vec, X_local_soln, X_dof_indices);
+                get_values_for_interpolation(x_node, *X_ghost_vec, X_dof_indices);
                 const bool qrule_changed =
                     FEDataManager::updateInterpQuadratureRule(qrule, d_default_interp_spec, elem, x_node, patch_dx_min);
-                if (qrule_changed) fe->attach_quadrature_rule(qrule.get());
-                fe->reinit(elem);
-                const unsigned int n_qp = qrule->n_points();
+                if (qrule_changed) fe_X->attach_quadrature_rule(qrule.get());
+
+                fe_X->reinit(elem);
+                if (d_use_velocity_jump_conditions)
+                {
+                    if (qrule_changed)
+                    {
+                        fe_DU_jump->attach_quadrature_rule(qrule.get());
+                    }
+                    fe_DU_jump->reinit(elem);
+                }
+                const unsigned int n_qpoints = qrule->n_points();
                 const size_t n_basis = U_dof_indices[0].size();
-                for (unsigned int qp = 0; qp < n_qp; ++qp)
+                const size_t n_basis_jump = WSS_in_dof_indices[0].size();
+
+                for (unsigned int qp = 0; qp < n_qpoints; ++qp)
                 {
                     for (unsigned int k = 0; k < NDIM - 1; ++k)
                     {
-                        interpolate(dX_dxi[k], qp, X_node, *dphi_dxi[k]);
                         interpolate(dx_dxi[k], qp, x_node, *dphi_dxi[k]);
                     }
                     if (NDIM == 2)
                     {
-                        dX_dxi[1] = VectorValue<double>(0.0, 0.0, 1.0);
                         dx_dxi[1] = VectorValue<double>(0.0, 0.0, 1.0);
                     }
-                    N = (dX_dxi[0].cross(dX_dxi[1])).unit();
                     n = (dx_dxi[0].cross(dx_dxi[1])).unit();
-                    const int idx = NDIM * (qp_offset + qp);
                     for (unsigned int d = 0; d < NDIM; ++d)
                     {
-                        U(d) = U_qp[idx + d];
+                        U(d) = U_qp[NDIM * (qp_offset + qp) + d];
+                        if (d_use_velocity_jump_conditions)
+                        {
+                            WSS_in(d) = WSS_in_qp[NDIM * (qp_offset + qp) + d];
+                            WSS_out(d) = WSS_out_qp[NDIM * (qp_offset + qp) + d];
+                        }
                     }
-                    U_n = (U * N) * N;
+                    U_n = (U * n) * n;
                     U_t = U - U_n;
                     for (unsigned int k = 0; k < n_basis; ++k)
                     {
-                        const double p_JxW = phi[k][qp] * JxW[qp];
+                        const double p_JxW = phi_X[k][qp] * JxW[qp];
                         for (unsigned int d = 0; d < NDIM; ++d)
                         {
                             U_rhs_e[d](k) += U(d) * p_JxW;
@@ -719,27 +1367,52 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
                             U_t_rhs_e[d](k) += U_t(d) * p_JxW;
                         }
                     }
+                    if (d_use_velocity_jump_conditions)
+                    {
+                        for (unsigned int k = 0; k < n_basis_jump; ++k)
+                        {
+                            const double p_jump_JxW = phi_DU_jump[k][qp] * JxW_jump[qp];
+                            for (unsigned int d = 0; d < NDIM; ++d)
+                            {
+                                WSS_in_rhs_e[d](k) += WSS_in(d) * p_jump_JxW;
+                                WSS_out_rhs_e[d](k) += WSS_out(d) * p_jump_JxW;
+                            }
+                        }
+                    }
                 }
                 for (unsigned int d = 0; d < NDIM; ++d)
                 {
-                    dof_id_scratch = U_dof_indices[d];
-                    U_dof_map.constrain_element_vector(U_rhs_e[d], dof_id_scratch);
-                    U_dof_map.constrain_element_vector(U_n_rhs_e[d], dof_id_scratch);
-                    U_dof_map.constrain_element_vector(U_t_rhs_e[d], dof_id_scratch);
-                    U_rhs_vec->add_vector(U_rhs_e[d], dof_id_scratch);
-                    U_n_rhs_vec->add_vector(U_n_rhs_e[d], dof_id_scratch);
-                    U_t_rhs_vec->add_vector(U_t_rhs_e[d], dof_id_scratch);
+                    U_dof_map.constrain_element_vector(U_rhs_e[d], U_dof_indices[d]);
+                    U_dof_map.constrain_element_vector(U_n_rhs_e[d], U_dof_indices[d]);
+                    U_dof_map.constrain_element_vector(U_t_rhs_e[d], U_dof_indices[d]);
+                    U_rhs_vec->add_vector(U_rhs_e[d], U_dof_indices[d]);
+                    U_n_rhs_vec->add_vector(U_n_rhs_e[d], U_dof_indices[d]);
+                    U_t_rhs_vec->add_vector(U_t_rhs_e[d], U_dof_indices[d]);
+                    if (d_use_velocity_jump_conditions)
+                    {
+                        WSS_out_dof_map->constrain_element_vector(WSS_out_rhs_e[d], WSS_out_dof_indices[d]);
+                        WSS_out_rhs_vec->add_vector(WSS_out_rhs_e[d], WSS_out_dof_indices[d]);
+                        WSS_in_dof_map->constrain_element_vector(WSS_in_rhs_e[d], WSS_in_dof_indices[d]);
+                        WSS_in_rhs_vec->add_vector(WSS_in_rhs_e[d], WSS_in_dof_indices[d]);
+                    }
                 }
-                qp_offset += n_qp;
+                qp_offset += n_qpoints;
             }
         }
         U_rhs_vec->close();
         U_n_rhs_vec->close();
         U_t_rhs_vec->close();
 
-        VecRestoreArray(X_local_vec, &X_local_soln);
-        VecGhostRestoreLocalForm(X_global_vec, &X_local_vec);
-
+        if (d_use_velocity_jump_conditions)
+        {
+            WSS_in_rhs_vec->close();
+            d_fe_data_managers[part]->computeL2Projection(
+                *WSS_in_vec, *WSS_in_rhs_vec, WSS_IN_SYSTEM_NAME, d_default_interp_spec.use_consistent_mass_matrix);
+                
+            WSS_out_rhs_vec->close();
+            d_fe_data_managers[part]->computeL2Projection(
+                *WSS_out_vec, *WSS_out_rhs_vec, WSS_OUT_SYSTEM_NAME, d_default_interp_spec.use_consistent_mass_matrix);
+        }
         // Solve for the nodal values.
         d_fe_data_managers[part]->computeL2Projection(
             *U_vec, *U_rhs_vec, VELOCITY_SYSTEM_NAME, d_default_interp_spec.use_consistent_mass_matrix);
@@ -747,6 +1420,12 @@ IBFESurfaceMethod::interpolateVelocity(const int u_data_idx,
             *U_n_vec, *U_n_rhs_vec, VELOCITY_SYSTEM_NAME, d_default_interp_spec.use_consistent_mass_matrix);
         d_fe_data_managers[part]->computeL2Projection(
             *U_t_vec, *U_t_rhs_vec, VELOCITY_SYSTEM_NAME, d_default_interp_spec.use_consistent_mass_matrix);
+
+		if (d_use_velocity_jump_conditions)
+		{
+			for (unsigned int d = 0; d < NDIM; ++d) d_DU_jump_IB_ghost_vecs[part][d]->close();
+		}
+                d_X_IB_ghost_vecs[part]->close();
     }
     return;
 } // interpolateVelocity
@@ -837,6 +1516,7 @@ void
 IBFESurfaceMethod::computeLagrangianForce(const double data_time)
 {
     TBOX_ASSERT(MathUtilities<double>::equalEps(data_time, d_half_time));
+    batch_vec_ghost_update(d_X_half_vecs, INSERT_VALUES, SCATTER_FORWARD);
     for (unsigned part = 0; part < d_num_parts; ++part)
     {
         EquationSystems* equation_systems = d_fe_data_managers[part]->getEquationSystems();
@@ -846,16 +1526,33 @@ IBFESurfaceMethod::computeLagrangianForce(const double data_time)
         // Setup global and elemental right-hand-side vectors.
         NumericVector<double>* F_vec = d_F_half_vecs[part];
         std::unique_ptr<NumericVector<double> > F_rhs_vec = F_vec->zero_clone();
-        DenseVector<double> F_rhs_e[NDIM];
-        NumericVector<double>* DP_vec = d_DP_half_vecs[part];
-        std::unique_ptr<NumericVector<double> > DP_rhs_vec =
-            (d_use_jump_conditions ? DP_vec->zero_clone() : std::unique_ptr<NumericVector<double> >());
-        DenseVector<double> DP_rhs_e;
+        std::array<DenseVector<double>, NDIM> F_rhs_e;
         VectorValue<double>& F_integral = d_lag_surface_force_integral[part];
         F_integral.zero();
-        double DP_rhs_integral = 0.0;
-        double surface_area = 0.0;
+
         NumericVector<double>* X_vec = d_X_half_vecs[part];
+        double surface_area = 0.0;
+
+        NumericVector<double>* P_jump_vec = d_P_jump_half_vecs[part];
+        std::unique_ptr<NumericVector<double> > P_jump_rhs_vec;
+        DenseVector<double> P_jump_rhs_e;
+        if (d_use_pressure_jump_conditions)
+        {
+            P_jump_rhs_vec = P_jump_vec->zero_clone();
+        }
+        double P_jump_rhs_integral = 0.0;
+
+        std::array<NumericVector<double>*, NDIM> DU_jump_vec;
+        std::array<std::unique_ptr<NumericVector<double> >, NDIM> DU_jump_rhs_vec;
+        std::array<std::array<DenseVector<double>, NDIM>, NDIM> DU_jump_rhs_e;
+        if (d_use_velocity_jump_conditions)
+        {
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                DU_jump_vec[d] = d_DU_jump_half_vecs[part][d];
+                DU_jump_rhs_vec[d] = DU_jump_vec[d]->zero_clone();
+            }
+        }
 
         // Extract the FE systems and DOF maps, and setup the FE objects.
         System& F_system = equation_systems->get_system(FORCE_SYSTEM_NAME);
@@ -876,38 +1573,78 @@ IBFESurfaceMethod::computeLagrangianForce(const double data_time)
         for (unsigned int d = 0; d < NDIM; ++d)
         {
             TBOX_ASSERT(X_dof_map.variable_type(d) == X_fe_type);
-            TBOX_ASSERT(X_dof_map.variable_type(d) == F_fe_type);
         }
+        TBOX_ASSERT(X_fe_type == F_fe_type);
         NumericVector<double>& X0_vec = X_system.get_vector("INITIAL_COORDINATES");
+        System* P_jump_system;
+        const DofMap* P_jump_dof_map = NULL;
+        FEDataManager::SystemDofMapCache* P_jump_dof_map_cache = NULL;
+        FEType P_jump_fe_type = INVALID_FE;
+        if (d_use_pressure_jump_conditions)
+        {
+            P_jump_system = &equation_systems->get_system(PRESSURE_JUMP_SYSTEM_NAME);
+            P_jump_dof_map = &P_jump_system->get_dof_map();
+            P_jump_dof_map_cache = d_fe_data_managers[part]->getDofMapCache(PRESSURE_JUMP_SYSTEM_NAME);
+            P_jump_fe_type = P_jump_dof_map->variable_type(0);
+        }
+
+        std::array<System*, NDIM> DU_jump_system;
+        std::array<DofMap*, NDIM> DU_jump_dof_map;
+        std::array<FEDataManager::SystemDofMapCache*, NDIM> DU_jump_dof_map_cache;
+        FEType DU_jump_fe_type = INVALID_FE;
+        if (d_use_velocity_jump_conditions)
+        {
+            for (unsigned int i = 0; i < NDIM; ++i)
+            {
+                DU_jump_system[i] = &equation_systems->get_system(VELOCITY_JUMP_SYSTEM_NAME[i]);
+                DU_jump_dof_map[i] = &DU_jump_system[i]->get_dof_map();
+                DU_jump_dof_map_cache[i] = d_fe_data_managers[part]->getDofMapCache(VELOCITY_JUMP_SYSTEM_NAME[i]);
+            }
+            DU_jump_fe_type = DU_jump_dof_map[0]->variable_type(0);
+            for (unsigned int i = 0; i < NDIM; ++i)
+            {
+                for (unsigned int j = 0; j < NDIM; ++j)
+                {
+                    TBOX_ASSERT(DU_jump_dof_map[i]->variable_type(j) == DU_jump_fe_type);
+                }
+            }
+        }
 
-        // silence some warnings by giving DP_dof_map_cache a bogus, but
-        // valid, value if we don't use jump conditions
-        FEDataManager::SystemDofMapCache* DP_dof_map_cache =
-            d_use_jump_conditions ? d_fe_data_managers[part]->getDofMapCache(PRESSURE_JUMP_SYSTEM_NAME) : nullptr;
-        const System* DP_system =
-            d_use_jump_conditions ? &equation_systems->get_system(PRESSURE_JUMP_SYSTEM_NAME) : nullptr;
-        const DofMap* DP_dof_map = d_use_jump_conditions ? &DP_system->get_dof_map() : nullptr;
-        if (d_use_jump_conditions)
+        // The P_jump_fe_type and DU_jump_fe_type are equal only if we are applying both jumps
+        // or none of the jumps.
+        if (d_use_pressure_jump_conditions && d_use_velocity_jump_conditions)
         {
-            FEType DP_fe_type = DP_dof_map->variable_type(0);
-            TBOX_ASSERT(DP_fe_type == X_fe_type);
-            TBOX_ASSERT(DP_fe_type == F_fe_type);
+            TBOX_ASSERT(P_jump_fe_type == DU_jump_fe_type);
         }
 
-        FEType fe_type = F_fe_type;
 
         std::unique_ptr<QBase> qrule = QBase::build(d_default_quad_type[part], dim, d_default_quad_order[part]);
 
-        std::unique_ptr<FEBase> fe = FEBase::build(dim, fe_type);
-        fe->attach_quadrature_rule(qrule.get());
-        const std::vector<double>& JxW = fe->get_JxW();
-        const std::vector<std::vector<double> >& phi = fe->get_phi();
-        std::array<const std::vector<std::vector<double> >*, NDIM - 1> dphi_dxi;
-        dphi_dxi[0] = &fe->get_dphidxi();
-        if (NDIM > 2) dphi_dxi[1] = &fe->get_dphideta();
+        std::unique_ptr<FEBase> fe_X = FEBase::build(dim, X_fe_type);
+        fe_X->attach_quadrature_rule(qrule.get());
+        const std::vector<double>& JxW = fe_X->get_JxW();
+        const std::vector<std::vector<double> >& phi_X = fe_X->get_phi();
+        std::array<const std::vector<std::vector<double> >*, NDIM - 1> dphi_dxi_X;
+        dphi_dxi_X[0] = &fe_X->get_dphidxi();
+        if (NDIM > 2) dphi_dxi_X[1] = &fe_X->get_dphideta();
+
+        FEType fe_jump_type = INVALID_FE;
+        if (d_use_pressure_jump_conditions)
+        {
+			fe_jump_type = P_jump_fe_type;
+		}
+		else
+		{
+			fe_jump_type = DU_jump_fe_type;
+		}
+
+        std::unique_ptr<FEBase> fe_jump = FEBase::build(dim, fe_jump_type);
+        fe_jump->attach_quadrature_rule(qrule.get());
+        const std::vector<std::vector<double> >& phi_jump = fe_jump->get_phi();
 
         FEDataInterpolation fe_interpolator(dim, d_fe_data_managers[part]);
         fe_interpolator.attachQuadratureRule(qrule.get());
+
         std::vector<size_t> surface_force_fcn_system_idxs;
         fe_interpolator.setupInterpolatedSystemDataIndexes(
             surface_force_fcn_system_idxs, d_lag_surface_force_fcn_data[part].system_data, equation_systems);
@@ -922,6 +1659,7 @@ IBFESurfaceMethod::computeLagrangianForce(const double data_time)
 
         // Loop over the elements to compute the right-hand side vector.
         boost::multi_array<double, 2> X_node, x_node;
+        double DU[NDIM][NDIM];
         TensorValue<double> FF;
         VectorValue<double> F, F_b, F_s, F_qp, N, X, n, x;
         std::array<VectorValue<double>, 2> dX_dxi, dx_dxi;
@@ -933,30 +1671,55 @@ IBFESurfaceMethod::computeLagrangianForce(const double data_time)
             Elem* const elem = *el_it;
             const auto& F_dof_indices = F_dof_map_cache.dof_indices(elem);
             const auto& X_dof_indices = X_dof_map_cache.dof_indices(elem);
+
             for (unsigned int d = 0; d < NDIM; ++d)
             {
                 F_rhs_e[d].resize(static_cast<int>(F_dof_indices[d].size()));
             }
-            if (d_use_jump_conditions)
+            if (d_use_pressure_jump_conditions)
             {
-                DP_rhs_e.resize(static_cast<int>(F_dof_indices[0].size()));
+                const auto& P_jump_dof_indices = P_jump_dof_map_cache->dof_indices(elem);
+                P_jump_rhs_e.resize(static_cast<int>(P_jump_dof_indices[0].size()));
+            }
+
+            if (d_use_velocity_jump_conditions)
+            {
+                for (unsigned int d = 0; d < NDIM; ++d)
+                {
+                    const auto& DU_jump_dof_indices = DU_jump_dof_map_cache[d]->dof_indices(elem);
+                    for (unsigned int k = 0; k < NDIM; ++k)
+                    {
+                        DU_jump_rhs_e[d][k].resize(static_cast<int>(DU_jump_dof_indices[k].size()));
+                    }
+                }
             }
-            fe->reinit(elem);
+
+            fe_X->reinit(elem);
+
             fe_interpolator.reinit(elem);
             fe_interpolator.collectDataForInterpolation(elem);
             fe_interpolator.interpolate(elem);
+
+
+            if (d_use_pressure_jump_conditions || d_use_velocity_jump_conditions)
+            {
+                fe_jump->reinit(elem);
+            }
+
+
             get_values_for_interpolation(x_node, *X_vec, X_dof_indices);
             get_values_for_interpolation(X_node, X0_vec, X_dof_indices);
-            const unsigned int n_qp = qrule->n_points();
-            const size_t n_basis = phi.size();
-            for (unsigned int qp = 0; qp < n_qp; ++qp)
+            const unsigned int n_qpoints = qrule->n_points();
+            const size_t n_basis = phi_X.size();
+            const size_t n_basis2 = phi_jump.size();
+            for (unsigned int qp = 0; qp < n_qpoints; ++qp)
             {
-                interpolate(X, qp, X_node, phi);
-                interpolate(x, qp, x_node, phi);
+                interpolate(X, qp, X_node, phi_X);
+                interpolate(x, qp, x_node, phi_X);
                 for (unsigned int k = 0; k < NDIM - 1; ++k)
                 {
-                    interpolate(dX_dxi[k], qp, X_node, *dphi_dxi[k]);
-                    interpolate(dx_dxi[k], qp, x_node, *dphi_dxi[k]);
+                    interpolate(dX_dxi[k], qp, X_node, *dphi_dxi_X[k]);
+                    interpolate(dx_dxi[k], qp, x_node, *dphi_dxi_X[k]);
                 }
                 if (NDIM == 2)
                 {
@@ -1023,27 +1786,57 @@ IBFESurfaceMethod::computeLagrangianForce(const double data_time)
                     F += F_s;
                 }
 
+                const double P_j = F * n * dA / da;
+                for (unsigned int i = 0; i < NDIM; ++i)
+                    for (unsigned int k = 0; k < NDIM; ++k)
+                        DU[i][k] = -(dA / da) * (F(i) - F * n * n(i)) * n(k); // [Ux] , [Uy], [Uz]
+
                 for (unsigned int d = 0; d < NDIM; ++d) F_integral(d) += F(d) * JxW[qp];
 
-                const double C_p = F * n * dA / da;
-                if (d_use_jump_conditions)
+                // Remote the part of the force that has been already included in the jump
+
+                if (d_use_pressure_jump_conditions && !d_use_velocity_jump_conditions)
                 {
                     F -= (F * n) * n;
                 }
+                if (!d_use_pressure_jump_conditions && d_use_velocity_jump_conditions)
+                {
+                    F = (F * n) * n;
+                }
+                if (d_use_pressure_jump_conditions && d_use_velocity_jump_conditions)
+                {
+                    F = 0.0;
+                }
 
                 // Add the boundary forces to the right-hand-side vector.
                 for (unsigned int k = 0; k < n_basis; ++k)
                 {
-                    F_qp = F * phi[k][qp] * JxW[qp];
+                    F_qp = F * phi_X[k][qp] * JxW[qp];
                     for (unsigned int i = 0; i < NDIM; ++i)
                     {
                         F_rhs_e[i](k) += F_qp(i);
                     }
-                    if (d_use_jump_conditions) DP_rhs_e(k) += C_p * phi[k][qp] * JxW[qp];
                 }
-                if (d_use_jump_conditions)
+                for (unsigned int k = 0; k < n_basis2; ++k)
+                {
+                    if (d_use_pressure_jump_conditions)
+                    {
+                        P_jump_rhs_e(k) += P_j * phi_jump[k][qp] * JxW[qp];
+                    }
+                    if (d_use_velocity_jump_conditions)
+                    {
+                        for (unsigned int i = 0; i < NDIM; ++i)
+                        {
+                            for (unsigned int j = 0; j < NDIM; ++j)
+                            {
+                                DU_jump_rhs_e[i][j](k) += DU[i][j] * phi_jump[k][qp] * JxW[qp];
+                            }
+                        }
+                    }
+                }
+                if (d_use_pressure_jump_conditions)
                 {
-                    DP_rhs_integral += C_p * JxW[qp];
+                    P_jump_rhs_integral += P_j * JxW[qp];
                     surface_area += JxW[qp];
                 }
             }
@@ -1055,28 +1848,48 @@ IBFESurfaceMethod::computeLagrangianForce(const double data_time)
                 dof_id_scratch = F_dof_indices[i];
                 F_dof_map.constrain_element_vector(F_rhs_e[i], dof_id_scratch);
                 F_rhs_vec->add_vector(F_rhs_e[i], dof_id_scratch);
+                if (d_use_velocity_jump_conditions)
+                {
+                    const auto& DU_jump_dof_indices = DU_jump_dof_map_cache[i]->dof_indices(elem);
+                    for (unsigned int k = 0; k < NDIM; ++k)
+                    {
+                        dof_id_scratch = DU_jump_dof_indices[k];
+                        DU_jump_dof_map[i]->constrain_element_vector(DU_jump_rhs_e[i][k], dof_id_scratch);
+                        DU_jump_rhs_vec[i]->add_vector(DU_jump_rhs_e[i][k], dof_id_scratch);
+                    }
+                }
             }
-            if (d_use_jump_conditions)
+            if (d_use_pressure_jump_conditions)
             {
-                dof_id_scratch = DP_dof_map_cache->dof_indices(elem)[0];
-                DP_dof_map->constrain_element_vector(DP_rhs_e, dof_id_scratch);
-                DP_rhs_vec->add_vector(DP_rhs_e, dof_id_scratch);
+                const auto& P_jump_dof_indices = P_jump_dof_map_cache->dof_indices(elem);
+                dof_id_scratch = P_jump_dof_indices[0];
+                P_jump_dof_map->constrain_element_vector(P_jump_rhs_e, dof_id_scratch);
+                P_jump_rhs_vec->add_vector(P_jump_rhs_e, dof_id_scratch);
             }
         }
 
-        SAMRAI_MPI::sumReduction(&F_integral(0), LIBMESH_DIM);
+        SAMRAI_MPI::sumReduction(&F_integral(0), NDIM);
 
         // Solve for F.
         d_fe_data_managers[part]->computeL2Projection(
             *F_vec, *F_rhs_vec, FORCE_SYSTEM_NAME, d_use_consistent_mass_matrix);
-        if (d_use_jump_conditions)
+        if (d_use_pressure_jump_conditions)
         {
             d_fe_data_managers[part]->computeL2Projection(
-                *DP_vec, *DP_rhs_vec, PRESSURE_JUMP_SYSTEM_NAME, d_use_consistent_mass_matrix);
-            DP_rhs_integral = SAMRAI_MPI::sumReduction(DP_rhs_integral);
+                *P_jump_vec, *P_jump_rhs_vec, PRESSURE_JUMP_SYSTEM_NAME, d_use_consistent_mass_matrix);
+            P_jump_rhs_integral = SAMRAI_MPI::sumReduction(P_jump_rhs_integral);
             surface_area = SAMRAI_MPI::sumReduction(surface_area);
-            if (d_normalize_pressure_jump) DP_vec->add(-DP_rhs_integral / surface_area);
-            DP_vec->close();
+            if (d_normalize_pressure_jump) P_jump_vec->add(-P_jump_rhs_integral / surface_area);
+            P_jump_vec->close();
+        }
+        if (d_use_velocity_jump_conditions)
+        {
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                d_fe_data_managers[part]->computeL2Projection(
+                    *DU_jump_vec[d], *DU_jump_rhs_vec[d], VELOCITY_JUMP_SYSTEM_NAME[d], d_use_consistent_mass_matrix);
+                DU_jump_vec[d]->close();
+            }
         }
     }
     return;
@@ -1099,13 +1912,40 @@ IBFESurfaceMethod::spreadForce(const int f_data_idx,
         F_vec->localize(*F_ghost_vec);
         d_fe_data_managers[part]->spread(
             f_data_idx, *F_ghost_vec, *X_ghost_vec, FORCE_SYSTEM_NAME, f_phys_bdry_op, data_time);
-        if (d_use_jump_conditions)
+        PetscVector<double>* P_jump_vec;
+        PetscVector<double>* P_jump_ghost_vec = NULL;
+        std::array<PetscVector<double>*, NDIM> DU_jump_ghost_vec;
+        std::array<PetscVector<double>*, NDIM> DU_jump_vec;
+        if (d_use_pressure_jump_conditions)
+        {
+            P_jump_vec = d_P_jump_half_vecs[part];
+            P_jump_ghost_vec = d_P_jump_IB_ghost_vecs[part];
+            P_jump_vec->localize(*P_jump_ghost_vec);
+        }
+        if (d_use_velocity_jump_conditions)
         {
-            PetscVector<double>* DP_vec = d_DP_half_vecs[part];
-            PetscVector<double>* DP_ghost_vec = d_DP_IB_ghost_vecs[part];
-            DP_vec->localize(*DP_ghost_vec);
-            imposeJumpConditions(f_data_idx, *DP_ghost_vec, *X_ghost_vec, data_time, part);
+            DU_jump_ghost_vec = d_DU_jump_IB_ghost_vecs[part];
+            DU_jump_vec = d_DU_jump_half_vecs[part];
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                DU_jump_vec[d]->localize(*DU_jump_ghost_vec[d]);
+            }
         }
+
+        if (d_use_pressure_jump_conditions || d_use_velocity_jump_conditions)
+        {
+			imposeJumpConditions(f_data_idx, *P_jump_ghost_vec, DU_jump_ghost_vec, *X_ghost_vec, data_time, part);
+
+	    }
+	    if (d_use_velocity_jump_conditions)
+		{
+			for (unsigned int d = 0; d < NDIM; ++d) d_DU_jump_IB_ghost_vecs[part][d]->close();
+		}
+		if(d_use_pressure_jump_conditions)
+		{
+			d_P_jump_IB_ghost_vecs[part]->close();
+		}
+	   
     }
     return;
 } // spreadForce
@@ -1186,6 +2026,7 @@ IBFESurfaceMethod::initializeFEEquationSystems()
             {
                 X_system.add_variable("X_" + std::to_string(d), d_fe_order[part], d_fe_family[part]);
             }
+            X_system.add_vector("INITIAL_COORDINATES", /*projections*/ true, GHOSTED);
 
             auto& dX_system = equation_systems->add_system<System>(COORD_MAPPING_SYSTEM_NAME);
             for (unsigned int d = 0; d < NDIM; ++d)
@@ -1217,54 +2058,153 @@ IBFESurfaceMethod::initializeFEEquationSystems()
                 F_system.add_variable("F_" + std::to_string(d), d_fe_order[part], d_fe_family[part]);
             }
 
-            if (d_use_jump_conditions)
+            if (d_use_pressure_jump_conditions)
             {
-                auto& DP_system = equation_systems->add_system<System>(PRESSURE_JUMP_SYSTEM_NAME);
-                DP_system.add_variable("C_p", d_fe_order[part], d_fe_family[part]);
+                System& P_jump_system = equation_systems->add_system<System>(PRESSURE_JUMP_SYSTEM_NAME);
+                System& P_in_system = equation_systems->add_system<System>(PRESSURE_IN_SYSTEM_NAME);
+                System& P_out_system = equation_systems->add_system<System>(PRESSURE_OUT_SYSTEM_NAME);
+                if (d_use_l2_lagrange_family)
+                {
+                    P_jump_system.add_variable("P_jump_", d_fe_order[part], L2_LAGRANGE);
+                    P_in_system.add_variable("P_in_", d_fe_order[part], L2_LAGRANGE);
+                    P_out_system.add_variable("P_out_", d_fe_order[part], L2_LAGRANGE);
+                }
+                else
+                {
+                    P_jump_system.add_variable("P_jump_", d_fe_order[part], d_fe_family[part]);
+                    P_in_system.add_variable("P_in_", d_fe_order[part], d_fe_family[part]);
+                    P_out_system.add_variable("P_out_", d_fe_order[part], d_fe_family[part]);
+                }
             }
-        }
-
-        // This is the same code (with a different system and vector name) as IBFEMethod.
-        //
-        // Setup cached system vectors.
-        //
-        // NOTE: libMesh does not appear to preserve the type of the vector
-        // after restart (GHOSTED vectors are now PARALLEL), and so we
-        // manually reset these vectors here.
-        auto insert_parallel_into_ghosted = [](const PetscVector<Number>& parallel_vector,
-                                               PetscVector<Number>& ghosted_vector) {
-            TBOX_ASSERT(parallel_vector.size() == ghosted_vector.size());
-            TBOX_ASSERT(parallel_vector.local_size() == ghosted_vector.local_size());
-            ghosted_vector = parallel_vector;
-            ghosted_vector.close();
-        };
 
-        const std::array<std::string, 1> system_names{ { COORDS_SYSTEM_NAME } };
-        const std::array<std::string, 1> vector_names{ { "INITIAL_COORDINATES" } };
-        for (const std::string& system_name : system_names)
-        {
-            auto& system = equation_systems->get_system(system_name);
-            for (const std::string& vector_name : vector_names)
+            if (d_use_velocity_jump_conditions)
             {
-                std::unique_ptr<NumericVector<double> > clone_vector;
-                if (from_restart)
+                std::array<System*, NDIM> DU_jump_system;
+                for (unsigned int d = 0; d < NDIM; ++d)
+                {
+                    DU_jump_system[d] = &equation_systems->add_system<System>(VELOCITY_JUMP_SYSTEM_NAME[d]);
+                    for (unsigned int i = 0; i < NDIM; ++i)
+                    {
+                        const std::string system_name = "DU_jump_" + std::to_string(d) + "_" + std::to_string(i);
+                        // TODO: The value of the FEFamily should just be read in from the input file directly instead
+                        // of using a boolean.
+                        if (d_use_l2_lagrange_family)
+                        {
+                            DU_jump_system[d]->add_variable(system_name, d_fe_order[part], L2_LAGRANGE);
+                        }
+                        else
+                        {
+                            DU_jump_system[d]->add_variable(system_name, d_fe_order[part], d_fe_family[part]);
+                        }
+                    }
+                }
+
+                System& WSS_in_system = equation_systems->add_system<System>(WSS_IN_SYSTEM_NAME);
+                for (unsigned int d = 0; d < NDIM; ++d)
+                {
+                    const std::string system_name = "WSS_in_" + std::to_string(d);
+                    // TODO: The value of the FEFamily should just be read in from the input file directly instead of
+                    // using a boolean.
+                    if (d_use_l2_lagrange_family)
+                    {
+                        WSS_in_system.add_variable(system_name, d_fe_order[part], L2_LAGRANGE);
+                    }
+                    else
+                    {
+                        WSS_in_system.add_variable(system_name, d_fe_order[part], d_fe_family[part]);
+                    }
+                }
+                
+                System& WSS_out_system = equation_systems->add_system<System>(WSS_OUT_SYSTEM_NAME);
+                for (unsigned int d = 0; d < NDIM; ++d)
                 {
-                    NumericVector<double>* current = system.request_vector(vector_name);
-                    if (current != nullptr)
+                    const std::string system_name = "WSS_out_" + std::to_string(d);
+                    // TODO: The value of the FEFamily should just be read in from the input file directly instead of
+                    // using a boolean.
+                    if (d_use_l2_lagrange_family)
+                    {
+                        WSS_out_system.add_variable(system_name, d_fe_order[part], L2_LAGRANGE);
+                    }
+                    else
                     {
-                        clone_vector = current->clone();
+                        WSS_out_system.add_variable(system_name, d_fe_order[part], d_fe_family[part]);
                     }
                 }
-                system.remove_vector(vector_name);
-                system.add_vector(vector_name, /*projections*/ true, /*type*/ GHOSTED);
+            }
 
-                if (clone_vector != nullptr)
+            if (d_use_pressure_jump_conditions && d_use_velocity_jump_conditions)
+            {
+                auto& TAU_in_system = equation_systems->add_system<System>(TAU_IN_SYSTEM_NAME);
+                for (unsigned int d = 0; d < NDIM; ++d)
                 {
-                    const auto& parallel_vector = dynamic_cast<const PetscVector<Number>&>(*clone_vector);
-                    auto& ghosted_vector = dynamic_cast<PetscVector<Number>&>(system.get_vector(vector_name));
-                    insert_parallel_into_ghosted(parallel_vector, ghosted_vector);
+                    std::string system_name = "TAU_IN_" + std::to_string(d);
+                    // TODO: The value of the FEFamily should just be read in from the input file directly instead of
+                    // using a boolean.
+                    if (d_use_l2_lagrange_family)
+                    {
+                        TAU_in_system.add_variable(system_name, d_fe_order[part], L2_LAGRANGE);
+                    }
+                    else
+                    {
+                        TAU_in_system.add_variable(system_name, d_fe_order[part], d_fe_family[part]);
+                    }
+                }
+                
+                auto& TAU_out_system = equation_systems->add_system<System>(TAU_OUT_SYSTEM_NAME);
+                for (unsigned int d = 0; d < NDIM; ++d)
+                {
+                    std::string system_name = "TAU_OUT_" + std::to_string(d);
+                    // TODO: The value of the FEFamily should just be read in from the input file directly instead of
+                    // using a boolean.
+                    if (d_use_l2_lagrange_family)
+                    {
+                        TAU_out_system.add_variable(system_name, d_fe_order[part], L2_LAGRANGE);
+                    }
+                    else
+                    {
+                        TAU_out_system.add_variable(system_name, d_fe_order[part], d_fe_family[part]);
+                    }
                 }
+                
             }
+        
+            auto insert_parallel_into_ghosted = [](const PetscVector<Number>& parallel_vector,
+                                               PetscVector<Number>& ghosted_vector) {
+				TBOX_ASSERT(parallel_vector.size() == ghosted_vector.size());
+				TBOX_ASSERT(parallel_vector.local_size() == ghosted_vector.local_size());
+				ghosted_vector = parallel_vector;
+				ghosted_vector.close();
+			};
+
+			const std::array<std::string, 1> system_names{ { COORDS_SYSTEM_NAME } };
+			const std::array<std::string, 1> vector_names{ { "INITIAL_COORDINATES" } };
+			for (const std::string& system_name : system_names)
+			{
+				auto& system = equation_systems->get_system(system_name);
+				for (const std::string& vector_name : vector_names)
+				{
+					std::unique_ptr<NumericVector<double> > clone_vector;
+					if (from_restart)
+					{
+						NumericVector<double>* current = system.request_vector(vector_name);
+						if (current != nullptr)
+						{
+							clone_vector = current->clone();
+						}
+					}
+					system.remove_vector(vector_name);
+					system.add_vector(vector_name, /*projections*/ true, /*type*/ GHOSTED);
+
+					if (clone_vector != nullptr)
+					{
+						const auto& parallel_vector = dynamic_cast<const PetscVector<Number>&>(*clone_vector);
+						auto& ghosted_vector = dynamic_cast<PetscVector<Number>&>(system.get_vector(vector_name));
+						insert_parallel_into_ghosted(parallel_vector, ghosted_vector);
+					}
+				}
+			}
+        
+        
         }
     }
     d_fe_equation_systems_initialized = true;
@@ -1319,11 +2259,46 @@ IBFESurfaceMethod::initializeFEData()
         F_system.assemble_before_solve = false;
         F_system.assemble();
 
-        if (d_use_jump_conditions)
+        if (d_use_pressure_jump_conditions)
+        {
+            System& P_jump_system = equation_systems->get_system<System>(PRESSURE_JUMP_SYSTEM_NAME);
+            P_jump_system.assemble_before_solve = false;
+            P_jump_system.assemble();
+
+            System& P_in_system = equation_systems->get_system<System>(PRESSURE_IN_SYSTEM_NAME);
+            P_in_system.assemble_before_solve = false;
+            P_in_system.assemble();
+
+            System& P_out_system = equation_systems->get_system<System>(PRESSURE_OUT_SYSTEM_NAME);
+            P_out_system.assemble_before_solve = false;
+            P_out_system.assemble();
+        }
+        if (d_use_velocity_jump_conditions)
         {
-            auto& DP_system = equation_systems->get_system<System>(PRESSURE_JUMP_SYSTEM_NAME);
-            DP_system.assemble_before_solve = false;
-            DP_system.assemble();
+            std::array<System*, NDIM> DU_jump_system;
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                DU_jump_system[d] = &equation_systems->get_system<System>(VELOCITY_JUMP_SYSTEM_NAME[d]);
+                DU_jump_system[d]->assemble_before_solve = false;
+                DU_jump_system[d]->assemble();
+            }
+            System& WSS_in_system = equation_systems->get_system<System>(WSS_IN_SYSTEM_NAME);
+            WSS_in_system.assemble_before_solve = false;
+            WSS_in_system.assemble();
+            
+            System& WSS_out_system = equation_systems->get_system<System>(WSS_OUT_SYSTEM_NAME);
+            WSS_out_system.assemble_before_solve = false;
+            WSS_out_system.assemble();
+        }
+        if (d_use_pressure_jump_conditions && d_use_velocity_jump_conditions)
+        {
+            System& TAU_in_system = equation_systems->get_system<System>(TAU_IN_SYSTEM_NAME);
+            TAU_in_system.assemble_before_solve = false;
+            TAU_in_system.assemble();
+            
+            System& TAU_out_system = equation_systems->get_system<System>(TAU_OUT_SYSTEM_NAME);
+            TAU_out_system.assemble_before_solve = false;
+            TAU_out_system.assemble();
         }
     }
     d_fe_data_initialized = true;
@@ -1333,7 +2308,14 @@ IBFESurfaceMethod::initializeFEData()
 void
 IBFESurfaceMethod::registerEulerianVariables()
 {
-    // intentionally blank
+    p_var = new CellVariable<NDIM, double>(d_object_name + "::p");
+    registerVariable(p_current_idx,
+					 p_new_idx,
+					 p_scratch_idx,
+                     p_var,
+                     d_ghosts,
+                     "CONSERVATIVE_COARSEN",
+                     "CONSERVATIVE_LINEAR_REFINE");
     return;
 } // registerEulerianVariables
 
@@ -1464,7 +2446,12 @@ IBFESurfaceMethod::putToDatabase(Pointer<Database> db)
     db->putInteger("IBFE_METHOD_VERSION", IBFE_METHOD_VERSION);
     db->putInteger("d_num_parts", d_num_parts);
     db->putIntegerArray("d_ghosts", d_ghosts, NDIM);
-    db->putBool("d_use_jump_conditions", d_use_jump_conditions);
+    db->putBool("d_use_velocity_jump_conditions", d_use_velocity_jump_conditions);
+    db->putBool("d_use_l2_lagrange_family", d_use_l2_lagrange_family);
+    db->putBool("d_use_pressure_jump_conditions", d_use_pressure_jump_conditions);
+    db->putBool("d_compute_fluid_traction", d_compute_fluid_traction);
+    db->putBool("d_traction_interior_side", d_traction_interior_side);
+    db->putDouble("d_traction_activation_time", d_traction_activation_time);
     db->putBool("d_use_consistent_mass_matrix", d_use_consistent_mass_matrix);
     db->putBool("d_use_direct_forcing", d_use_direct_forcing);
     return;
@@ -1505,137 +2492,1009 @@ struct IndexOrder
 } // namespace
 
 void
-IBFESurfaceMethod::imposeJumpConditions(const int f_data_idx,
-                                        PetscVector<double>& DP_ghost_vec,
-                                        PetscVector<double>& X_ghost_vec,
-                                        const double /*data_time*/,
-                                        const unsigned int part)
+IBFESurfaceMethod::extrapolatePressureForTraction(const int p_data_idx, const double data_time, unsigned int part)
 {
-    // Extract the mesh.
+	batch_vec_ghost_update({ d_P_out_half_vecs[part], d_P_in_half_vecs[part], d_X_new_vecs[part] },
+                           INSERT_VALUES,
+                           SCATTER_FORWARD);
+
+    Pointer<PatchHierarchy<NDIM> > patch_hierarchy = d_fe_data_managers[part]->getPatchHierarchy();
+
+    NumericVector<double>* P_in_vec = d_P_in_half_vecs[part];
+    NumericVector<double>* P_out_vec = d_P_out_half_vecs[part];
+    NumericVector<double>* P_jump_ghost_vec = d_P_jump_IB_ghost_vecs[part];
+    NumericVector<double>* X_vec = NULL;
+    NumericVector<double>* X_ghost_vec = d_X_IB_ghost_vecs[part];
+
+    std::unique_ptr<NumericVector<double> > P_in_rhs_vec = (*P_in_vec).zero_clone();
+    (*P_in_rhs_vec).zero();
+    DenseVector<double> P_in_rhs_e;
+    
+    std::unique_ptr<NumericVector<double> > P_out_rhs_vec = (*P_out_vec).zero_clone();
+    (*P_out_rhs_vec).zero();
+    DenseVector<double> P_out_rhs_e;
+
+    if (MathUtilities<double>::equalEps(data_time, d_current_time))
+    {
+        X_vec = d_X_current_vecs[part];
+    }
+    else if (MathUtilities<double>::equalEps(data_time, d_half_time))
+    {
+        X_vec = d_X_half_vecs[part];
+    }
+    else if (MathUtilities<double>::equalEps(data_time, d_new_time))
+    {
+        X_vec = d_X_new_vecs[part];
+    }
+    copy_and_synch(*X_vec, *X_ghost_vec);
+
+    // Extract the FE systems and DOF maps, and setup the FE object.
     EquationSystems* equation_systems = d_fe_data_managers[part]->getEquationSystems();
     const MeshBase& mesh = equation_systems->get_mesh();
     const unsigned int dim = mesh.mesh_dimension();
-
-    // Extract the FE systems and DOF maps, and setup the FE object.
-    System& DP_system = equation_systems->get_system(PRESSURE_JUMP_SYSTEM_NAME);
-    DofMap& DP_dof_map = DP_system.get_dof_map();
-    FEType DP_fe_type = DP_dof_map.variable_type(0);
-    std::vector<unsigned int> DP_dof_indices;
+    std::unique_ptr<QBase> qrule;
 
     System& X_system = equation_systems->get_system(COORDS_SYSTEM_NAME);
     DofMap& X_dof_map = X_system.get_dof_map();
-    FEDataManager::SystemDofMapCache& X_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(COORDS_SYSTEM_NAME);
+    std::vector<std::vector<unsigned int> > X_dof_indices(NDIM);
     FEType X_fe_type = X_dof_map.variable_type(0);
     for (unsigned int d = 0; d < NDIM; ++d)
     {
         TBOX_ASSERT(X_dof_map.variable_type(d) == X_fe_type);
     }
 
-    TBOX_ASSERT(DP_fe_type == X_fe_type);
-    FEType fe_type = DP_fe_type;
-
-    std::unique_ptr<FEBase> fe = FEBase::build(dim, fe_type);
-    const std::vector<std::vector<double> >& phi = fe->get_phi();
-    std::array<const std::vector<std::vector<double> >*, NDIM - 1> dphi_dxi;
-    dphi_dxi[0] = &fe->get_dphidxi();
-    if (NDIM > 2) dphi_dxi[1] = &fe->get_dphideta();
+    FEDataManager::SystemDofMapCache& P_jump_dof_map_cache =
+    *d_fe_data_managers[part]->getDofMapCache(PRESSURE_JUMP_SYSTEM_NAME);
+    std::vector<unsigned int> P_jump_dof_indices;
+    std::unique_ptr<FEBase> fe_X = FEBase::build(dim, X_fe_type);
+    const std::vector<double>& JxW = fe_X->get_JxW();
+    const std::vector<std::vector<double> >& phi_X = fe_X->get_phi();
+    std::array<const std::vector<std::vector<double> >*, NDIM - 1> dphi_dxi_X;
+    dphi_dxi_X[0] = &fe_X->get_dphidxi();
+    if (NDIM > 2) dphi_dxi_X[1] = &fe_X->get_dphideta();
+
+    System& P_in_system = equation_systems->get_system(PRESSURE_IN_SYSTEM_NAME);
+    const DofMap& P_in_dof_map = P_in_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& P_in_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(PRESSURE_IN_SYSTEM_NAME);
+    std::vector<unsigned int> P_in_dof_indices;
+    
+    
+    System& P_out_system = equation_systems->get_system(PRESSURE_OUT_SYSTEM_NAME);
+    const DofMap& P_out_dof_map = P_out_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& P_out_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(PRESSURE_OUT_SYSTEM_NAME);
+    FEType P_out_fe_type = P_out_dof_map.variable_type(0);
+    std::vector<unsigned int> P_out_dof_indices;
+
+    std::unique_ptr<FEBase> fe_P = FEBase::build(dim, P_out_fe_type);
+    const std::vector<std::vector<double> >& phi_P = fe_P->get_phi();
 
-    // Loop over the patches to impose jump conditions on the Eulerian grid.
     const std::vector<std::vector<Elem*> >& active_patch_element_map =
         d_fe_data_managers[part]->getActivePatchElementMap();
-    const int level_num = d_fe_data_managers[part]->getLevelNumber();
-    boost::multi_array<double, 1> DP_node;
+
     boost::multi_array<double, 2> x_node;
+    std::vector<double> x_qp, x_in_qp, x_out_qp;
+    boost::multi_array<double, 1> P_jump_node;
+    std::vector<double> P_i_qp, P_o_qp, P_in_qp, P_out_qp, P_jump_qp, N_qp;
     std::array<VectorValue<double>, 2> dx_dxi;
-    VectorValue<double> n;
-    std::vector<libMesh::Point> X_node_cache, x_node_cache;
-    IBTK::Point x_min, x_max;
-    Pointer<PatchLevel<NDIM> > level = d_hierarchy->getPatchLevel(level_num);
-    const IntVector<NDIM>& ratio = level->getRatio();
+
+    Pointer<PatchLevel<NDIM> > level = d_hierarchy->getPatchLevel(d_fe_data_managers[part]->getLevelNumber());
     const Pointer<CartesianGridGeometry<NDIM> > grid_geom = level->getGridGeometry();
+    VectorValue<double> tau1, tau2, n;
+    X_ghost_vec->close();
     int local_patch_num = 0;
     for (PatchLevel<NDIM>::Iterator p(level); p; p++, ++local_patch_num)
     {
         // The relevant collection of elements.
         const std::vector<Elem*>& patch_elems = active_patch_element_map[local_patch_num];
         const size_t num_active_patch_elems = patch_elems.size();
-        if (num_active_patch_elems == 0) continue;
-
+        if (!num_active_patch_elems) continue;
         const Pointer<Patch<NDIM> > patch = level->getPatch(p());
-        Pointer<SideData<NDIM, double> > f_data = patch->getPatchData(f_data_idx);
-        const Box<NDIM>& patch_box = patch->getBox();
-        const CellIndex<NDIM>& patch_lower = patch_box.lower();
-        std::array<Box<NDIM>, NDIM> side_ghost_boxes;
+        const Pointer<CartesianPatchGeometry<NDIM> > patch_geom = patch->getPatchGeometry();
+        const double* const patch_dx = patch_geom->getDx();
+        const double patch_dx_min = *std::min_element(patch_dx, patch_dx + NDIM);
+
+        const Pointer<CartesianPatchGeometry<NDIM> > pgeom = patch->getPatchGeometry();
+        const double* const x_lower = pgeom->getXLower();
+        const double* const x_upper = pgeom->getXUpper();
+
+        const double* const dx = pgeom->getDx();
+
+        double diag_dis = 0.0;
         for (unsigned int d = 0; d < NDIM; ++d)
         {
-            side_ghost_boxes[d] = SideGeometry<NDIM>::toSideBox(f_data->getGhostBox(), d);
+            diag_dis += dx[d] * dx[d];
         }
-        const Pointer<CartesianPatchGeometry<NDIM> > patch_geom = patch->getPatchGeometry();
-        const double* const x_lower = patch_geom->getXLower();
-        const double* const dx = patch_geom->getDx();
 
-        std::array<std::map<hier::Index<NDIM>, std::vector<libMesh::Point>, IndexOrder>, NDIM> intersection_points,
-            intersection_ref_coords;
-        std::array<std::map<hier::Index<NDIM>, std::vector<VectorValue<double> >, IndexOrder>, NDIM>
-            intersection_normals;
+        if (d_p_calc_width == 0)
+        {
+           TBOX_ERROR(d_object_name << ": The width for the interfacial pressure calc hasn't been set up!"
+                      << std::endl);
+        }
+        const double dh = d_p_calc_width * sqrt(diag_dis);
 
-        // Loop over the elements.
-        for (size_t e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
+        const int p_ghost_num = static_cast<int>(ceil(2.0 * dh / patch_dx_min));
+
+        std::array<double, NDIM> x_lower_gh, x_upper_gh;
+        for (unsigned int d = 0; d < NDIM; ++d)
+        {
+            x_lower_gh[d] = x_lower[d] - (static_cast<double>(p_ghost_num)) * dx[d];
+            x_upper_gh[d] = x_upper[d] + (static_cast<double>(p_ghost_num)) * dx[d];
+        }
+
+        double* x_upper_ghost = x_upper_gh.data();
+        double* x_lower_ghost = x_lower_gh.data();
+
+        // Setup vectors to store the values of U and X at the quadrature
+        // points.
+        //
+        // All this loop is doing is computing the total number of quadraturee
+        // points associated with all of the elements we are currently
+        // processing.  That number is n_qp_patch.
+        unsigned int n_qp_patch = 0;
+        for (unsigned int e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
         {
             Elem* const elem = patch_elems[e_idx];
-            DP_dof_map.dof_indices(elem, DP_dof_indices);
-            const auto& X_dof_indices = X_dof_map_cache.dof_indices(elem);
-            get_values_for_interpolation(DP_node, DP_ghost_vec, DP_dof_indices);
-            get_values_for_interpolation(x_node, X_ghost_vec, X_dof_indices);
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                X_dof_map.dof_indices(elem, X_dof_indices[d], d);
+            }
+            get_values_for_interpolation(x_node, *X_ghost_vec, X_dof_indices);
+
+            FEDataManager::updateInterpQuadratureRule(qrule, d_default_interp_spec, elem, x_node, patch_dx_min);
+
+            n_qp_patch += qrule->n_points();
+        }
+
+        if (!n_qp_patch) continue;
+        P_jump_qp.resize(n_qp_patch);
+        P_i_qp.resize(n_qp_patch);
+        P_o_qp.resize(n_qp_patch);
+        P_in_qp.resize(n_qp_patch);
+        P_out_qp.resize(n_qp_patch);
+        x_in_qp.resize(NDIM * n_qp_patch);
+        x_out_qp.resize(NDIM * n_qp_patch);
+        x_qp.resize(NDIM * n_qp_patch);
+        N_qp.resize(NDIM * n_qp_patch);
+        std::fill(P_i_qp.begin(), P_i_qp.end(), 0.0);
+        std::fill(P_o_qp.begin(), P_o_qp.end(), 0.0);
+        std::fill(P_in_qp.begin(), P_in_qp.end(), 0.0);
+        std::fill(P_out_qp.begin(), P_out_qp.end(), 0.0);
+		std::fill(P_jump_qp.begin(), P_jump_qp.end(), 0.0);
+        std::fill(N_qp.begin(), N_qp.end(), 0.0);
+
+        // Loop over the elements and compute the positions of the quadrature points.
+        qrule.reset();
+        unsigned int qp_offset = 0;
+        for (unsigned int e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
+        {
+            Elem* const elem = patch_elems[e_idx];
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                X_dof_map.dof_indices(elem, X_dof_indices[d], d);
+            }
+            get_values_for_interpolation(x_node, *X_ghost_vec, X_dof_indices);
+            
+            P_jump_dof_map_cache.dof_indices(elem, P_jump_dof_indices);
+            get_values_for_interpolation(P_jump_node, *P_jump_ghost_vec, P_jump_dof_indices);
+
+            const bool qrule_changed =
+                FEDataManager::updateInterpQuadratureRule(qrule, d_default_interp_spec, elem, x_node, patch_dx_min);
+
+            if (qrule_changed)
+            {
+                fe_X->attach_quadrature_rule(qrule.get());
+                fe_P->attach_quadrature_rule(qrule.get());
+            }
+            fe_X->reinit(elem);
+            fe_P->reinit(elem);
 
-            // Cache the nodal and physical coordinates of the side element,
-            // determine the bounding box of the current configuration of the
-            // element, and set the nodal coordinates to correspond to the
-            // physical coordinates.
             const unsigned int n_node = elem->n_nodes();
-            X_node_cache.resize(n_node);
-            x_node_cache.resize(n_node);
-            x_min = IBTK::Point::Constant(std::numeric_limits<double>::max());
-            x_max = IBTK::Point::Constant(-std::numeric_limits<double>::max());
-            for (unsigned int k = 0; k < n_node; ++k)
+            const unsigned int n_qp = qrule->n_points();
+
+            // Zero out the values of X, du, and dv prior to accumulation.
+            double* x_begin = &x_qp[NDIM * qp_offset];
+            std::fill(x_begin, x_begin + NDIM * n_qp, 0.0);
+
+            double* x_in_begin = &x_in_qp[NDIM * qp_offset];
+            std::fill(x_in_begin, x_in_begin + NDIM * n_qp, 0.0);
+            
+            double* x_out_begin = &x_out_qp[NDIM * qp_offset];
+            std::fill(x_out_begin, x_out_begin + NDIM * n_qp, 0.0);
+
+            double* N_begin = &N_qp[NDIM * qp_offset];
+            std::fill(N_begin, N_begin + NDIM * n_qp, 0.0);
+
+            // Interpolate X, du, and dv at all of the quadrature points
+            // via accumulation, i.e., X(qp) = sum_k X_k * phi_k(qp) for
+            // each qp.
+
+            for (unsigned int qp = 0; qp < n_qp; ++qp)
             {
-                X_node_cache[k] = elem->point(k);
-                libMesh::Point& x = x_node_cache[k];
-                for (unsigned int d = 0; d < NDIM; ++d)
+                for (unsigned int k = 0; k < NDIM - 1; ++k)
                 {
-                    x(d) = x_node[k][d];
+                    interpolate(dx_dxi[k], qp, x_node, *dphi_dxi_X[k]);
                 }
-                if (d_perturb_fe_mesh_nodes)
+                if (NDIM == 2)
                 {
-                    // Perturb the mesh configuration to keep the FE mesh nodes
-                    // away from cell edges, nodes, and centers.
-                    //
-                    // This implies that we only have to deal with multiple
-                    // intersections along element edges, and not at element
-                    // nodes.
-                    for (unsigned int d = 0; d < NDIM; ++d)
+                    dx_dxi[1] = VectorValue<double>(0.0, 0.0, 1.0);
+                }
+                n = (dx_dxi[0].cross(dx_dxi[1])).unit();
+
+                for (unsigned int i = 0; i < NDIM; ++i)
+                {
+                    for (unsigned int k = 0; k < n_node; ++k)
                     {
-                        const int i_s = std::floor((x(d) - x_lower[d]) / dx[d]) + patch_lower[d];
-                        for (int shift = 0; shift <= 2; ++shift)
-                        {
-                            const double x_s =
-                                x_lower[d] + dx[d] * (static_cast<double>(i_s - patch_lower[d]) + 0.5 * shift);
-                            const double tol = 1.0e-4 * dx[d];
-                            if (x(d) <= x_s) x(d) = std::min(x_s - tol, x(d));
-                            if (x(d) >= x_s) x(d) = std::max(x_s + tol, x(d));
-                        }
+                        const double& p_X = phi_X[k][qp];
+                        x_qp[NDIM * (qp_offset + qp) + i] += x_node[k][i] * p_X;
                     }
+                    N_qp[NDIM * (qp_offset + qp) + i] = n(i);
+                    // Note that here we calculate the pressure on one side as the jump plus the pressure on the other
+                    // side.
+                    x_in_qp[NDIM * (qp_offset + qp) + i] =
+                        x_qp[NDIM * (qp_offset + qp) + i] - n(i) * dh;
+                    x_out_qp[NDIM * (qp_offset + qp) + i] =
+                        x_qp[NDIM * (qp_offset + qp) + i] + n(i) * dh;
                 }
-                for (unsigned int d = 0; d < NDIM; ++d)
+                for (unsigned int k = 0; k < n_node; ++k)
                 {
-                    x_min[d] = std::min(x_min[d], x(d));
-                    x_max[d] = std::max(x_max[d], x(d));
+                    const double& p_P = phi_P[k][qp];
+
+                    P_jump_qp[qp_offset + qp] += P_jump_node[k] * p_P;
                 }
-                elem->point(k) = x;
             }
-            Box<NDIM> box(IndexUtilities::getCellIndex(&x_min[0], grid_geom, ratio),
-                          IndexUtilities::getCellIndex(&x_max[0], grid_geom, ratio));
-            box.grow(IntVector<NDIM>(1));
+            qp_offset += n_qp;
+        }
+        // Interpolate values from the Cartesian grid patch to the quadrature
+        // points.
+        // Note: Values are interpolated only to those quadrature points that
+        // are within the patch interior
+
+        const Box<NDIM>& interp_box = patch->getBox();
+
+        Pointer<CellData<NDIM, double> > p_data = patch->getPatchData(p_data_idx);
+
+        const Box<NDIM> ghost_box = Box<NDIM>::grow(patch->getBox(), IntVector<NDIM>(p_ghost_num));
+
+        LEInteractor::interpolate(
+            P_i_qp, 1, x_in_qp, NDIM, p_data, patch, ghost_box, d_default_interp_spec.kernel_fcn);
+            
+        LEInteractor::interpolate(
+            P_o_qp, 1, x_out_qp, NDIM, p_data, patch, ghost_box, d_default_interp_spec.kernel_fcn);
+
+        std::vector<int> local_indices;
+        local_indices.clear();
+        const int upper_bound = n_qp_patch;
+        if (upper_bound == 0) return;
+
+        local_indices.reserve(upper_bound);
+        for (unsigned int k = 0; k < n_qp_patch; ++k)
+        {
+            const double* const xx = &x_qp[NDIM * k];
+            const Index<NDIM> i = IndexUtilities::getCellIndex(xx, patch_geom, interp_box);
+            if (interp_box.contains(i)) local_indices.push_back(k);
+
+            const double* const x_i = &x_in_qp[NDIM * k];
+            const Index<NDIM> ip = IndexUtilities::getCellIndex(
+                x_i, x_lower_ghost, x_upper_ghost, patch_geom->getDx(), ghost_box.lower(), ghost_box.upper());
+            if (!ghost_box.contains(ip) && interp_box.contains(i))
+                TBOX_ERROR(d_object_name << "::IBFESurfaceMethod():\n"
+                                         << " the pressure interpolation ghost width hasn't beeen properly set"
+                                         << std::endl);
+            const double* const x_o = &x_out_qp[NDIM * k];
+            const Index<NDIM> op = IndexUtilities::getCellIndex(
+                x_o, x_lower_ghost, x_upper_ghost, patch_geom->getDx(), ghost_box.lower(), ghost_box.upper());
+            if (!ghost_box.contains(op) && interp_box.contains(i))
+                TBOX_ERROR(d_object_name << "::IBFESurfaceMethod():\n"
+                                         << " the pressure interpolation ghost width hasn't beeen properly set"
+                                         << std::endl);
+        }
+
+        const unsigned int nindices = static_cast<int>(local_indices.size());
+
+        if (!local_indices.empty())
+        {
+            for (unsigned int k = 0; k < nindices; ++k)
+            {
+                P_out_qp[local_indices[k]] = P_o_qp[local_indices[k]];
+                P_in_qp[local_indices[k]] = P_i_qp[local_indices[k]];
+            }
+        }
+
+        // Loop over the elements and accumulate the right-hand-side values.
+        qrule.reset();
+        qp_offset = 0;
+        for (unsigned int e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
+        {
+            Elem* const elem = patch_elems[e_idx];
+
+            P_in_dof_map_cache.dof_indices(elem, P_in_dof_indices);
+            P_in_rhs_e.resize(static_cast<int>(P_in_dof_indices.size()));
+            
+            P_out_dof_map_cache.dof_indices(elem, P_out_dof_indices);
+            P_out_rhs_e.resize(static_cast<int>(P_out_dof_indices.size()));
+
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                X_dof_map.dof_indices(elem, X_dof_indices[d], d);
+            }
+            get_values_for_interpolation(x_node, *X_ghost_vec, X_dof_indices);
+            const bool qrule_changed =
+                FEDataManager::updateInterpQuadratureRule(qrule, d_default_interp_spec, elem, x_node, patch_dx_min);
+            if (qrule_changed)
+            {
+                fe_X->attach_quadrature_rule(qrule.get());
+                fe_P->attach_quadrature_rule(qrule.get());
+            }
+
+            fe_X->reinit(elem);
+            fe_P->reinit(elem);
+
+            const unsigned int n_qp = qrule->n_points();
+            const size_t n_basis2 = P_out_dof_indices.size();
+            for (unsigned int qp = 0; qp < n_qp; ++qp)
+            {
+                const int idx = qp_offset + qp;
+                for (unsigned int k = 0; k < n_basis2; ++k)
+                {
+                    const double p_JxW = phi_P[k][qp] * JxW[qp];
+                    P_in_rhs_e(k) += P_in_qp[idx] * p_JxW;
+                    P_out_rhs_e(k) += P_out_qp[idx] * p_JxW;
+                }
+            }
+
+            P_in_dof_map.constrain_element_vector(P_in_rhs_e, P_in_dof_indices);
+            P_in_rhs_vec->add_vector(P_in_rhs_e, P_in_dof_indices);
+            
+            P_out_dof_map.constrain_element_vector(P_out_rhs_e, P_out_dof_indices);
+            P_out_rhs_vec->add_vector(P_out_rhs_e, P_out_dof_indices);
+
+            qp_offset += n_qp;
+        }
+    }
+    P_in_rhs_vec->close();
+    P_out_rhs_vec->close();
+
+    d_fe_data_managers[part]->computeL2Projection(
+        *P_in_vec, *P_in_rhs_vec, PRESSURE_IN_SYSTEM_NAME, d_default_interp_spec.use_consistent_mass_matrix);
+        
+    d_fe_data_managers[part]->computeL2Projection(
+        *P_out_vec, *P_out_rhs_vec, PRESSURE_OUT_SYSTEM_NAME, d_default_interp_spec.use_consistent_mass_matrix);
+
+    d_X_half_vecs[part]->close();
+    d_X_current_vecs[part]->close();
+    d_X_new_vecs[part]->close();
+
+    d_P_in_half_vecs[part]->close();
+    d_P_out_half_vecs[part]->close();
+    d_X_IB_ghost_vecs[part]->close();
+
+    return;
+
+} // extrapolatePressureForTraction
+
+void
+IBFESurfaceMethod::computeFluidTraction(const double data_time, unsigned int part)
+{
+    batch_vec_ghost_update({ d_WSS_in_half_vecs[part],
+                             d_WSS_out_half_vecs[part],
+                             d_P_in_half_vecs[part], 
+                             d_P_out_half_vecs[part],
+                             d_TAU_in_half_vecs[part],
+                             d_TAU_out_half_vecs[part],
+                             d_X_new_vecs[part] },
+                           INSERT_VALUES,
+                           SCATTER_FORWARD);
+    NumericVector<double>* WSS_in_vec = NULL;
+    NumericVector<double>* WSS_in_ghost_vec = d_WSS_in_IB_ghost_vecs[part];
+    
+    NumericVector<double>* WSS_out_vec = NULL;
+    NumericVector<double>* WSS_out_ghost_vec = d_WSS_out_IB_ghost_vecs[part];
+
+    NumericVector<double>* P_in_vec = NULL;
+    NumericVector<double>* P_in_ghost_vec = d_P_in_IB_ghost_vecs[part];
+    
+    NumericVector<double>* P_out_vec = NULL;
+    NumericVector<double>* P_out_ghost_vec = d_P_out_IB_ghost_vecs[part];
+
+    NumericVector<double>* TAU_in_vec = d_TAU_in_half_vecs[part];
+    NumericVector<double>* TAU_out_vec = d_TAU_out_half_vecs[part];
+
+    NumericVector<double>* X_vec = NULL;
+
+    if (MathUtilities<double>::equalEps(data_time, d_current_time))
+    {
+        X_vec = d_X_current_vecs[part];
+    }
+    else if (MathUtilities<double>::equalEps(data_time, d_half_time))
+    {
+        X_vec = d_X_half_vecs[part];
+    }
+    else if (MathUtilities<double>::equalEps(data_time, d_new_time))
+    {
+        X_vec = d_X_new_vecs[part];
+    }
+    NumericVector<double>* X_ghost_vec = d_X_IB_ghost_vecs[part];
+    copy_and_synch(*X_vec, *X_ghost_vec);
+
+    WSS_in_vec = d_WSS_in_half_vecs[part];
+    copy_and_synch(*WSS_in_vec, *WSS_in_ghost_vec);
+
+    WSS_out_vec = d_WSS_out_half_vecs[part];
+    copy_and_synch(*WSS_out_vec, *WSS_out_ghost_vec);
+    
+    P_in_vec = d_P_in_half_vecs[part];
+    copy_and_synch(*P_in_vec, *P_in_ghost_vec);
+    
+    P_out_vec = d_P_out_half_vecs[part];
+    copy_and_synch(*P_out_vec, *P_out_ghost_vec);
+
+    std::unique_ptr<NumericVector<double> > TAU_in_rhs_vec = TAU_in_vec->zero_clone();
+    std::array<DenseVector<double>, NDIM> TAU_in_rhs_e;
+    
+    std::unique_ptr<NumericVector<double> > TAU_out_rhs_vec = TAU_out_vec->zero_clone();
+    std::array<DenseVector<double>, NDIM> TAU_out_rhs_e;
+
+    // Extract the FE systems and DOF maps, and setup the FE objects.
+    EquationSystems* equation_systems = d_fe_data_managers[part]->getEquationSystems();
+    const MeshBase& mesh = equation_systems->get_mesh();
+    const unsigned int dim = mesh.mesh_dimension();
+    std::unique_ptr<QBase> qrule;
+
+    System& X_system = equation_systems->get_system(COORDS_SYSTEM_NAME);
+    const DofMap& X_dof_map = X_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& X_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(COORDS_SYSTEM_NAME);
+    FEType X_fe_type = X_dof_map.variable_type(0);
+    for (unsigned int d = 0; d < NDIM; ++d)
+    {
+        TBOX_ASSERT(X_dof_map.variable_type(d) == X_fe_type);
+    }
+
+    System& P_in_system = equation_systems->get_system(PRESSURE_IN_SYSTEM_NAME);
+    const DofMap& P_in_dof_map = P_in_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& P_in_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(PRESSURE_IN_SYSTEM_NAME);
+    FEType P_in_fe_type = P_in_dof_map.variable_type(0);
+    
+    System& P_out_system = equation_systems->get_system(PRESSURE_OUT_SYSTEM_NAME);
+    const DofMap& P_out_dof_map = P_out_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& P_out_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(PRESSURE_OUT_SYSTEM_NAME);
+    FEType P_out_fe_type = P_out_dof_map.variable_type(0);
+
+    System& WSS_in_system = equation_systems->get_system(WSS_IN_SYSTEM_NAME);
+    const DofMap& WSS_in_dof_map = WSS_in_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& WSS_in_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(WSS_IN_SYSTEM_NAME);
+    FEType WSS_in_fe_type = WSS_in_dof_map.variable_type(0);
+    for (unsigned int d = 0; d < NDIM; ++d)
+    {
+        TBOX_ASSERT(WSS_in_dof_map.variable_type(d) == WSS_in_fe_type);
+    }
+    TBOX_ASSERT(WSS_in_fe_type == P_in_fe_type);
+    
+    
+    System& WSS_out_system = equation_systems->get_system(WSS_OUT_SYSTEM_NAME);
+    const DofMap& WSS_out_dof_map = WSS_out_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& WSS_out_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(WSS_OUT_SYSTEM_NAME);
+    FEType WSS_out_fe_type = WSS_out_dof_map.variable_type(0);
+    for (unsigned int d = 0; d < NDIM; ++d)
+    {
+        TBOX_ASSERT(WSS_out_dof_map.variable_type(d) == WSS_out_fe_type);
+    }
+    TBOX_ASSERT(WSS_out_fe_type == P_out_fe_type);
+
+    System& TAU_in_system = equation_systems->get_system(TAU_IN_SYSTEM_NAME);
+    const DofMap& TAU_in_dof_map = TAU_in_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& TAU_in_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(TAU_IN_SYSTEM_NAME);
+    FEType TAU_in_fe_type = TAU_in_dof_map.variable_type(0);
+    for (unsigned int d = 0; d < NDIM; ++d)
+    {
+        TBOX_ASSERT(TAU_in_dof_map.variable_type(d) == TAU_in_fe_type);
+    }
+    TBOX_ASSERT(TAU_in_fe_type == P_in_fe_type);
+    
+    System& TAU_out_system = equation_systems->get_system(TAU_OUT_SYSTEM_NAME);
+    const DofMap& TAU_out_dof_map = TAU_out_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& TAU_out_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(TAU_OUT_SYSTEM_NAME);
+    FEType TAU_out_fe_type = TAU_out_dof_map.variable_type(0);
+    for (unsigned int d = 0; d < NDIM; ++d)
+    {
+        TBOX_ASSERT(TAU_out_dof_map.variable_type(d) == TAU_out_fe_type);
+    }
+    TBOX_ASSERT(TAU_out_fe_type == P_out_fe_type);
+    
+    std::unique_ptr<FEBase> fe_X = FEBase::build(dim, X_fe_type);
+    const std::vector<double>& JxW = fe_X->get_JxW();
+    const std::vector<std::vector<double> >& phi_X = fe_X->get_phi();
+    std::array<const std::vector<std::vector<double> >*, NDIM - 1> dphi_dxi_X;
+    dphi_dxi_X[0] = &fe_X->get_dphidxi();
+    if (NDIM > 2) dphi_dxi_X[1] = &fe_X->get_dphideta();
+
+    std::unique_ptr<FEBase> fe_P = FEBase::build(dim, P_out_fe_type);
+    const std::vector<std::vector<double> >& phi_P = fe_P->get_phi();
+
+    X_ghost_vec->close();
+    PetscVector<double>* X_petsc_vec = static_cast<PetscVector<double>*>(X_ghost_vec);
+    Vec X_global_vec = X_petsc_vec->vec();
+    Vec X_local_vec;
+    VecGhostGetLocalForm(X_global_vec, &X_local_vec);
+    double* X_local_soln;
+    VecGetArray(X_local_vec, &X_local_soln);
+    std::unique_ptr<NumericVector<double> > X0_vec = X_petsc_vec->clone();
+    copy_and_synch(X_system.get_vector("INITIAL_COORDINATES"), *X0_vec);
+    X0_vec->close();
+
+    const std::vector<std::vector<Elem*> >& active_patch_element_map =
+        d_fe_data_managers[part]->getActivePatchElementMap();
+
+    boost::multi_array<double, 2> x_node, X_node, WSS_in_node, WSS_out_node, n_qp_node;
+    boost::multi_array<double, 1> P_in_node, P_out_node;
+    std::vector<double> x_in_qp, x_out_qp, x_qp;
+    std::vector<double> P_in_qp, P_out_qp, Normal_qp, WSS_in_qp, WSS_out_qp, TAU_in_qp, TAU_out_qp;
+    std::array<VectorValue<double>, 2> dX_dxi, dx_dxi;
+    VectorValue<double> n, N, x, X;
+
+    Pointer<PatchLevel<NDIM> > level = d_hierarchy->getPatchLevel(d_fe_data_managers[part]->getLevelNumber());
+    const Pointer<CartesianGridGeometry<NDIM> > grid_geom = level->getGridGeometry();
+    int local_patch_num = 0;
+    for (PatchLevel<NDIM>::Iterator p(level); p; p++, ++local_patch_num)
+    {
+        // The relevant collection of elements.
+        const std::vector<Elem*>& patch_elems = active_patch_element_map[local_patch_num];
+        const size_t num_active_patch_elems = patch_elems.size();
+        if (!num_active_patch_elems) continue;
+        const Pointer<Patch<NDIM> > patch = level->getPatch(p());
+        const Pointer<CartesianPatchGeometry<NDIM> > patch_geom = patch->getPatchGeometry();
+        const double* const patch_dx = patch_geom->getDx();
+        const double patch_dx_min = *std::min_element(patch_dx, patch_dx + NDIM);
+
+        const Pointer<CartesianPatchGeometry<NDIM> > pgeom = patch->getPatchGeometry();
+
+        const double* const dx = pgeom->getDx();
+
+        double diag_dis = 0.0;
+        for (unsigned int d = 0; d < NDIM; ++d)
+        {
+            diag_dis += dx[d] * dx[d];
+        }
+
+        unsigned int n_qp_patch = 0;
+        for (unsigned int e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
+        {
+            Elem* const elem = patch_elems[e_idx];
+            const auto& X_dof_indices = X_dof_map_cache.dof_indices(elem);
+            get_values_for_interpolation(x_node, *X_petsc_vec, X_local_soln, X_dof_indices);
+            FEDataManager::updateInterpQuadratureRule(qrule, d_default_interp_spec, elem, x_node, patch_dx_min);
+            n_qp_patch += qrule->n_points();
+        }
+
+        if (!n_qp_patch) continue;
+        P_in_qp.resize(n_qp_patch);
+        P_out_qp.resize(n_qp_patch);
+        x_qp.resize(NDIM * n_qp_patch);
+        WSS_in_qp.resize(NDIM * n_qp_patch);
+        WSS_out_qp.resize(NDIM * n_qp_patch);
+
+        TAU_in_qp.resize(NDIM * n_qp_patch);
+        TAU_out_qp.resize(NDIM * n_qp_patch);
+        Normal_qp.resize(NDIM * n_qp_patch);
+        std::fill(Normal_qp.begin(), Normal_qp.end(), 0.0);
+        std::fill(x_qp.begin(), x_qp.end(), 0.0);
+        std::fill(WSS_in_qp.begin(), WSS_in_qp.end(), 0.0);
+        std::fill(WSS_out_qp.begin(), WSS_out_qp.end(), 0.0);
+        std::fill(P_in_qp.begin(), P_in_qp.end(), 0.0);
+        std::fill(P_out_qp.begin(), P_out_qp.end(), 0.0);
+        std::fill(TAU_in_qp.begin(), TAU_in_qp.end(), 0.0);
+        std::fill(TAU_out_qp.begin(), TAU_out_qp.end(), 0.0);
+
+        // Loop over the elements and compute the positions of the quadrature points.
+        qrule.reset();
+        unsigned int qp_offset = 0;
+        for (unsigned int e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
+        {
+            Elem* const elem = patch_elems[e_idx];
+            const auto& X_dof_indices = X_dof_map_cache.dof_indices(elem);
+            const auto& WSS_in_dof_indices = WSS_in_dof_map_cache.dof_indices(elem);
+            const auto& WSS_out_dof_indices = WSS_out_dof_map_cache.dof_indices(elem);
+            const auto& P_in_dof_indices = P_in_dof_map_cache.dof_indices(elem);
+            const auto& P_out_dof_indices = P_out_dof_map_cache.dof_indices(elem);
+            get_values_for_interpolation(x_node, *X_petsc_vec, X_local_soln, X_dof_indices);
+            get_values_for_interpolation(WSS_in_node, *WSS_in_ghost_vec, WSS_in_dof_indices);
+            get_values_for_interpolation(WSS_out_node, *WSS_out_ghost_vec, WSS_out_dof_indices);
+            get_values_for_interpolation(P_in_node, *P_in_ghost_vec, P_in_dof_indices[0]);
+            get_values_for_interpolation(P_out_node, *P_out_ghost_vec, P_out_dof_indices[0]);
+            get_values_for_interpolation(X_node, *X0_vec, X_dof_indices);
+
+            const bool qrule_changed =
+                FEDataManager::updateInterpQuadratureRule(qrule, d_default_interp_spec, elem, x_node, patch_dx_min);
+            if (qrule_changed)
+            {
+                fe_X->attach_quadrature_rule(qrule.get());
+                fe_P->attach_quadrature_rule(qrule.get());
+            }
+            fe_X->reinit(elem);
+            fe_P->reinit(elem);
+
+            const unsigned int n_node = elem->n_nodes();
+            const unsigned int n_qp = qrule->n_points();
+
+            // Zero out the values of X, du, and dv prior to accumulation.
+            double* x_begin = &x_qp[NDIM * qp_offset];
+            std::fill(x_begin, x_begin + NDIM * n_qp, 0.0);
+
+            double* Normal_begin = &Normal_qp[NDIM * qp_offset];
+            std::fill(Normal_begin, Normal_begin + NDIM * n_qp, 0.0);
+
+            double* WSS_in_begin = &WSS_in_qp[NDIM * qp_offset];
+            std::fill(WSS_in_begin, WSS_in_begin + NDIM * n_qp, 0.0);
+            
+            double* WSS_out_begin = &WSS_out_qp[NDIM * qp_offset];
+            std::fill(WSS_out_begin, WSS_out_begin + NDIM * n_qp, 0.0);
+
+            double* TAU_in_begin = &TAU_in_qp[NDIM * qp_offset];
+            std::fill(TAU_in_begin, TAU_in_begin + NDIM * n_qp, 0.0);
+            
+            double* TAU_out_begin = &TAU_out_qp[NDIM * qp_offset];
+            std::fill(TAU_out_begin, TAU_out_begin + NDIM * n_qp, 0.0);
+
+            double* P_in_begin = &P_in_qp[qp_offset];
+            std::fill(P_in_begin, P_in_begin + n_qp, 0.0);
+            
+            double* P_out_begin = &P_out_qp[qp_offset];
+            std::fill(P_out_begin, P_out_begin + n_qp, 0.0);
+
+            for (unsigned int qp = 0; qp < n_qp; ++qp)
+            {
+                interpolate(X, qp, X_node, phi_X);
+                interpolate(x, qp, x_node, phi_X);
+                for (unsigned int k = 0; k < NDIM - 1; ++k)
+                {
+                    interpolate(dX_dxi[k], qp, X_node, *dphi_dxi_X[k]);
+                    interpolate(dx_dxi[k], qp, x_node, *dphi_dxi_X[k]);
+                }
+                if (NDIM == 2)
+                {
+                    dX_dxi[1] = dx_dxi[1] = VectorValue<double>(0.0, 0.0, 1.0);
+                }
+
+                // Construct unit vectors in the reference and current
+                // configurations.
+                N = dX_dxi[0].cross(dX_dxi[1]);
+                const double dA = N.norm();
+                N = N.unit();
+                n = dx_dxi[0].cross(dx_dxi[1]);
+                const double da = n.norm();
+                n = n.unit();
+
+                for (unsigned int i = 0; i < NDIM; ++i)
+                {
+                    for (unsigned int k = 0; k < n_node; ++k)
+                    {
+                        const double& p_X = phi_X[k][qp];
+                        x_qp[NDIM * (qp_offset + qp) + i] += x_node[k][i] * p_X;
+                        const double& p_P = phi_P[k][qp];
+                        WSS_in_qp[NDIM * (qp_offset + qp) + i] += (da / dA) * WSS_in_node[k][i] * p_P;
+                        WSS_out_qp[NDIM * (qp_offset + qp) + i] += (da / dA) * WSS_out_node[k][i] * p_P;
+                    }
+                    Normal_qp[NDIM * (qp_offset + qp) + i] = n(i);
+                }
+
+                for (unsigned int k = 0; k < n_node; ++k)
+                {
+                    const double& p_P = phi_P[k][qp];
+                    P_in_qp[qp_offset + qp] += (da / dA) * P_in_node[k] * p_P;
+                    P_out_qp[qp_offset + qp] += (da / dA) * P_out_node[k] * p_P;
+                }
+            }
+            qp_offset += n_qp;
+        }
+
+        const Box<NDIM>& interp_box = patch->getBox();
+        std::vector<int> local_indices;
+        local_indices.clear();
+        const int upper_bound = n_qp_patch;
+        if (upper_bound == 0) return;
+
+        local_indices.reserve(upper_bound);
+        for (unsigned int k = 0; k < n_qp_patch; ++k)
+        {
+            const double* const XX = &x_qp[NDIM * k];
+            const Index<NDIM> i = IndexUtilities::getCellIndex(XX, patch_geom, interp_box);
+            if (interp_box.contains(i)) local_indices.push_back(k);
+        }
+
+        const unsigned int nindices = static_cast<int>(local_indices.size());
+
+        if (!local_indices.empty())
+        {
+            for (unsigned int axis = 0; axis < NDIM; ++axis)
+            {
+                for (unsigned int k = 0; k < nindices; ++k)
+                {
+                    // calculate both the interior and exterior fluid tracitons (tau)
+                    TAU_in_qp[NDIM * local_indices[k] + axis] =
+                        WSS_in_qp[NDIM * local_indices[k] + axis] -
+                        P_in_qp[local_indices[k]] * Normal_qp[NDIM * local_indices[k] + axis];
+
+                    TAU_out_qp[NDIM * local_indices[k] + axis] =
+                        WSS_out_qp[NDIM * local_indices[k] + axis] -
+                        P_out_qp[local_indices[k]] * Normal_qp[NDIM * local_indices[k] + axis];
+                }
+            }
+        }
+
+        // Loop over the elements and accumulate the right-hand-side values.
+        qrule.reset();
+        qp_offset = 0;
+        for (unsigned int e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
+        {
+            Elem* const elem = patch_elems[e_idx];
+            const auto& X_dof_indices = X_dof_map_cache.dof_indices(elem);
+            const auto& TAU_in_dof_indices = TAU_in_dof_map_cache.dof_indices(elem);
+            const auto& TAU_out_dof_indices = TAU_out_dof_map_cache.dof_indices(elem);
+            
+            for (unsigned int i = 0; i < NDIM; ++i)
+            {
+                TAU_in_rhs_e[i].resize(static_cast<int>(TAU_in_dof_indices[i].size()));
+                TAU_out_rhs_e[i].resize(static_cast<int>(TAU_out_dof_indices[i].size()));
+            }
+
+            get_values_for_interpolation(x_node, *X_petsc_vec, X_local_soln, X_dof_indices);
+            const bool qrule_changed =
+                FEDataManager::updateInterpQuadratureRule(qrule, d_default_interp_spec, elem, x_node, patch_dx_min);
+            if (qrule_changed)
+            {
+                fe_X->attach_quadrature_rule(qrule.get());
+                fe_P->attach_quadrature_rule(qrule.get());
+            }
+            fe_X->reinit(elem);
+            fe_P->reinit(elem);
+            const unsigned int n_qp = qrule->n_points();
+            const size_t n_basis2 = TAU_out_dof_indices[0].size();
+            for (unsigned int qp = 0; qp < n_qp; ++qp)
+            {
+                const int idx = NDIM * (qp_offset + qp);
+                for (unsigned int k = 0; k < n_basis2; ++k)
+                {
+                    const double p_JxW = phi_P[k][qp] * JxW[qp];
+                    for (unsigned int i = 0; i < NDIM; ++i)
+                    {
+                        TAU_in_rhs_e[i](k) += TAU_in_qp[idx + i] * p_JxW;
+                        TAU_out_rhs_e[i](k) += TAU_out_qp[idx + i] * p_JxW;
+                    }
+                }
+            }
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                auto dof_id_in_scratch = TAU_in_dof_indices[d];
+                TAU_in_dof_map.constrain_element_vector(TAU_in_rhs_e[d], dof_id_in_scratch);
+                TAU_in_rhs_vec->add_vector(TAU_in_rhs_e[d], dof_id_in_scratch);
+                
+                auto dof_id_out_scratch = TAU_out_dof_indices[d];
+                TAU_out_dof_map.constrain_element_vector(TAU_out_rhs_e[d], dof_id_out_scratch);
+                TAU_out_rhs_vec->add_vector(TAU_out_rhs_e[d], dof_id_out_scratch);
+            }
+            qp_offset += n_qp;
+        }
+    }
+
+    TAU_in_rhs_vec->close();
+    TAU_out_rhs_vec->close();
+
+    d_fe_data_managers[part]->computeL2Projection(
+        *TAU_in_vec, *TAU_in_rhs_vec, TAU_IN_SYSTEM_NAME, d_default_interp_spec.use_consistent_mass_matrix);
+        
+   d_fe_data_managers[part]->computeL2Projection(
+        *TAU_out_vec, *TAU_out_rhs_vec, TAU_OUT_SYSTEM_NAME, d_default_interp_spec.use_consistent_mass_matrix);
+
+    d_X_half_vecs[part]->close();
+    d_X_current_vecs[part]->close();
+    d_X_new_vecs[part]->close();
+    d_TAU_in_half_vecs[part]->close();
+    d_WSS_in_half_vecs[part]->close();
+    d_P_in_half_vecs[part]->close();
+    d_TAU_out_half_vecs[part]->close();
+    d_WSS_out_half_vecs[part]->close();
+    d_P_out_half_vecs[part]->close();
+
+    VecRestoreArray(X_local_vec, &X_local_soln);
+    VecGhostRestoreLocalForm(X_global_vec, &X_local_vec);
+
+    d_WSS_in_IB_ghost_vecs[part]->close();
+    d_WSS_out_IB_ghost_vecs[part]->close();
+    
+    d_P_in_IB_ghost_vecs[part]->close();
+    d_P_out_IB_ghost_vecs[part]->close();
+    d_X_IB_ghost_vecs[part]->close();
+
+    return;
+} // computeFluidTraction
+
+void
+IBFESurfaceMethod::imposeJumpConditions(const int f_data_idx,
+                                        PetscVector<double>& P_jump_ghost_vec,
+                                        std::array<PetscVector<double>*, NDIM>& DU_jump_ghost_vec,
+                                        PetscVector<double>& X_ghost_vec,
+                                        const double /*data_time*/,
+                                        const unsigned int part)
+{
+    // Extract the mesh.
+    EquationSystems* equation_systems = d_fe_data_managers[part]->getEquationSystems();
+    const MeshBase& mesh = equation_systems->get_mesh();
+    const unsigned int dim = mesh.mesh_dimension();
+
+    // Extract the FE systems and DOF maps, and setup the FE object
+    System& X_system = equation_systems->get_system(COORDS_SYSTEM_NAME);
+    const DofMap& X_dof_map = X_system.get_dof_map();
+    FEDataManager::SystemDofMapCache& X_dof_map_cache = *d_fe_data_managers[part]->getDofMapCache(COORDS_SYSTEM_NAME);
+    FEType X_fe_type = X_dof_map.variable_type(0);
+    for (unsigned int d = 0; d < NDIM; ++d) TBOX_ASSERT(X_dof_map.variable_type(d) == X_fe_type);
+
+    System* P_jump_system;
+    const DofMap* P_jump_dof_map;
+    FEDataManager::SystemDofMapCache* P_jump_dof_map_cache = NULL;
+    FEType P_jump_fe_type;
+    if (d_use_pressure_jump_conditions)
+    {
+        P_jump_system = &equation_systems->get_system(PRESSURE_JUMP_SYSTEM_NAME);
+        P_jump_dof_map = &P_jump_system->get_dof_map();
+        P_jump_dof_map_cache = d_fe_data_managers[part]->getDofMapCache(PRESSURE_JUMP_SYSTEM_NAME);
+        P_jump_fe_type = P_jump_dof_map->variable_type(0);
+    }
+
+    std::array<DofMap*, NDIM> DU_jump_dof_map;
+    std::array<FEDataManager::SystemDofMapCache*, NDIM> DU_jump_dof_map_cache;
+    std::array<System*, NDIM> DU_jump_system;
+    FEType DU_jump_fe_type;
+    if (d_use_velocity_jump_conditions)
+    {
+        for (unsigned int i = 0; i < NDIM; ++i)
+        {
+            DU_jump_system[i] = &equation_systems->get_system(VELOCITY_JUMP_SYSTEM_NAME[i]);
+            DU_jump_dof_map_cache[i] = d_fe_data_managers[part]->getDofMapCache(VELOCITY_JUMP_SYSTEM_NAME[i]);
+            DU_jump_dof_map[i] = &DU_jump_system[i]->get_dof_map();
+            DU_jump_fe_type = DU_jump_dof_map[i]->variable_type(0);
+            for (unsigned int d = 0; d < NDIM; ++d)
+            {
+                TBOX_ASSERT(DU_jump_dof_map[i]->variable_type(d) == DU_jump_fe_type);
+            }
+        }
+    }
+
+    FEType fe_type = X_fe_type;
+    std::unique_ptr<FEBase> fe_X = FEBase::build(dim, fe_type);
+    std::array<const std::vector<std::vector<double> >*, NDIM - 1> dphi_dxi;
+    dphi_dxi[0] = &fe_X->get_dphidxi();
+    if (NDIM > 2) dphi_dxi[1] = &fe_X->get_dphideta();
+
+    std::unique_ptr<FEBase> fe_P_jump = FEBase::build(dim, P_jump_fe_type);
+    const std::vector<std::vector<double> >& phi_P_jump = fe_P_jump->get_phi();
+
+    // Loop over the patches to impose jump conditions on the Eulerian grid.
+    const std::vector<std::vector<Elem*> >& active_patch_element_map =
+        d_fe_data_managers[part]->getActivePatchElementMap();
+    const int level_num = d_fe_data_managers[part]->getLevelNumber();
+    boost::multi_array<double, 1> P_jump_node;
+    boost::multi_array<double, 2> x_node;
+    std::array<boost::multi_array<double, 2>, NDIM> DU_jump_node;
+    std::array<VectorValue<double>, 2> dx_dxi;
+    VectorValue<double> n, jn;
+    std::vector<libMesh::Point> X_node_cache, x_node_cache;
+    IBTK::Point x_min, x_max;
+    Pointer<PatchLevel<NDIM> > level = d_hierarchy->getPatchLevel(level_num);
+    const IntVector<NDIM>& ratio = level->getRatio();
+    const Pointer<CartesianGridGeometry<NDIM> > grid_geom = level->getGridGeometry();
+    int local_patch_num = 0;
+    for (PatchLevel<NDIM>::Iterator p(level); p; p++, ++local_patch_num)
+    {
+        // The relevant collection of elements.
+        const std::vector<Elem*>& patch_elems = active_patch_element_map[local_patch_num];
+        const size_t num_active_patch_elems = patch_elems.size();
+        if (num_active_patch_elems == 0) continue;
+
+        const Pointer<Patch<NDIM> > patch = level->getPatch(p());
+        Pointer<SideData<NDIM, double> > f_data = patch->getPatchData(f_data_idx);
+        const Box<NDIM>& patch_box = patch->getBox();
+        const CellIndex<NDIM>& patch_lower = patch_box.lower();
+        std::array<Box<NDIM>, NDIM> side_ghost_boxes;
+        for (unsigned int d = 0; d < NDIM; ++d)
+        {
+            side_ghost_boxes[d] = SideGeometry<NDIM>::toSideBox(f_data->getGhostBox(), d);
+        }
+        
+        
+        
+        Box<NDIM> side_boxes[NDIM];
+        for (int d = 0; d < NDIM; ++d)
+        {
+            side_boxes[d] = SideGeometry<NDIM>::toSideBox(patch_box, d);
+        }
+        
+        
+        const Pointer<CartesianPatchGeometry<NDIM> > patch_geom = patch->getPatchGeometry();
+        const double* const x_lower = patch_geom->getXLower();
+        const double* const dx = patch_geom->getDx();
+
+        std::array<std::map<hier::Index<NDIM>, std::vector<libMesh::Point>, IndexOrder>, NDIM> intersection_points,
+            intersection_ref_coords;
+        std::array<std::map<hier::Index<NDIM>, std::vector<VectorValue<double> >, IndexOrder>, NDIM>
+            intersection_normals;
+
+        std::array<std::map<hier::Index<NDIM>, std::vector<libMesh::Point>, IndexOrder>, NDIM> intersection_u_points,
+            intersection_u_ref_coords;
+        std::array<std::map<hier::Index<NDIM>, std::vector<VectorValue<double> >, IndexOrder>, NDIM>
+            intersection_u_normals;
+
+        std::array<std::array<std::map<hier::Index<NDIM>, std::vector<libMesh::Point>, IndexOrder>, NDIM>, NDIM>
+            intersectionSide_u_points, intersectionSide_u_ref_coords;
+        std::array<std::array<std::map<hier::Index<NDIM>, std::vector<VectorValue<double> >, IndexOrder>, NDIM>, NDIM>
+            intersectionSide_u_normals;
+
+        // Loop over the elements.
+        for (size_t e_idx = 0; e_idx < num_active_patch_elems; ++e_idx)
+        {
+            Elem* const elem = patch_elems[e_idx];
+            const auto& X_dof_indices = X_dof_map_cache.dof_indices(elem);
+            get_values_for_interpolation(x_node, X_ghost_vec, X_dof_indices);
+            if (d_use_pressure_jump_conditions)
+            {
+                const auto& P_jump_dof_indices = P_jump_dof_map_cache->dof_indices(elem);
+                get_values_for_interpolation(P_jump_node, P_jump_ghost_vec, P_jump_dof_indices[0]);
+            }
+            if (d_use_velocity_jump_conditions)
+            {
+                for (unsigned int axis = 0; axis < NDIM; ++axis)
+                {
+                    const auto& DU_jump_dof_indices = DU_jump_dof_map_cache[axis]->dof_indices(elem);
+                    get_values_for_interpolation(DU_jump_node[axis], *DU_jump_ghost_vec[axis], DU_jump_dof_indices);
+                }
+            }
+
+            // Cache the nodal and physical coordinates of the side element,
+            // determine the bounding box of the current configuration of the
+            // element, and set the nodal coordinates to correspond to the
+            // physical coordinates.
+            const unsigned int n_nodes = elem->n_nodes();
+            X_node_cache.resize(n_nodes);
+            x_node_cache.resize(n_nodes);
+            x_min = IBTK::Point::Constant(std::numeric_limits<double>::max());
+            x_max = IBTK::Point::Constant(-std::numeric_limits<double>::max());
+            for (unsigned int k = 0; k < n_nodes; ++k)
+            {
+                X_node_cache[k] = elem->point(k);
+                libMesh::Point& x = x_node_cache[k];
+                for (unsigned int d = 0; d < NDIM; ++d)
+                {
+                    x(d) = x_node[k][d];
+                }
+                if (d_perturb_fe_mesh_nodes)
+                {
+                    // Perturb the mesh configuration to keep the FE mesh nodes
+                    // away from cell edges, nodes, and centers.
+                    //
+                    // This implies that we only have to deal with multiple
+                    // intersections along element edges, and not at element
+                    // nodes.
+                    for (unsigned int d = 0; d < NDIM; ++d)
+                    {
+                        const int i_s = boost::math::iround(((x(d) - x_lower[d]) / dx[d]) - 0.5) + patch_lower[d];
+                        for (int shift = 0; shift <= 2; ++shift)
+                        {
+                            const double x_s =
+                                x_lower[d] + dx[d] * (static_cast<double>(i_s - patch_lower[d]) + 0.5 * shift);
+                            const double tol = 1.0e-4 * dx[d];
+                            if (x(d) <= x_s) x(d) = std::min(x_s - tol, x(d));
+                            if (x(d) >= x_s) x(d) = std::max(x_s + tol, x(d));
+                        }
+                    }
+                }
+                for (unsigned int d = 0; d < NDIM; ++d)
+                {
+                    x_min[d] = std::min(x_min[d], x(d));
+                    x_max[d] = std::max(x_max[d], x(d));
+                }
+                elem->point(k) = x;
+            }
+            Box<NDIM> box(IndexUtilities::getCellIndex(&x_min[0], grid_geom, ratio),
+                          IndexUtilities::getCellIndex(&x_max[0], grid_geom, ratio));
+            box.grow(IntVector<NDIM>(1));
             box = box * patch_box;
 
             // Loop over coordinate directions and look for intersections with
@@ -1644,8 +3503,16 @@ IBFESurfaceMethod::imposeJumpConditions(const int f_data_idx,
             {
                 Box<NDIM> extended_box = patch_box;
                 extended_box.grow(IntVector<NDIM>(1));
+                Box<NDIM> extended_side_box = patch_box;
+                extended_side_box.grow(IntVector<NDIM>(2));
                 if (patch_geom->getTouchesRegularBoundary(axis, 1)) extended_box.upper(axis) += 1;
 
+                Box<NDIM> side_u_boxes[NDIM];
+                for (int d = 0; d < NDIM; ++d)
+                {
+                    side_u_boxes[d] = SideGeometry<NDIM>::toSideBox(extended_side_box, d);
+                }
+
                 // Setup a unit vector pointing in the coordinate direction of
                 // interest.
                 VectorValue<double> q;
@@ -1655,111 +3522,401 @@ IBFESurfaceMethod::imposeJumpConditions(const int f_data_idx,
                 Box<NDIM> axis_box = box;
                 axis_box.lower(axis) = 0;
                 axis_box.upper(axis) = 0;
+
+                unsigned int SideDim[NDIM][NDIM - 1];
+                for (unsigned int d = 0; d < NDIM; ++d)
+                    for (unsigned int l = 0; l < NDIM - 1; ++l) SideDim[d][l] = (d + l + 1) % NDIM;
+
                 for (BoxIterator<NDIM> b(axis_box); b; b++)
                 {
                     const hier::Index<NDIM>& i_c = b();
                     libMesh::Point r;
+                    std::array<libMesh::Point, NDIM - 1> rs;
+
                     for (unsigned int d = 0; d < NDIM; ++d)
                     {
                         r(d) = (d == axis ? 0.0 :
                                             x_lower[d] + dx[d] * (static_cast<double>(i_c(d) - patch_lower[d]) + 0.5));
+
+                        for (unsigned int l = 0; l < NDIM - 1; ++l)
+                        {
+                            rs[l](d) =
+                                (d == axis ? 0.0 :
+                                             d == SideDim[axis][l] ?
+                                             x_lower[d] + dx[d] * (static_cast<double>(i_c(d) - patch_lower[d])) :
+                                             x_lower[d] + dx[d] * (static_cast<double>(i_c(d) - patch_lower[d]) + 0.5)); 
+                        }
                     }
+
                     std::vector<std::pair<double, libMesh::Point> > intersections;
-                    static const double tolerance = std::sqrt(std::numeric_limits<double>::epsilon());
+                    std::array<std::vector<std::pair<double, libMesh::Point> >, NDIM - 1> intersectionsSide;
+
+                    static const double tolerance = sqrt(std::numeric_limits<double>::epsilon());
+
 #if (NDIM == 2)
                     intersect_line_with_edge(intersections, static_cast<Edge*>(elem), r, q, tolerance);
 #endif
 #if (NDIM == 3)
                     intersect_line_with_face(intersections, static_cast<Face*>(elem), r, q, tolerance);
 #endif
-                    for (const auto& intersection : intersections)
+                    for (unsigned int l = 0; l < NDIM - 1; ++l)
+                    {
+#if (NDIM == 2)
+                        intersect_line_with_edge(intersectionsSide[l], static_cast<Edge*>(elem), rs[l], q, tolerance);
+#endif
+#if (NDIM == 3)
+                        intersect_line_with_face(intersectionsSide[l], static_cast<Face*>(elem), rs[l], q, tolerance);
+#endif
+                    }
+
+                    if (d_use_pressure_jump_conditions)
                     {
-                        const libMesh::Point x = r + intersection.first * q;
-                        const libMesh::Point& xi = intersection.second;
-                        SideIndex<NDIM> i_s(i_c, axis, 0);
-                        i_s(axis) = boost::math::iround((x(axis) - x_lower[axis]) / dx[axis]) + patch_lower[axis];
-                        if (extended_box.contains(i_s))
+                        for (unsigned int k = 0; k < intersections.size(); ++k)
                         {
-                            std::vector<libMesh::Point> ref_coords(1, xi);
-                            fe->reinit(elem, &ref_coords);
-                            for (unsigned int l = 0; l < NDIM - 1; ++l)
-                            {
-                                interpolate(dx_dxi[l], 0, x_node, *dphi_dxi[l]);
-                            }
-                            if (NDIM == 2)
+                            const libMesh::Point x = r + intersections[k].first * q;
+                            const libMesh::Point& xi = intersections[k].second;
+                            SideIndex<NDIM> i_s(i_c, axis, 0);
+                            i_s(axis) = boost::math::iround((x(axis) - x_lower[axis]) / dx[axis]) + patch_lower[axis];
+                            if (extended_box.contains(i_s))
                             {
-                                dx_dxi[1] = VectorValue<double>(0.0, 0.0, 1.0);
+                                std::vector<libMesh::Point> ref_coords(1, xi);
+                                fe_X->reinit(elem, &ref_coords);
+                                fe_P_jump->reinit(elem, &ref_coords);
+                                for (unsigned int l = 0; l < NDIM - 1; ++l)
+                                {
+                                    interpolate(dx_dxi[l], 0, x_node, *dphi_dxi[l]);
+                                }
+                                if (NDIM == 2)
+                                {
+                                    dx_dxi[1] = VectorValue<double>(0.0, 0.0, 1.0);
+                                }
+                                n = (dx_dxi[0].cross(dx_dxi[1])).unit();
+
+                                // Make sure we haven't already found this
+                                // intersection.
+                                //
+                                // (Because we are doing this in floating point
+                                // arithmetic, we can't even count on the
+                                // intersection being assigned to the same index!)
+                                bool found_same_intersection_point = false;
+                                for (int shift = -1; shift <= 1; ++shift)
+                                {
+                                    SideIndex<NDIM> i_s_prime = i_s;
+                                    i_s_prime(axis) += shift;
+                                    const std::vector<libMesh::Point>& candidate_coords =
+                                        intersection_points[axis][i_s_prime];
+                                    const std::vector<libMesh::Point>& candidate_ref_coords =
+                                        intersection_ref_coords[axis][i_s_prime];
+                                    const std::vector<VectorValue<double> >& candidate_normals =
+                                        intersection_normals[axis][i_s_prime];
+
+                                    checkDoubleCountingIntersection(axis,
+                                                                    dx,
+                                                                    n,
+                                                                    x,
+                                                                    xi,
+                                                                    i_s,
+                                                                    i_s_prime,
+                                                                    candidate_coords,
+                                                                    candidate_ref_coords,
+                                                                    candidate_normals,
+                                                                    found_same_intersection_point);
+                                    if (found_same_intersection_point) break;
+                                }
+
+                                if (!found_same_intersection_point)
+                                {
+                                    // Evaluate the jump conditions and apply them
+                                    // to the Eulerian grid.
+                                    if (side_ghost_boxes[axis].contains(i_s))
+                                    {
+                                        const double C_p = interpolate(0, P_jump_node, phi_P_jump);
+                                        const double sgn = n(axis) > 0.0 ? 1.0 : n(axis) < 0.0 ? -1.0 : 0.0;
+                                        (*f_data)(i_s) += sgn * (C_p / dx[axis]);
+                                    }
+
+                                    // Keep track of the positions where we have
+                                    // imposed jump conditions.
+                                    intersection_points[axis][i_s].push_back(x);
+                                    intersection_ref_coords[axis][i_s].push_back(xi);
+                                    intersection_normals[axis][i_s].push_back(n);
+                                }
                             }
-                            n = (dx_dxi[0].cross(dx_dxi[1])).unit();
-
-                            // Make sure we haven't already found this
-                            // intersection.
-                            //
-                            // (Because we are doing this in floating point
-                            // arithmetic, we can't even count on the
-                            // intersection being assigned to the same index!)
-                            bool found_same_intersection_point = false;
-                            for (int shift = -1; shift <= 1; ++shift)
+                        }
+                    }
+
+                    if (d_use_velocity_jump_conditions)
+                    {
+                        for (unsigned int k = 0; k < intersections.size(); ++k)
+                        {
+                            libMesh::Point xu = r + intersections[k].first * q;
+                            const libMesh::Point& xui = intersections[k].second;
+                            SideIndex<NDIM> i_s_um(i_c, axis, 0);
+                            Index<NDIM> i_c_neighbor = i_c;
+                            i_c_neighbor(axis) += 1;
+
+                            SideIndex<NDIM> i_s_up(i_c_neighbor, axis, 0);
+                            i_s_up(axis) = boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis] + 0.5) +
+                                           patch_lower[axis];
+                            i_s_um(axis) = boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis] - 0.5) + 
+										   patch_lower[axis];
+
+                            if (extended_box.contains(i_s_up) && extended_box.contains(i_s_um))
                             {
-                                SideIndex<NDIM> i_s_prime = i_s;
-                                i_s_prime(axis) += shift;
-                                const std::vector<libMesh::Point>& candidate_coords =
-                                    intersection_points[axis][i_s_prime];
-                                const std::vector<libMesh::Point>& candidate_ref_coords =
-                                    intersection_ref_coords[axis][i_s_prime];
-                                const std::vector<VectorValue<double> >& candidate_normals =
-                                    intersection_normals[axis][i_s_prime];
-                                auto x_prime_it = candidate_coords.begin();
-                                auto xi_prime_it = candidate_ref_coords.begin();
-                                auto n_prime_it = candidate_normals.begin();
-                                for (; x_prime_it != candidate_coords.end(); ++x_prime_it, ++xi_prime_it, ++n_prime_it)
+                                std::vector<libMesh::Point> ref_coords(1, xui);
+                                fe_X->reinit(elem, &ref_coords);
+                                fe_P_jump->reinit(elem, &ref_coords);
+                                for (unsigned int l = 0; l < NDIM - 1; ++l)
+                                {
+                                    interpolate(dx_dxi[l], 0, x_node, *dphi_dxi[l]);
+                                }
+                                if (NDIM == 2)
+                                {
+                                    dx_dxi[1] = VectorValue<double>(0.0, 0.0, 1.0);
+                                }
+                                n = (dx_dxi[0].cross(dx_dxi[1])).unit();
+
+                                bool found_same_intersection_point = false;
+
+                                for (int shift = -1; shift <= 1; ++shift)
                                 {
-                                    const libMesh::Point& x_prime = *x_prime_it;
-                                    const libMesh::Point& xi_prime = *xi_prime_it;
-                                    const libMesh::Point& n_prime = *n_prime_it;
-                                    if (x.absolute_fuzzy_equals(x_prime, 1.0e-5 * dx[axis]))
+                                    SideIndex<NDIM> i_s_prime = i_s_um;
+                                    i_s_prime(axis) += shift;
+                                    const std::vector<libMesh::Point>& candidate_coords =
+                                        intersection_u_points[axis][i_s_prime];
+                                    const std::vector<libMesh::Point>& candidate_ref_coords =
+                                        intersection_u_ref_coords[axis][i_s_prime];
+                                    const std::vector<VectorValue<double> >& candidate_normals =
+                                        intersection_u_normals[axis][i_s_prime];
+
+                                    checkDoubleCountingIntersection(axis,
+                                                                    dx,
+                                                                    n,
+                                                                    xu,
+                                                                    xui,
+                                                                    i_s_um,
+                                                                    i_s_prime,
+                                                                    candidate_coords,
+                                                                    candidate_ref_coords,
+                                                                    candidate_normals,
+                                                                    found_same_intersection_point);
+                                    if (found_same_intersection_point) break;
+                                }
+
+                                if (!found_same_intersection_point)
+                                {
+                                    // imposed jump conditions.
+
+                                    TBOX_ASSERT(i_s_um.getAxis() == i_s_up.getAxis());
+                                    TBOX_ASSERT(i_s_up(axis) - i_s_um(axis) == 1);
+                                    const double x_cell_bdry_um =
+                                        x_lower[axis] +
+                                        static_cast<double>(i_s_um(axis) - patch_lower[axis]) * dx[axis];
+
+                                    const double x_cell_bdry_up =
+                                        x_lower[axis] +
+                                        static_cast<double>(i_s_up(axis) - patch_lower[axis]) * dx[axis];
+                                    const double sdh_um = ((xu(axis) - x_cell_bdry_um)); // Signed Distance h
+
+                                    const double sdh_up = ((xu(axis) - x_cell_bdry_up)); // Signed Distance h
+                                    TBOX_ASSERT((sdh_um) < dx[axis] && sdh_um > 0);
+                                    TBOX_ASSERT(fabs(sdh_up) < dx[axis] && sdh_up < 0);
+                                    if (side_ghost_boxes[axis].contains(i_s_up) &&
+                                        side_ghost_boxes[axis].contains(i_s_um))
                                     {
-                                        // WARNING: This check is ONLY
-                                        // guaranteed to work at edges (where
-                                        // only two elements meet).  To avoid FE
-                                        // mesh nodes, set
-                                        // d_perturb_fe_mesh_nodes to true.
-                                        found_same_intersection_point = n(axis) * n_prime(axis) > 0.0;
-                                        if (d_do_log)
-                                        {
-                                            plog << "==========\n";
-                                            plog << "multiple intersections detected:\n";
-                                            plog << "  x    = " << x << "\n";
-                                            plog << "  x'   = " << x_prime << "\n";
-                                            plog << "  xi   = " << xi << "\n";
-                                            plog << "  xi'  = " << xi_prime << "\n";
-                                            plog << "  n    = " << n << "\n";
-                                            plog << "  n'   = " << n_prime << "\n";
-                                            plog << "  i_s  = " << i_s << "\n";
-                                            plog << "  i_s' = " << i_s_prime << "\n";
-                                            plog << "  axis = " << axis << "\n";
-                                        }
+                                        double C_u_um = 0;
+                                        double C_u_up = 0;
+
+                                        interpolate(&jn(0), 0, DU_jump_node[axis], phi_P_jump);
+                                        C_u_up = sdh_up * jn(axis);
+                                        C_u_um = sdh_um * jn(axis);
+
+                                        const double sgn = n(axis) > 0.0 ? 1.0 : n(axis) < 0.0 ? -1.0 : 0.0;
+                                        // Note that the corrections are applied to opposite sides
+                                        (*f_data)(i_s_up) -= sgn * (C_u_um / (dx[axis] * dx[axis]));
+                                        (*f_data)(i_s_um) += sgn * (C_u_up / (dx[axis] * dx[axis]));
                                     }
-                                    if (found_same_intersection_point) break;
+
+                                    // Keep track of the positions where we have
+                                    // imposed jump conditions.
+                                    intersection_u_points[axis][i_s_um].push_back(xu);
+                                    intersection_u_ref_coords[axis][i_s_um].push_back(xui);
+                                    intersection_u_normals[axis][i_s_um].push_back(n);
                                 }
-                                if (found_same_intersection_point) break;
                             }
-                            if (!found_same_intersection_point)
+
+                        }
+
+                        for (unsigned int j = 0; j < NDIM - 1; ++j)
+                        {
+                            for (unsigned int k = 0; k < intersectionsSide[j].size(); ++k)
                             {
-                                // Evaluate the jump conditions and apply them
-                                // to the Eulerian grid.
-                                if (side_ghost_boxes[axis].contains(i_s))
+                                libMesh::Point xu = rs[j] + intersectionsSide[j][k].first * q;
+                                const libMesh::Point& xui = intersectionsSide[j][k].second;
+                                SideIndex<NDIM> i_s_up;
+                                SideIndex<NDIM> i_s_um;
+
+                                if (xu(axis) - x_lower[axis] > 0.0)
+                                {
+                                    if (fmod(xu(axis) - x_lower[axis], dx[axis]) >= 0.5 * dx[axis])
+                                    {
+                                        SideIndex<NDIM> i_side_um(i_c, SideDim[axis][j], 0);
+                                        Index<NDIM> i_c_neighbor = i_c;
+                                        i_c_neighbor(axis) += 1;
+
+                                        SideIndex<NDIM> i_side_up(i_c_neighbor, SideDim[axis][j], 0);
+
+                                        i_side_up(axis) =
+                                            boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis]) +
+                                            patch_lower[axis];
+                                        i_side_um(axis) =
+                                            boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis] - 0.5) +
+                                            patch_lower[axis];
+                                        i_s_up = i_side_up;
+                                        i_s_um = i_side_um;
+                                    }
+                                    else if (fmod((xu(axis) - x_lower[axis]), dx[axis]) < 0.5 * dx[axis])
+                                    {
+                                        SideIndex<NDIM> i_side_up(i_c, SideDim[axis][j], 0);
+                                        Index<NDIM> i_c_neighbor = i_c;
+                                        i_c_neighbor(axis) -= 1;
+                                        SideIndex<NDIM> i_side_um(i_c_neighbor, SideDim[axis][j], 0);
+                                        i_side_up(axis) =
+                                            boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis] - 0.5) +
+                                            patch_lower[axis];
+                                        i_side_um(axis) =
+                                            boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis] - 1.0) +
+                                            patch_lower[axis];
+                                        i_s_up = i_side_up;
+                                        i_s_um = i_side_um;
+                                    }
+                                    else
+                                    {
+                                        continue;
+                                    }
+                                }
+                                else if (xu(axis) - x_lower[axis] < 0.0)
+                                {
+                                    if (fmod(fabs(xu(axis) - x_lower[axis]), dx[axis]) < 0.5 * dx[axis])
+                                    {
+                                        SideIndex<NDIM> i_side_um(i_c, SideDim[axis][j], 0);
+                                        Index<NDIM> i_c_neighbor = i_c;
+                                        i_c_neighbor(axis) += 1;
+
+                                        SideIndex<NDIM> i_side_up(i_c_neighbor, SideDim[axis][j], 0);
+
+                                        i_side_up(axis) =
+                                            boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis]) +
+                                            patch_lower[axis];
+                                        i_side_um(axis) =
+                                            boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis] - 0.5) +
+                                            patch_lower[axis];
+                                        i_s_up = i_side_up;
+                                        i_s_um = i_side_um;
+                                    }
+                                    else
+                                    {
+                                        SideIndex<NDIM> i_side_up(i_c, SideDim[axis][j], 0);
+                                        Index<NDIM> i_c_neighbor = i_c;
+                                        i_c_neighbor(axis) -= 1;
+                                        SideIndex<NDIM> i_side_um(i_c_neighbor, SideDim[axis][j], 0);
+                                        i_side_up(axis) =
+                                            boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis] -0.5) +
+                                            patch_lower[axis];
+                                        i_side_um(axis) =
+                                            boost::math::iround((xu(axis) - x_lower[axis]) / dx[axis] - 1.0) +
+                                            patch_lower[axis];
+                                        i_s_up = i_side_up;
+                                        i_s_um = i_side_um;
+                                    }
+                                }
+                                else
                                 {
-                                    const double C_p = interpolate(0, DP_node, phi);
-                                    const double sgn = n(axis) > 0.0 ? 1.0 : n(axis) < 0.0 ? -1.0 : 0.0;
-                                    (*f_data)(i_s) += sgn * (C_p / dx[axis]);
+                                    TBOX_ERROR(d_object_name << ":  Restart file version different than class version."
+                                                             << std::endl);
                                 }
 
-                                // Keep track of the positions where we have
-                                // imposed jump conditions.
-                                intersection_points[axis][i_s].push_back(x);
-                                intersection_ref_coords[axis][i_s].push_back(xi);
-                                intersection_normals[axis][i_s].push_back(n);
+                                if (extended_side_box.contains(i_s_up) && extended_side_box.contains(i_s_um))
+                                {
+                                    TBOX_ASSERT(i_s_up(axis) - i_s_um(axis) == 1);
+                                    std::vector<libMesh::Point> ref_coords(1, xui);
+                                    fe_X->reinit(elem, &ref_coords);
+                                    fe_P_jump->reinit(elem, &ref_coords);
+                                    for (unsigned int l = 0; l < NDIM - 1; ++l)
+                                    {
+                                        interpolate(dx_dxi[l], 0, x_node, *dphi_dxi[l]);
+                                    }
+                                    if (NDIM == 2)
+                                    {
+                                        dx_dxi[1] = VectorValue<double>(0.0, 0.0, 1.0);
+                                    }
+                                    n = (dx_dxi[0].cross(dx_dxi[1])).unit();
+
+                                    bool found_same_intersection_point = false;
+
+                                    for (int shift = -1; shift <= 1; ++shift)
+                                    {
+                                        SideIndex<NDIM> i_s_prime = i_s_um;
+                                        i_s_prime(SideDim[axis][j]) += shift;
+                                        const std::vector<libMesh::Point>& candidate_coords =
+                                            intersectionSide_u_points[j][axis][i_s_prime];
+                                        const std::vector<libMesh::Point>& candidate_ref_coords =
+                                            intersectionSide_u_ref_coords[j][axis][i_s_prime];
+                                        const std::vector<VectorValue<double> >& candidate_normals =
+                                            intersectionSide_u_normals[j][axis][i_s_prime];
+
+                                        checkDoubleCountingIntersection(axis,
+                                                                        dx,
+                                                                        n,
+                                                                        xu,
+                                                                        xui,
+                                                                        i_s_um,
+                                                                        i_s_prime,
+                                                                        candidate_coords,
+                                                                        candidate_ref_coords,
+                                                                        candidate_normals,
+                                                                        found_same_intersection_point);
+                                        if (found_same_intersection_point) break;
+                                    }
+
+                                    if (!found_same_intersection_point)
+                                    {
+                                        // Evaluate the jump conditions and apply them
+                                        // to the Eulerian grid.
+
+                                        const double x_mid_side_up =
+                                            x_lower[axis] +
+                                            static_cast<double>(i_s_up(axis) - patch_lower[axis] + 0.5) * dx[axis];
+
+                                        const double x_mid_side_um =
+                                            x_lower[axis] +
+                                            static_cast<double>(i_s_um(axis) - patch_lower[axis] + 0.5) * dx[axis];
+
+                                        TBOX_ASSERT(xu(axis) <= x_mid_side_up);
+                                        TBOX_ASSERT(xu(axis) > x_mid_side_um);
+
+                                        const double sdh_up = xu(axis) - x_mid_side_up; // Signed Distance h
+                                        const double sdh_um = xu(axis) - x_mid_side_um;
+                                        if (side_ghost_boxes[SideDim[axis][j]].contains(i_s_up) &&
+                                            side_ghost_boxes[SideDim[axis][j]].contains(i_s_um))
+                                        {
+                                            double C_u_um = 0;
+                                            double C_u_up = 0;
+
+                                            interpolate(&jn(0), 0, DU_jump_node[SideDim[axis][j]], phi_P_jump);
+                                            C_u_um = sdh_um * jn(axis);
+                                            C_u_up = sdh_up * jn(axis);
+
+                                            const double sgn = n(axis) > 0.0 ? 1.0 : n(axis) < 0.0 ? -1.0 : 0.0;
+
+                                            (*f_data)(i_s_um) += sgn * (C_u_up / (dx[axis] * dx[axis]));
+                                            (*f_data)(i_s_up) -= sgn * (C_u_um / (dx[axis] * dx[axis]));
+                                        }
+                                        intersectionSide_u_points[j][axis][i_s_um].push_back(xu);
+                                        intersectionSide_u_ref_coords[j][axis][i_s_um].push_back(xui);
+                                        intersectionSide_u_normals[j][axis][i_s_um].push_back(n);
+                                    }
+                                }
                             }
                         }
                     }
@@ -1767,15 +3924,66 @@ IBFESurfaceMethod::imposeJumpConditions(const int f_data_idx,
             }
 
             // Restore the element coordinates.
-            for (unsigned int k = 0; k < n_node; ++k)
+            for (unsigned int k = 0; k < n_nodes; ++k)
             {
                 elem->point(k) = X_node_cache[k];
             }
         }
     }
+
     return;
 } // imposeJumpConditions
 
+void
+IBFESurfaceMethod::checkDoubleCountingIntersection(int axis,
+                                                   const double* dx,
+                                                   libMesh::VectorValue<double> n,
+                                                   const libMesh::Point x,
+                                                   const libMesh::Point& xi,
+                                                   const SideIndex<NDIM> i_s,
+                                                   const SideIndex<NDIM> i_s_prime,
+                                                   const std::vector<libMesh::Point> candidate_coords,
+                                                   const std::vector<libMesh::Point> candidate_ref_coords,
+                                                   const std::vector<libMesh::VectorValue<double> > candidate_normals,
+                                                   bool found_same_intersection_point)
+{
+    std::vector<libMesh::Point>::const_iterator x_prime_it = candidate_coords.begin();
+    std::vector<libMesh::Point>::const_iterator xi_prime_it = candidate_ref_coords.begin();
+    std::vector<VectorValue<double> >::const_iterator n_prime_it = candidate_normals.begin();
+    for (; x_prime_it != candidate_coords.end(); ++x_prime_it, ++xi_prime_it, ++n_prime_it)
+    {
+        const libMesh::Point& x_prime = *x_prime_it;
+        const libMesh::Point& xi_prime = *xi_prime_it;
+        const libMesh::Point& n_prime = *n_prime_it;
+        // TODO: Do not use a hard-coded magic number?
+        if (x.absolute_fuzzy_equals(x_prime, 1.0e-5 * dx[axis]))
+        {
+            // WARNING: This check is ONLY
+            // guaranteed to work at edges (where
+            // only two elements meet).  To avoid FE
+            // mesh nodes, set
+            // d_perturb_fe_mesh_nodes to true.
+            found_same_intersection_point = n(axis) * n_prime(axis) > 0.0;
+            if (d_do_log)
+            {
+                plog << "==========\n";
+                plog << "multiple intersections detected:\n";
+                plog << "  x    = " << x << "\n";
+                plog << "  x'   = " << x_prime << "\n";
+                plog << "  xi   = " << xi << "\n";
+                plog << "  xi'  = " << xi_prime << "\n";
+                plog << "  n    = " << n << "\n";
+                plog << "  n'   = " << n_prime << "\n";
+                plog << "  i_s  = " << i_s << "\n";
+                plog << "  i_s' = " << i_s_prime << "\n";
+                plog << "  axis = " << axis << "\n";
+            }
+        }
+        if (found_same_intersection_point) break;
+    }
+    return;
+}
+
 void
 IBFESurfaceMethod::initializeCoordinates(const unsigned int part)
 {
@@ -1785,9 +3993,8 @@ IBFESurfaceMethod::initializeCoordinates(const unsigned int part)
     const unsigned int X_sys_num = X_system.number();
     NumericVector<double>& X_coords = *X_system.solution;
     const bool identity_mapping = !d_coordinate_mapping_fcn_data[part].fcn;
-    auto it = mesh.local_nodes_begin();
-    const auto end_it = mesh.local_nodes_end();
-    for (; it != end_it; ++it)
+
+    for (MeshBase::node_iterator it = mesh.local_nodes_begin(); it != mesh.local_nodes_end(); ++it)
     {
         Node* n = *it;
         if (n->n_vars(X_sys_num))
@@ -1808,8 +4015,8 @@ IBFESurfaceMethod::initializeCoordinates(const unsigned int part)
     }
     X_coords.close();
     X_system.get_dof_map().enforce_constraints_exactly(X_system, &X_coords);
-    X_coords.localize(*X_system.current_local_solution);
-    X_coords.localize(X_system.get_vector("INITIAL_COORDINATES"));
+    copy_and_synch(X_coords, *X_system.current_local_solution);
+    copy_and_synch(X_coords, X_system.get_vector("INITIAL_COORDINATES"));
     return;
 } // initializeCoordinates
 
@@ -1824,9 +4031,8 @@ IBFESurfaceMethod::updateCoordinateMapping(const unsigned int part)
     System& dX_system = equation_systems->get_system(COORD_MAPPING_SYSTEM_NAME);
     const unsigned int dX_sys_num = dX_system.number();
     NumericVector<double>& dX_coords = *dX_system.solution;
-    auto it = mesh.local_nodes_begin();
-    const auto end_it = mesh.local_nodes_end();
-    for (; it != end_it; ++it)
+
+    for (MeshBase::node_iterator it = mesh.local_nodes_begin(); it != mesh.local_nodes_end(); ++it)
     {
         Node* n = *it;
         if (n->n_vars(X_sys_num))
@@ -1842,8 +4048,7 @@ IBFESurfaceMethod::updateCoordinateMapping(const unsigned int part)
             }
         }
     }
-    dX_coords.close();
-    dX_coords.localize(*dX_system.current_local_solution);
+    copy_and_synch(dX_coords, *dX_system.current_local_solution);
     return;
 } // updateCoordinateMapping
 
@@ -1862,9 +4067,7 @@ IBFESurfaceMethod::initializeVelocity(const unsigned int part)
     }
     else
     {
-        auto it = mesh.local_nodes_begin();
-        const auto end_it = mesh.local_nodes_end();
-        for (; it != end_it; ++it)
+        for (MeshBase::node_iterator it = mesh.local_nodes_begin(); it != mesh.local_nodes_end(); ++it)
         {
             Node* n = *it;
             if (n->n_vars(U_sys_num))
@@ -1882,7 +4085,7 @@ IBFESurfaceMethod::initializeVelocity(const unsigned int part)
     }
     U_vec.close();
     U_system.get_dof_map().enforce_constraints_exactly(U_system, &U_vec);
-    U_vec.localize(*U_system.current_local_solution);
+    copy_and_synch(U_vec, *U_system.current_local_solution);
     return;
 } // initializeVelocity
 
@@ -2076,11 +4279,30 @@ IBFESurfaceMethod::getFromInput(Pointer<Database> db, bool /*is_from_restart*/)
         d_default_spread_spec.use_nodal_quadrature = db->getBool("IB_use_nodal_quadrature");
 
     // Force computation settings.
-    if (db->isBool("use_jump_conditions")) d_use_jump_conditions = db->getBool("use_jump_conditions");
-    if (d_use_jump_conditions)
+    if (db->isBool("use_pressure_jump_conditions"))
     {
-        if (db->isBool("perturb_fe_mesh_nodes")) d_perturb_fe_mesh_nodes = db->getBool("perturb_fe_mesh_nodes");
+        d_use_pressure_jump_conditions = db->getBool("use_pressure_jump_conditions");
         if (db->isBool("normalize_pressure_jump")) d_normalize_pressure_jump = db->getBool("normalize_pressure_jump");
+	}
+
+    if (db->isBool("use_l2_lagrange_family")) d_use_l2_lagrange_family = db->getBool("use_l2_lagrange_family");
+
+    if (db->isBool("use_velocity_jump_conditions"))
+    {
+        d_use_velocity_jump_conditions = db->getBool("use_velocity_jump_conditions");
+        if (db->isDouble("wss_calc_width")) d_wss_calc_width = db->getDouble("wss_calc_width");
+	}
+    if (d_use_pressure_jump_conditions || d_use_velocity_jump_conditions)
+    {
+        if (db->isBool("perturb_fe_mesh_nodes")) d_perturb_fe_mesh_nodes = db->getBool("perturb_fe_mesh_nodes");
+    }
+    if (db->isBool("compute_fluid_traction"))
+    {
+		d_compute_fluid_traction = db->getBool("compute_fluid_traction");
+        if (db->isDouble("p_calc_width")) d_p_calc_width = db->getDouble("p_calc_width");
+        if (db->isDouble("traction_activation_time"))
+            d_traction_activation_time = db->getDouble("traction_activation_time");
+        if (db->isBool("traction_interior_side")) d_traction_interior_side = db->getBool("traction_interior_side");
     }
     if (db->isBool("use_consistent_mass_matrix"))
         d_use_consistent_mass_matrix = db->getBool("use_consistent_mass_matrix");
@@ -2132,7 +4354,12 @@ IBFESurfaceMethod::getFromRestart()
         TBOX_ERROR(d_object_name << ":  Restart file version different than class version." << std::endl);
     }
     db->getIntegerArray("d_ghosts", d_ghosts, NDIM);
-    d_use_jump_conditions = db->getBool("d_use_jump_conditions");
+    d_use_l2_lagrange_family = db->getBool("d_use_l2_lagrange_family");
+    d_use_pressure_jump_conditions = db->getBool("d_use_pressure_jump_conditions");
+    d_use_velocity_jump_conditions = db->getBool("d_use_velocity_jump_conditions");
+    d_compute_fluid_traction = db->getBool("d_compute_fluid_traction");
+    d_traction_interior_side = db->getBool("d_d_traction_interior_side");
+    d_traction_activation_time = db->getDouble("d_traction_activation_time");
     d_use_consistent_mass_matrix = db->getBool("d_use_consistent_mass_matrix");
     d_use_direct_forcing = db->getBool("d_use_direct_forcing");
     return;
diff --git a/tests/IBFE/explicit_ex5_2d.mpirun=2.input b/tests/IBFE/explicit_ex5_2d.mpirun=2.input
index 196986b4b..133de311e 100644
--- a/tests/IBFE/explicit_ex5_2d.mpirun=2.input
+++ b/tests/IBFE/explicit_ex5_2d.mpirun=2.input
@@ -2,6 +2,7 @@
 Re = 200.0
 MU = 1.0/Re
 RHO = 1.0
+R = 0.5        								   // radius of the cylinder
 
 // grid spacing parameters
 L = 16.0                                       // width of computational domain
@@ -229,8 +230,8 @@ LoadBalancer {
 
 TimerManager{
    print_exclusive = FALSE
-   print_total = TRUE
+   print_total 	   = TRUE
    print_threshold = 0.1
 
-   timer_list = "IBAMR::*::*","IBTK::*::*","*::*::*"
+   timer_list      = "IBAMR::*::*","IBTK::*::*","*::*::*"
 }
diff --git a/tests/IBFE/explicit_ex5_2d.restart=40.mpirun=2.input b/tests/IBFE/explicit_ex5_2d.restart=40.mpirun=2.input
index 7a52f9a46..ea69357f0 100644
--- a/tests/IBFE/explicit_ex5_2d.restart=40.mpirun=2.input
+++ b/tests/IBFE/explicit_ex5_2d.restart=40.mpirun=2.input
@@ -2,6 +2,7 @@
 Re = 200.0
 MU = 1.0/Re
 RHO = 1.0
+R = 0.5        								   // radius of the cylinder
 
 // grid spacing parameters
 L = 16.0                                       // width of computational domain
@@ -229,8 +230,8 @@ LoadBalancer {
 
 TimerManager{
    print_exclusive = FALSE
-   print_total = TRUE
+   print_total 	   = TRUE
    print_threshold = 0.1
 
-   timer_list = "IBAMR::*::*","IBTK::*::*","*::*::*"
+   timer_list      = "IBAMR::*::*","IBTK::*::*","*::*::*"
 }
diff --git a/tests/IBFE/explicit_ex5_3d.mpirun=2.input b/tests/IBFE/explicit_ex5_3d.mpirun=2.input
index 096cafcbf..767fd85e4 100644
--- a/tests/IBFE/explicit_ex5_3d.mpirun=2.input
+++ b/tests/IBFE/explicit_ex5_3d.mpirun=2.input
@@ -2,7 +2,7 @@
 Re = 400.0
 MU = 1.0/Re
 RHO = 1.0
-
+R = 0.5        											// radius of the cylinder
 // grid spacing parameters
 L = 16.0                                       // width of computational domain
 MAX_LEVELS = 3                                 // maximum number of levels in locally refined grid
