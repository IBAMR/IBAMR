// ---------------------------------------------------------------------
//
// Copyright (c) 2016 - 2019 by the IBAMR developers
// All rights reserved.
//
// This file is part of IBAMR.
//
// IBAMR is free software and is distributed under the 3-clause BSD
// license. The full text of the license can be found in the file
// COPYRIGHT at the top level directory of IBAMR.
//
// ---------------------------------------------------------------------

/////////////////////////////// INCLUDES /////////////////////////////////////

#include "ibamr/IBPDForceGen.h"
#include "ibamr/IBSpringForceSpec.h"
#include "ibamr/IBTargetPointForceSpec.h"
#include "ibamr/namespaces.h" // IWYU pragma: keep

#include "ibtk/IBTK_CHKERRQ.h"
#include "ibtk/LData.h"
#include "ibtk/LDataManager.h"
#include "ibtk/LMesh.h"
#include "ibtk/LNode.h"
#include "ibtk/compiler_hints.h"
#include "ibtk/ibtk_utilities.h"

#include "IntVector.h"
#include "PatchHierarchy.h"
#include "PatchLevel.h"
#include "tbox/Pointer.h"
#include "tbox/Utilities.h"

#include "petscsys.h"
#include "petscvec.h"

#include "boost/multi_array.hpp"

#include <math.h>
#include <stddef.h>

#include <algorithm>
#include <functional>
#include <iterator>
#include <limits>
#include <map>
#include <ostream>
#include <set>
#include <utility>

/////////////////////////////// NAMESPACE ////////////////////////////////////

namespace IBAMR
{
/////////////////////////////// STATIC ///////////////////////////////////////

namespace
{
void
resetLocalPETScIndices(std::vector<int>& inds, const int global_node_offset, const int num_local_nodes)
{
#if defined(NDEBUG)
    NULL_USE(num_local_nodes);
#endif
    for (std::vector<int>::iterator it = inds.begin(); it != inds.end(); ++it)
    {
        int& idx = *it;
#if !defined(NDEBUG)
        TBOX_ASSERT(idx >= global_node_offset && idx < global_node_offset + num_local_nodes);
#endif
        idx -= global_node_offset;
    }
    return;
} // resetLocalPETScIndices

void
resetLocalOrNonlocalPETScIndices(std::vector<int>& inds,
                                 const int global_node_offset,
                                 const int num_local_nodes,
                                 const std::vector<int>& nonlocal_petsc_idxs)
{
    for (auto& idx : inds)
    {
        if (idx >= global_node_offset && idx < global_node_offset + num_local_nodes)
        {
            // A local node.
            idx -= global_node_offset;
        }
        else
        {
            // A nonlocal node.
            //
            // First, lookup the slave node index in the set of ghost nodes.
            const std::vector<int>::const_iterator posn =
                std::lower_bound(nonlocal_petsc_idxs.begin(), nonlocal_petsc_idxs.end(), idx);
#if !defined(NDEBUG)
            TBOX_ASSERT(idx == *posn);
#endif
            // Second, set the local index via the offset of the ghost node
            // index within the set of ghost nodes.
            const auto offset = static_cast<int>(std::distance(nonlocal_petsc_idxs.begin(), posn));
            idx = num_local_nodes + offset;
        }
    }
    return;
} // resetLocalOrNonlocalPETScIndices

double
default_inf_fcn(double R0, double delta)
{
#if (NDIM == 2)
    static const double A = 2.0;
    static const double C = 60.0 / (7.0 * M_PI * A * A);
#elif (NDIM == 3)
    static const double A = 2.0;
    static const double C = 24.0 / (2.0 * M_PI * A * A * A);
#endif

    double W;

    double r = R0 / delta;
    if (r < 1.0)
    {
        W = C * (2.0 / 3.0 - r * r + 0.5 * r * r * r);
    }
    else if (r <= 2.0)
    {
        W = C * std::pow((2.0 - r), 3) / 6.0;
    }
    else
    {
        W = 0.0;
    }

    return W;

} // default_inf_fcn

double
default_vol_frac_fcn(double R0, double horizon, double delta)
{
    double vol_frac;
    if (R0 <= (horizon - delta))
    {
        vol_frac = 1.0;
    }
    else if (R0 <= (horizon + delta))
    {
        vol_frac = (horizon + delta - R0) / (2.0 * delta);
    }
    else
    {
        vol_frac = 0.0;
    }

    return vol_frac;

} // default_vol_frac_fcn

void
default_PK1_fcn(Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor>& PK1,
                const Eigen::Map<const Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> >& FF,
                const Eigen::Map<const IBTK::Vector>& /*X0*/,
                int /*lag_idx*/)
{
    using mat_type = Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor>;
    static const mat_type II = mat_type::Identity();
    mat_type E = 0.5 * (FF.transpose() * FF - II);
    const double trE = E.trace();
    PK1 = IBPDForceGen::s_lame_0 * trE * FF + 2.0 * IBPDForceGen::s_lame_1 * FF * E;

    return;

} // default_PK1_fcn

Eigen::Vector4d
default_force_damage_fcn(const double /*horizon*/,
                         const double /*delta*/,
                         const double W,
                         const double vol_frac,
                         double* parameters,
                         const Eigen::Map<const IBTK::Vector>& X0_mastr,
                         const Eigen::Map<const IBTK::Vector>& X0_slave,
                         const Eigen::Map<const IBTK::Vector>& X_mastr,
                         const Eigen::Map<const IBTK::Vector>& X_slave,
                         const Eigen::Map<const Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> >& FF_mastr,
                         const Eigen::Map<const Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> >& FF_slave,
                         const Eigen::Map<const Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> >& B_mastr,
                         const Eigen::Map<const Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> >& B_slave,
                         Eigen::Map<IBTK::Vector>& F_mastr,
                         Eigen::Map<IBTK::Vector>& F_slave,
                         const int lag_mastr_node_idx,
                         const int lag_slave_node_idx)
{
    // Bond parameters
    // 0 --> Kappa, 1 --> R0, 2--> user defined
    const double& R0 = parameters[1];
    const double& vol_mastr = parameters[2];
    const double& vol_slave = parameters[3];
    double& fail = parameters[4];
    const double& critical_stretch = parameters[5];

    // Estimate failure.
    const double R = (X_slave - X_mastr).norm();
    const double stretch = (R - R0) / R0;
    if (MathUtilities<double>::equalEps(fail, 1.0) && std::fabs(stretch) > critical_stretch)
    {
        fail = 0.0;
    }

    // PK1 stress tensor
    using vec_type = IBTK::Vector;
    using mat_type = Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor>;
    mat_type PK1_mastr, PK1_slave;
    default_PK1_fcn(PK1_mastr, FF_mastr, X0_mastr, lag_mastr_node_idx);
    default_PK1_fcn(PK1_slave, FF_slave, X0_slave, lag_slave_node_idx);

    // Compute PD force.
    vec_type trac = W * (PK1_mastr * B_mastr + PK1_slave * B_slave) * (X0_slave - X0_mastr);
    F_mastr += fail * (vol_frac * vol_slave) * trac * (vol_frac * vol_slave);
    F_slave += -fail * (vol_frac * vol_mastr) * trac * (vol_frac * vol_mastr);

    // Compute damage.
    Eigen::Vector4d D;
    D(0) = vol_slave * vol_frac * fail;
    D(1) = vol_slave * vol_frac;
    D(2) = vol_mastr * vol_frac * fail;
    D(3) = vol_mastr * vol_frac;

    return D;

} // default_force_damage_fcn

void
default_target_point_force_fcn(const Eigen::Map<const IBTK::Vector>& X,
                               const Eigen::Map<const IBTK::Vector>& X_target,
                               const Eigen::Map<const IBTK::Vector>& U,
                               double K,
                               double E,
                               int /*lag_idx*/,
                               Eigen::Map<IBTK::Vector>& F)
{
    F += K * (X_target - X) - E * U;

    return;
} // default_target_point_force_fcn
} // namespace

double IBPDForceGen::s_lame_0 = 1.0;
double IBPDForceGen::s_lame_1 = 1.0;

/////////////////////////////// PUBLIC ///////////////////////////////////////

IBPDForceGen::IBPDForceGen(Pointer<Database> input_db)
{
    // Get values from input database.
    if (input_db)
    {
        if (input_db->keyExists("horizon"))
        {
            d_horizon = input_db->getDouble("horizon");
        }

        if (input_db->keyExists("ds"))
        {
            d_ds = input_db->getDouble("ds");
        }

    }
    registerBondForceSpecificationFunction(
        0, &default_PK1_fcn, &default_force_damage_fcn, &default_inf_fcn, &default_vol_frac_fcn);
    registerTargetPointForceFunction(&default_target_point_force_fcn);

    return;
} // IBPDForceGen

void
IBPDForceGen::registerBondForceSpecificationFunction(int force_fcn_index,
                                                     const BondPK1FcnPtr bond_PK1_fcn_ptr,
                                                     const BondForceDamageFcnPtr bond_force_damage_fcn_ptr,
                                                     const BondInfluenceFcnPtr bond_inf_fcn_ptr,
                                                     const BondVolFracFcnPtr bond_vol_frac_fcn_ptr)
{
    d_bond_PK1_fcn_map[force_fcn_index] = bond_PK1_fcn_ptr;
    d_bond_force_damage_fcn_map[force_fcn_index] = bond_force_damage_fcn_ptr;
    d_bond_inf_fcn_map[force_fcn_index] = bond_inf_fcn_ptr;
    d_bond_vol_frac_fcn_map[force_fcn_index] = bond_vol_frac_fcn_ptr;

    return;

} // registerBondForceSpecificationFunction

void
IBPDForceGen::registerTargetPointForceFunction(const TargetPointForceFcnPtr target_point_force_fcn_ptr)
{
    d_target_point_force_fcn = target_point_force_fcn_ptr;
    return;

} // registerTargetPointForceFunction

void
IBPDForceGen::initializeLevelData(const Pointer<PatchHierarchy<NDIM> > hierarchy,
                                  const int level_number,
                                  const double init_data_time,
                                  const bool initial_time,
                                  LDataManager* const l_data_manager)
{
    if (!l_data_manager->levelContainsLagrangianData(level_number)) return;
    plog << "IBPDForceGen::initializeLevelData(): initializing IBPDForceGen level data." << std::endl;

#if !defined(NDEBUG)
    TBOX_ASSERT(hierarchy);
#endif
    Pointer<PatchLevel<NDIM> > level = hierarchy->getPatchLevel(level_number);

    // Resize the vectors corresponding to data individually maintained for
    // separate levels of the patch hierarchy.
    const int new_size = std::max(level_number + 1, static_cast<int>(d_is_initialized.size()));

    d_bond_data.resize(new_size);
    d_target_point_data.resize(new_size);
    d_X0_ghost_data.resize(new_size, Pointer<LData>(nullptr));
    d_X_ghost_data.resize(new_size, Pointer<LData>(nullptr));
    d_F_ghost_data.resize(new_size, Pointer<LData>(nullptr));
    d_dmg_ghost_data.resize(new_size, Pointer<LData>(nullptr));
    d_B_ghost_data.resize(new_size, Pointer<LData>(nullptr));
    d_FF_ghost_data.resize(new_size, Pointer<LData>(nullptr));
    d_dX_data.resize(new_size, Pointer<LData>(nullptr));
    d_is_initialized.resize(new_size, false);

    // Keep track of all of the nonlocal PETSc indices required to compute the
    // forces.
    std::set<int> nonlocal_petsc_idx_set;

    // Setup the cached data.
    initializeBondLevelData(
        nonlocal_petsc_idx_set, hierarchy, level_number, init_data_time, initial_time, l_data_manager);
    initializeTargetPointLevelData(
        nonlocal_petsc_idx_set, hierarchy, level_number, init_data_time, initial_time, l_data_manager);

    // Put the nonlocal PETSc indices into a vector.
    std::vector<int> nonlocal_petsc_idxs(nonlocal_petsc_idx_set.begin(), nonlocal_petsc_idx_set.end());

    // Put all cached PETSc node indices into local form.
    const int global_node_offset = l_data_manager->getGlobalNodeOffset(level_number);
    const int num_local_nodes = l_data_manager->getNumberOfLocalNodes(level_number);
    resetLocalPETScIndices(d_bond_data[level_number].petsc_mastr_node_idxs, global_node_offset, num_local_nodes);
    resetLocalOrNonlocalPETScIndices(
        d_bond_data[level_number].petsc_slave_node_idxs, global_node_offset, num_local_nodes, nonlocal_petsc_idxs);
    resetLocalPETScIndices(d_target_point_data[level_number].petsc_node_idxs, global_node_offset, num_local_nodes);

    std::ostringstream X0_name_stream;
    X0_name_stream << "IBPDForceGen::X0_ghost_" << level_number;
    d_X0_ghost_data[level_number] = new LData(X0_name_stream.str(), num_local_nodes, NDIM, nonlocal_petsc_idxs);

    std::ostringstream X_name_stream;
    X_name_stream << "IBPDForceGen::X_ghost_" << level_number;
    d_X_ghost_data[level_number] = new LData(X_name_stream.str(), num_local_nodes, NDIM, nonlocal_petsc_idxs);

    std::ostringstream F_name_stream;
    F_name_stream << "IBPDForceGen::F_ghost_" << level_number;
    d_F_ghost_data[level_number] = new LData(F_name_stream.str(), num_local_nodes, NDIM, nonlocal_petsc_idxs);

    std::ostringstream dmg_name_stream;
    dmg_name_stream << "IBPDForceGen::dmg_ghost_" << level_number;
    d_dmg_ghost_data[level_number] = new LData(dmg_name_stream.str(), num_local_nodes, 2, nonlocal_petsc_idxs);

    std::ostringstream B_name_stream;
    B_name_stream << "IBPDForceGen::B_ghost_" << level_number;
    d_B_ghost_data[level_number] = new LData(B_name_stream.str(), num_local_nodes, NDIM * NDIM, nonlocal_petsc_idxs);

    std::ostringstream FF_name_stream;
    FF_name_stream << "IBPDForceGen::FF_ghost_" << level_number;
    d_FF_ghost_data[level_number] = new LData(FF_name_stream.str(), num_local_nodes, NDIM * NDIM, nonlocal_petsc_idxs);

    std::ostringstream dX_name_stream;
    dX_name_stream << "IBPDForceGen::dX_" << level_number;
    d_dX_data[level_number] = new LData(dX_name_stream.str(), num_local_nodes, NDIM);

    // Compute periodic displacements.
    boost::multi_array_ref<double, 2>& dX_array = *d_dX_data[level_number]->getLocalFormVecArray();
    const Pointer<LMesh> mesh = l_data_manager->getLMesh(level_number);
    const std::vector<LNode*>& local_nodes = mesh->getLocalNodes();
    for (int k = 0; k < num_local_nodes; ++k)
    {
        const LNode* const node = local_nodes[k];
        const Vector& periodic_displacement = node->getPeriodicDisplacement();
        for (unsigned int d = 0; d < NDIM; ++d)
        {
            dX_array[k][d] = periodic_displacement[d];
        }
    }
    d_dX_data[level_number]->restoreArrays();

    // Indicate that the level data has been initialized and we need to compute shape tensor.
    d_is_initialized[level_number] = true;

    return;
} // initializeLevelData

void
IBPDForceGen::computeLagrangianForceAndDamage(Pointer<LData> F_data,
                                              Pointer<LData> D_data,
                                              Pointer<LData> X_data,
                                              Pointer<LData> U_data,
                                              const Pointer<PatchHierarchy<NDIM> > hierarchy,
                                              const int level_number,
                                              const double data_time,
                                              LDataManager* const l_data_manager)
{
    if (!l_data_manager->levelContainsLagrangianData(level_number)) return;
    const Pointer<LMesh> mesh = l_data_manager->getLMesh(level_number);
    const std::vector<LNode*>& local_nodes = mesh->getLocalNodes();
    int ierr;

    // Initialize various ghost data.
    Pointer<LData> F_ghost_data = d_F_ghost_data[level_number];
    Vec F_ghost_local_form_vec;
    ierr = VecGhostGetLocalForm(F_ghost_data->getVec(), &F_ghost_local_form_vec);
    IBTK_CHKERRQ(ierr);
    ierr = VecSet(F_ghost_local_form_vec, 0.0);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostRestoreLocalForm(F_ghost_data->getVec(), &F_ghost_local_form_vec);
    IBTK_CHKERRQ(ierr);

    Pointer<LData> D_ghost_data = d_dmg_ghost_data[level_number];
    Vec D_ghost_local_form_vec;
    ierr = VecGhostGetLocalForm(D_ghost_data->getVec(), &D_ghost_local_form_vec);
    IBTK_CHKERRQ(ierr);
    ierr = VecSet(D_ghost_local_form_vec, 0.0);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostRestoreLocalForm(D_ghost_data->getVec(), &D_ghost_local_form_vec);
    IBTK_CHKERRQ(ierr);

    Pointer<LData> X_ghost_data = d_X_ghost_data[level_number];
    Pointer<LData> dX_data = d_dX_data[level_number];
    ierr = VecAXPBYPCZ(X_ghost_data->getVec(), 1.0, 1.0, 0.0, X_data->getVec(), dX_data->getVec());
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostUpdateBegin(X_ghost_data->getVec(), INSERT_VALUES, SCATTER_FORWARD);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostUpdateEnd(X_ghost_data->getVec(), INSERT_VALUES, SCATTER_FORWARD);
    IBTK_CHKERRQ(ierr);

    Pointer<LData> X0_ghost_data = d_X0_ghost_data[level_number];
    Pointer<LData> X0 = l_data_manager->getLData("X0_unshifted", level_number);
    ierr = VecCopy(X0->getVec(), X0_ghost_data->getVec());
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostUpdateBegin(X0_ghost_data->getVec(), INSERT_VALUES, SCATTER_FORWARD);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostUpdateEnd(X0_ghost_data->getVec(), INSERT_VALUES, SCATTER_FORWARD);
    IBTK_CHKERRQ(ierr);

    Pointer<LData> B_ghost_data = d_B_ghost_data[level_number];
    Vec B_ghost_local_form_vec;
    ierr = VecGhostGetLocalForm(B_ghost_data->getVec(), &B_ghost_local_form_vec);
    IBTK_CHKERRQ(ierr);
    ierr = VecSet(B_ghost_local_form_vec, 0.0);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostRestoreLocalForm(B_ghost_data->getVec(), &B_ghost_local_form_vec);
    IBTK_CHKERRQ(ierr);

    Pointer<LData> FF_ghost_data = d_FF_ghost_data[level_number];
    Vec FF_ghost_local_form_vec;
    ierr = VecGhostGetLocalForm(FF_ghost_data->getVec(), &FF_ghost_local_form_vec);
    IBTK_CHKERRQ(ierr);
    ierr = VecSet(FF_ghost_local_form_vec, 0.0);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostRestoreLocalForm(FF_ghost_data->getVec(), &FF_ghost_local_form_vec);
    IBTK_CHKERRQ(ierr);

    // Compute shape tensor.
    computeShapeTensor(B_ghost_data, X0_ghost_data, hierarchy, level_number, data_time, l_data_manager);
    ierr = VecGhostUpdateBegin(B_ghost_data->getVec(), ADD_VALUES, SCATTER_REVERSE);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostUpdateEnd(B_ghost_data->getVec(), ADD_VALUES, SCATTER_REVERSE);
    IBTK_CHKERRQ(ierr);

    boost::multi_array_ref<double, 2>& B_ghost_data_array = *B_ghost_data->getLocalFormVecArray();
    for (const auto& node : local_nodes)
    {
        const int lag_idx = node->getLagrangianIndex();
        const int local_idx = node->getLocalPETScIndex();
        double* B = &B_ghost_data_array[local_idx][0];
        Eigen::Map<Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_B(B);

        // Scale the matrix.
        const double scale = eig_B.norm();
        if (!MathUtilities<double>::equalEps(scale, 0.0))
        {
            eig_B *= (1.0 / scale);
        }

        // Invert the scaled matrix.
        #if (NDIM == 3)
        // eig_B << eig_B(0),eig_B(1),eig_B(2),eig_B(3),eig_B(4),eig_B(5),eig_B(6),eig_B(7),1.0;
        bool invertible;
        eig_B.computeInverseWithCheck(eig_B, invertible);
        if (!invertible)
        {
            TBOX_WARNING("IBPDForceGen::computeLagrangianForceAndDamage() : Matrix inversion failed.\n"
                         << " Lagrangian index = " << lag_idx << "\nScaled B tensor is \n"
                         << eig_B << "\n"
                         << " Scaling factor  = " << scale << "\n"
                         << "Setting inverse of B tensor to zero"
                         << "\n");
            eig_B.setZero();
        }
        #endif
        #if (NDIM == 2)
        // bool invertible;
        Eigen::Matrix<double, NDIM+1, NDIM+1, Eigen::RowMajor> B0;
        Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> B0_inv;
        B0 << eig_B(0),eig_B(1),0.0,eig_B(2),eig_B(3),0.0,0.0,0.0,1.0;
        // B0.computeInverseWithCheck(B0_inv, invertible);
        B0_inv << eig_B(3), -eig_B(1), - eig_B(2), eig_B(0);
        double det_B0 = eig_B(0)*eig_B(3) - eig_B(1)*eig_B(2);
        eig_B << B0_inv(0)/det_B0, B0_inv(1)/det_B0, B0_inv(2)/det_B0, B0_inv(3)/det_B0;
        // if (!invertible)
        // {
        //     TBOX_WARNING("IBPDForceGen::computeLagrangianForceAndDamage() : Matrix inversion failed.\n"
        //                  << " Lagrangian index = " << lag_idx << "\nScaled B tensor is \n"
        //                  << eig_B << "\n"
        //                  << " Scaling factor  = " << scale << "\n"
        //                  << "Setting inverse of B tensor to zero"
        //                  << "\n");
        //     eig_B.setZero();
        // }
        #endif

        // Scale back the inverse-matrix.
        if (!MathUtilities<double>::equalEps(scale, 0.0))
        {
            eig_B *= (1.0 / scale);
        }
    }

    ierr = VecGhostUpdateBegin(B_ghost_data->getVec(), INSERT_VALUES, SCATTER_FORWARD);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostUpdateEnd(B_ghost_data->getVec(), INSERT_VALUES, SCATTER_FORWARD);
    IBTK_CHKERRQ(ierr);
    B_ghost_data->restoreArrays();

    // Compute the deformation gradient tensor.
    // FF = int_k {Y outer X}_k . Inv{B}
    computeDeformationGradientTensor(
        FF_ghost_data, X_ghost_data, X0_ghost_data, hierarchy, level_number, data_time, l_data_manager);
    ierr = VecGhostUpdateBegin(FF_ghost_data->getVec(), ADD_VALUES, SCATTER_REVERSE);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostUpdateEnd(FF_ghost_data->getVec(), ADD_VALUES, SCATTER_REVERSE);
    IBTK_CHKERRQ(ierr);

    {
        boost::multi_array_ref<double, 2>& FF_ghost_data_array = *FF_ghost_data->getLocalFormVecArray();
        boost::multi_array_ref<double, 2>& B_ghost_data_array = *B_ghost_data->getLocalFormVecArray();
        for (const auto& node : local_nodes)
        {
            const int local_idx = node->getLocalPETScIndex();
            double* B = &B_ghost_data_array[local_idx][0];
            double* FF = &FF_ghost_data_array[local_idx][0];
            Eigen::Map<Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_B(B);
            Eigen::Map<Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_FF(FF);
            // #if (NDIM == 3)
            // eig_B << eig_B(0),eig_B(1),eig_B(2),eig_B(3),eig_B(4),eig_B(5),eig_B(6),eig_B(7),1.0;
            // #endif
            // #if (NDIM == 3)
            // eig_FF << eig_FF(0),eig_FF(1),eig_FF(2),eig_FF(3),eig_FF(4),eig_FF(5),eig_FF(6),eig_FF(7),1.0;
            // #endif
            
            eig_FF = eig_FF * eig_B;

        }
        ierr = VecGhostUpdateBegin(FF_ghost_data->getVec(), INSERT_VALUES, SCATTER_FORWARD);
        IBTK_CHKERRQ(ierr);
        ierr = VecGhostUpdateEnd(FF_ghost_data->getVec(), INSERT_VALUES, SCATTER_FORWARD);
        IBTK_CHKERRQ(ierr);
        FF_ghost_data->restoreArrays();
        B_ghost_data->restoreArrays();
    }

    // Compute the forces and damage functions.
    computeLagrangianBondForceAndDamage(F_ghost_data,
                                        D_ghost_data,
                                        X_ghost_data,
                                        X0_ghost_data,
                                        FF_ghost_data,
                                        B_ghost_data,
                                        hierarchy,
                                        level_number,
                                        data_time,
                                        l_data_manager);
    computeLagrangianTargetPointForce(
        F_ghost_data, X_ghost_data, X0_ghost_data, U_data, hierarchy, level_number, data_time, l_data_manager);
    ierr = VecGhostUpdateBegin(F_ghost_data->getVec(), ADD_VALUES, SCATTER_REVERSE);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostUpdateEnd(F_ghost_data->getVec(), ADD_VALUES, SCATTER_REVERSE);
    IBTK_CHKERRQ(ierr);
    ierr = VecAXPY(F_data->getVec(), 1.0, F_ghost_data->getVec());
    ierr = VecGhostUpdateBegin(D_ghost_data->getVec(), ADD_VALUES, SCATTER_REVERSE);
    IBTK_CHKERRQ(ierr);
    ierr = VecGhostUpdateEnd(D_ghost_data->getVec(), ADD_VALUES, SCATTER_REVERSE);
    IBTK_CHKERRQ(ierr);

    // Compute the damage factor.
    boost::multi_array_ref<double, 1>& D_data_array = *D_data->getLocalFormArray();
    boost::multi_array_ref<double, 2>& D_ghost_data_array = *D_ghost_data->getLocalFormVecArray();
    for (const auto& node : local_nodes)
    {
        const int local_idx = node->getLocalPETScIndex();
        double* D_ghost = &D_ghost_data_array[local_idx][0];
        double* D = &D_data_array[local_idx];

        D[0] = 1.0 - D_ghost[0] / D_ghost[1];
    }
    D_data->restoreArrays();
    D_ghost_data->restoreArrays();

    return;
} // computeLagrangianForce

/////////////////////////////// PROTECTED ////////////////////////////////////

/////////////////////////////// PRIVATE //////////////////////////////////////

void
IBPDForceGen::initializeBondLevelData(std::set<int>& nonlocal_petsc_idx_set,
                                      const Pointer<PatchHierarchy<NDIM> > /*hierarchy*/,
                                      const int level_number,
                                      const double /*init_data_time*/,
                                      const bool /*initial_time*/,
                                      LDataManager* const l_data_manager)
{
    std::vector<int>& lag_mastr_node_idxs = d_bond_data[level_number].lag_mastr_node_idxs;
    std::vector<int>& lag_slave_node_idxs = d_bond_data[level_number].lag_slave_node_idxs;
    std::vector<int>& petsc_mastr_node_idxs = d_bond_data[level_number].petsc_mastr_node_idxs;
    std::vector<int>& petsc_slave_node_idxs = d_bond_data[level_number].petsc_slave_node_idxs;
    std::vector<int>& petsc_global_mastr_node_idxs = d_bond_data[level_number].petsc_global_mastr_node_idxs;
    std::vector<int>& petsc_global_slave_node_idxs = d_bond_data[level_number].petsc_global_slave_node_idxs;
    std::vector<BondForceDamageFcnPtr>& force_dmg_fcns = d_bond_data[level_number].force_dmg_fcns;
    std::vector<BondPK1FcnPtr>& force_PK1_fcns = d_bond_data[level_number].force_PK1_fcns;
    std::vector<BondInfluenceFcnPtr>& force_inf_fcns = d_bond_data[level_number].force_inf_fcns;
    std::vector<BondVolFracFcnPtr>& force_vol_frac_fcns = d_bond_data[level_number].force_vol_frac_fcns;
    std::vector<double*>& parameters = d_bond_data[level_number].parameters;

    // The LMesh object provides the set of local Lagrangian nodes.
    const Pointer<LMesh> mesh = l_data_manager->getLMesh(level_number);
    const std::vector<LNode*>& local_nodes = mesh->getLocalNodes();
    const auto num_local_nodes = static_cast<int>(local_nodes.size());

    // Determine how many bonds are associated with the present MPI process.
    unsigned int num_bonds = 0;
    for (const auto& node : local_nodes)
    {
        const IBSpringForceSpec* const force_spec = node->getNodeDataItem<IBSpringForceSpec>();
        if (force_spec) num_bonds += force_spec->getNumberOfSprings();
    }

    // Resize arrays for storing cached values used to compute bond forces.
    lag_mastr_node_idxs.resize(num_bonds);
    lag_slave_node_idxs.resize(num_bonds);
    petsc_mastr_node_idxs.resize(num_bonds);
    petsc_slave_node_idxs.resize(num_bonds);
    petsc_global_mastr_node_idxs.resize(num_bonds);
    petsc_global_slave_node_idxs.resize(num_bonds);
    force_dmg_fcns.resize(num_bonds);
    force_PK1_fcns.resize(num_bonds);
    force_inf_fcns.resize(num_bonds);
    force_vol_frac_fcns.resize(num_bonds);
    parameters.resize(num_bonds);

    // Setup the data structures used to compute bond forces.
    int current_bond = 0;
    for (const auto& node : local_nodes)
    {
        IBSpringForceSpec* const force_spec = node->getNodeDataItem<IBSpringForceSpec>();
        if (!force_spec) continue;

        const int lag_idx = node->getLagrangianIndex();
#if !defined(NDEBUG)
        TBOX_ASSERT(lag_idx == force_spec->getMasterNodeIndex());
#endif
        const int petsc_idx = node->getGlobalPETScIndex();
        const std::vector<int>& slv = force_spec->getSlaveNodeIndices();
        const std::vector<int>& fcn = force_spec->getForceFunctionIndices();
        std::vector<std::vector<double> >& params = force_spec->getParameters();
        const unsigned int n_mastr_bonds = force_spec->getNumberOfSprings();
#if !defined(NDEBUG)
        TBOX_ASSERT(n_mastr_bonds == slv.size());
        TBOX_ASSERT(n_mastr_bonds == params.size());
#endif
        for (unsigned int k = 0; k < n_mastr_bonds; ++k)
        {
            lag_mastr_node_idxs[current_bond] = lag_idx;
            lag_slave_node_idxs[current_bond] = slv[k];
            petsc_mastr_node_idxs[current_bond] = petsc_idx;
            force_dmg_fcns[current_bond] = d_bond_force_damage_fcn_map[fcn[k]];
            force_PK1_fcns[current_bond] = d_bond_PK1_fcn_map[fcn[k]];
            force_inf_fcns[current_bond] = d_bond_inf_fcn_map[fcn[k]];
            force_vol_frac_fcns[current_bond] = d_bond_vol_frac_fcn_map[fcn[k]];
            parameters[current_bond] = params.empty() ? nullptr : &params[k][0];
            ++current_bond;
        }
    }

    // Map the Lagrangian slave node indices to the PETSc indices corresponding
    // to the present data distribution.
    petsc_slave_node_idxs = lag_slave_node_idxs;
    l_data_manager->mapLagrangianToPETSc(petsc_slave_node_idxs, level_number);

    // Keep a copy of global PETSc indices.
    petsc_global_mastr_node_idxs = petsc_mastr_node_idxs;
    petsc_global_slave_node_idxs = petsc_slave_node_idxs;

    // Determine the ghost nodes required to compute spring forces.
    //
    // NOTE: Only slave nodes can be "off processor".  Master nodes are
    // guaranteed to be "on processor".
    const int global_node_offset = l_data_manager->getGlobalNodeOffset(level_number);
    for (unsigned int k = 0; k < petsc_slave_node_idxs.size(); ++k)
    {
        const int idx = petsc_slave_node_idxs[k];
        if (UNLIKELY(idx < global_node_offset || idx >= global_node_offset + num_local_nodes))
        {
            nonlocal_petsc_idx_set.insert(idx);
        }
    }
    return;
} // initializeBondLevelData

void
IBPDForceGen::computeShapeTensor(Pointer<LData> B_data,
                                 Pointer<LData> X0_data,
                                 Pointer<PatchHierarchy<NDIM> > hierarchy,
                                 int level_number,
                                 double /*data_time*/,
                                 LDataManager* l_data_manager)
{
    const auto num_bonds = static_cast<int>(d_bond_data[level_number].lag_mastr_node_idxs.size());
    if (num_bonds == 0) return;

    Pointer<PatchLevel<NDIM> > level = hierarchy->getPatchLevel(level_number);
    const IntVector<NDIM>& ratio = level->getRatio();
    Pointer<CartesianGridGeometry<NDIM> > grid_geom = level->getGridGeometry();
    const double* dx0 = grid_geom->getDx();
    double dx[NDIM];
    for (int d = 0; d < NDIM; ++d)
    {
        dx[d] = dx0[d] / ratio[d];
    }
    const double horizon = d_horizon * (*std::max_element(dx, dx + NDIM));
    const double delta = d_ds * (*std::min_element(dx, dx + NDIM));

    const Pointer<LMesh> mesh = l_data_manager->getLMesh(level_number);
    const std::vector<LNode*>& local_nodes = mesh->getLocalNodes();

    const int* const lag_mastr_node_idxs = &d_bond_data[level_number].lag_mastr_node_idxs[0];
    const int* const lag_slave_node_idxs = &d_bond_data[level_number].lag_slave_node_idxs[0];
    int* petsc_mastr_node_idxs = &d_bond_data[level_number].petsc_mastr_node_idxs[0];
    int* petsc_slave_node_idxs = &d_bond_data[level_number].petsc_slave_node_idxs[0];

    for (const auto& node : local_nodes)
    {
        const int local_idx = node->getLocalPETScIndex();
        const int lag_idx = node->getLagrangianIndex();

        for (int k = 0; k < num_bonds ; ++k)
        {
            if (lag_idx == lag_mastr_node_idxs[k])
            {
                petsc_mastr_node_idxs[k] = local_idx;
            }
            if (lag_idx == lag_slave_node_idxs[k])
            {
                petsc_slave_node_idxs[k] = local_idx;
            }
        }
    }

    double** const parameters = &d_bond_data[level_number].parameters[0];
    const BondInfluenceFcnPtr* const force_inf_fcns = &d_bond_data[level_number].force_inf_fcns[0];
    const BondVolFracFcnPtr* const force_vol_frac_fcns = &d_bond_data[level_number].force_vol_frac_fcns[0];
    double* const B_node = B_data->getGhostedLocalFormVecArray()->data();
    const double* const X0_node = X0_data->getGhostedLocalFormVecArray()->data();

    static const int BLOCKSIZE = 16; // this parameter needs to be tuned
    int k, kblock, kunroll, X_mastr_idx, X_slave_idx, B_mastr_idx, B_slave_idx;
    double Q0[NDIM], R0, W, vol_frac;
    kblock = 0;
    for (; kblock < (num_bonds - 1) / BLOCKSIZE;
         ++kblock) // ensure that the last block is NOT handled by this first loop
    {
        PREFETCH_READ_NTA_BLOCK(petsc_mastr_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        PREFETCH_READ_NTA_BLOCK(petsc_slave_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        PREFETCH_READ_NTA_BLOCK(parameters + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        for (kunroll = 0; kunroll < BLOCKSIZE; ++kunroll)
        {
            k = kblock * BLOCKSIZE + kunroll;
            X_mastr_idx = petsc_mastr_node_idxs[k] * NDIM;
            X_slave_idx = petsc_slave_node_idxs[k] * NDIM;
            B_mastr_idx = petsc_mastr_node_idxs[k] * NDIM * NDIM;
            B_slave_idx = petsc_slave_node_idxs[k] * NDIM * NDIM;
#if !defined(NDEBUG)
            TBOX_ASSERT(X_mastr_idx != X_slave_idx);
            TBOX_ASSERT(B_mastr_idx != B_slave_idx);
#endif
            PREFETCH_READ_NTA_BLOCK(B_node + NDIM * NDIM * petsc_mastr_node_idxs[k + 1], NDIM * NDIM);
            PREFETCH_READ_NTA_BLOCK(B_node + NDIM * NDIM * petsc_slave_node_idxs[k + 1], NDIM * NDIM);
            PREFETCH_READ_NTA_NDIM_BLOCK(X0_node + NDIM * petsc_mastr_node_idxs[k + 1]);
            PREFETCH_READ_NTA_NDIM_BLOCK(X0_node + NDIM * petsc_slave_node_idxs[k + 1]);
            PREFETCH_READ_NTA(parameters[k + 1]);

            Q0[0] = X0_node[X_slave_idx + 0] - X0_node[X_mastr_idx + 0];
            Q0[1] = X0_node[X_slave_idx + 1] - X0_node[X_mastr_idx + 1];
#if (NDIM == 3)
            Q0[2] = X0_node[X_slave_idx + 2] - X0_node[X_mastr_idx + 2];
#endif

            const double* bond_params = parameters[k];
            const double& vol_mastr = bond_params[2];
            const double& vol_slave = bond_params[3];
            const double& fail = bond_params[4];
            R0 = bond_params[1];
            W = force_inf_fcns[k](R0, delta);
            vol_frac = force_vol_frac_fcns[k](R0, horizon, delta);

            Eigen::Map<IBTK::Vector> eig_Q0(Q0);
            Eigen::Map<Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_B_mastr(&B_node[B_mastr_idx]),
                eig_B_slave(&B_node[B_slave_idx]);
            eig_B_mastr.noalias() += fail * W * vol_frac * vol_slave * eig_Q0 * eig_Q0.transpose();
            eig_B_slave.noalias() += fail * W * vol_frac * vol_mastr * eig_Q0 * eig_Q0.transpose();
        }
    }
    for (k = kblock * BLOCKSIZE; k < num_bonds; ++k)
    {
        X_mastr_idx = petsc_mastr_node_idxs[k] * NDIM;
        X_slave_idx = petsc_slave_node_idxs[k] * NDIM;
        B_mastr_idx = petsc_mastr_node_idxs[k] * NDIM * NDIM;
        B_slave_idx = petsc_slave_node_idxs[k] * NDIM * NDIM;
#if !defined(NDEBUG)
        TBOX_ASSERT(X_mastr_idx != X_slave_idx);
        TBOX_ASSERT(B_mastr_idx != B_slave_idx);
#endif

        Q0[0] = X0_node[X_slave_idx + 0] - X0_node[X_mastr_idx + 0];
        Q0[1] = X0_node[X_slave_idx + 1] - X0_node[X_mastr_idx + 1];
#if (NDIM == 3)
        Q0[2] = X0_node[X_slave_idx + 2] - X0_node[X_mastr_idx + 2];
#endif

        const double* bond_params = parameters[k];
        const double& vol_mastr = bond_params[2];
        const double& vol_slave = bond_params[3];
        const double& fail = bond_params[4];
        R0 = bond_params[1];
        W = force_inf_fcns[k](R0, delta);
        vol_frac = force_vol_frac_fcns[k](R0, horizon, delta);

        Eigen::Map<IBTK::Vector> eig_Q0(Q0);
        Eigen::Map<Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_B_mastr(&B_node[B_mastr_idx]),
            eig_B_slave(&B_node[B_slave_idx]);
        eig_B_mastr.noalias() += fail * W * vol_frac * vol_slave * eig_Q0 * eig_Q0.transpose();
        eig_B_slave.noalias() += fail * W * vol_frac * vol_mastr * eig_Q0 * eig_Q0.transpose();
    }

    X0_data->restoreArrays();
    B_data->restoreArrays();

    return;
} // computeShapeTensor

void
IBPDForceGen::computeDeformationGradientTensor(Pointer<LData> FF_data,
                                               Pointer<LData> X_data,
                                               Pointer<LData> X0_data,
                                               Pointer<PatchHierarchy<NDIM> > hierarchy,
                                               int level_number,
                                               double /*data_time*/,
                                               LDataManager* l_data_manager)
{
    const auto num_bonds = static_cast<int>(d_bond_data[level_number].lag_mastr_node_idxs.size());
    if (num_bonds == 0) return;

    Pointer<PatchLevel<NDIM> > level = hierarchy->getPatchLevel(level_number);
    const IntVector<NDIM>& ratio = level->getRatio();
    Pointer<CartesianGridGeometry<NDIM> > grid_geom = level->getGridGeometry();
    const double* dx0 = grid_geom->getDx();
    double dx[NDIM];
    for (int d = 0; d < NDIM; ++d)
    {
        dx[d] = dx0[d] / ratio[d];
    }
    const double horizon = d_horizon * (*std::min_element(dx, dx + NDIM));
    const double delta = d_ds * (*std::min_element(dx, dx + NDIM));

    const Pointer<LMesh> mesh = l_data_manager->getLMesh(level_number);
    const std::vector<LNode*>& local_nodes = mesh->getLocalNodes();

    const int* const lag_mastr_node_idxs = &d_bond_data[level_number].lag_mastr_node_idxs[0];
    const int* const lag_slave_node_idxs = &d_bond_data[level_number].lag_slave_node_idxs[0];
    int* petsc_mastr_node_idxs = &d_bond_data[level_number].petsc_mastr_node_idxs[0];
    int* petsc_slave_node_idxs = &d_bond_data[level_number].petsc_slave_node_idxs[0];

    for (const auto& node : local_nodes)
    {
        const int local_idx = node->getLocalPETScIndex();
        const int lag_idx = node->getLagrangianIndex();

        for (int k = 0; k < num_bonds ; ++k)
        {
            if (lag_idx == lag_mastr_node_idxs[k])
            {
                petsc_mastr_node_idxs[k] = local_idx;
            }
            if (lag_idx == lag_slave_node_idxs[k])
            {
                petsc_slave_node_idxs[k] = local_idx;
            }
        }
    }

    double** const parameters = &d_bond_data[level_number].parameters[0];
    const BondInfluenceFcnPtr* const force_inf_fcns = &d_bond_data[level_number].force_inf_fcns[0];
    const BondVolFracFcnPtr* const force_vol_frac_fcns = &d_bond_data[level_number].force_vol_frac_fcns[0];
    double* const FF_node = FF_data->getGhostedLocalFormVecArray()->data();
    const double* const X_node = X_data->getGhostedLocalFormVecArray()->data();
    const double* const X0_node = X0_data->getGhostedLocalFormVecArray()->data();

    static const int BLOCKSIZE = 16; // this parameter needs to be tuned
    int k, kblock, kunroll, X_mastr_idx, X_slave_idx, FF_mastr_idx, FF_slave_idx;
    double Q[NDIM], Q0[NDIM], R0, W, vol_frac;
    kblock = 0;
    for (; kblock < (num_bonds - 1) / BLOCKSIZE;
         ++kblock) // ensure that the last block is NOT handled by this first loop
    {
        PREFETCH_READ_NTA_BLOCK(petsc_mastr_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        PREFETCH_READ_NTA_BLOCK(petsc_slave_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        PREFETCH_READ_NTA_BLOCK(parameters + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        for (kunroll = 0; kunroll < BLOCKSIZE; ++kunroll)
        {
            k = kblock * BLOCKSIZE + kunroll;
            X_mastr_idx = petsc_mastr_node_idxs[k] * NDIM;
            X_slave_idx = petsc_slave_node_idxs[k] * NDIM;
            FF_mastr_idx = petsc_mastr_node_idxs[k] * NDIM * NDIM;
            FF_slave_idx = petsc_slave_node_idxs[k] * NDIM * NDIM;
#if !defined(NDEBUG)
            TBOX_ASSERT(X_mastr_idx != X_slave_idx);
            TBOX_ASSERT(FF_mastr_idx != FF_slave_idx);
#endif
            PREFETCH_READ_NTA_BLOCK(FF_node + NDIM * NDIM * petsc_mastr_node_idxs[k + 1], NDIM * NDIM);
            PREFETCH_READ_NTA_BLOCK(FF_node + NDIM * NDIM * petsc_slave_node_idxs[k + 1], NDIM * NDIM);
            PREFETCH_READ_NTA_NDIM_BLOCK(X_node + NDIM * petsc_mastr_node_idxs[k + 1]);
            PREFETCH_READ_NTA_NDIM_BLOCK(X_node + NDIM * petsc_slave_node_idxs[k + 1]);
            PREFETCH_READ_NTA_NDIM_BLOCK(X0_node + NDIM * petsc_mastr_node_idxs[k + 1]);
            PREFETCH_READ_NTA_NDIM_BLOCK(X0_node + NDIM * petsc_slave_node_idxs[k + 1]);
            PREFETCH_READ_NTA(parameters[k + 1]);

            Q[0] = X_node[X_slave_idx + 0] - X_node[X_mastr_idx + 0];
            Q[1] = X_node[X_slave_idx + 1] - X_node[X_mastr_idx + 1];
#if (NDIM == 3)
            Q[2] = X_node[X_slave_idx + 2] - X_node[X_mastr_idx + 2];
#endif

            Q0[0] = X0_node[X_slave_idx + 0] - X0_node[X_mastr_idx + 0];
            Q0[1] = X0_node[X_slave_idx + 1] - X0_node[X_mastr_idx + 1];
#if (NDIM == 3)
            Q0[2] = X0_node[X_slave_idx + 2] - X0_node[X_mastr_idx + 2];
#endif

            const double* bond_params = parameters[k];
            const double& vol_mastr = bond_params[2];
            const double& vol_slave = bond_params[3];
            const double& fail = bond_params[4];
            R0 = parameters[k][1];
            W = force_inf_fcns[k](R0, delta);
            vol_frac = force_vol_frac_fcns[k](R0, horizon, delta);

            Eigen::Map<const IBTK::Vector> eig_Q(Q), eig_Q0(Q0);
            Eigen::Map<Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_FF_mastr(&FF_node[FF_mastr_idx]),
                eig_FF_slave(&FF_node[FF_slave_idx]);
            eig_FF_mastr.noalias() += fail * W * vol_frac * vol_slave * eig_Q * eig_Q0.transpose();
            eig_FF_slave.noalias() += fail * W * vol_frac * vol_mastr * eig_Q * eig_Q0.transpose();
        }
    }
    for (k = kblock * BLOCKSIZE; k < num_bonds; ++k)
    {
        X_mastr_idx = petsc_mastr_node_idxs[k] * NDIM;
        X_slave_idx = petsc_slave_node_idxs[k] * NDIM;
        FF_mastr_idx = petsc_mastr_node_idxs[k] * NDIM * NDIM;
        FF_slave_idx = petsc_slave_node_idxs[k] * NDIM * NDIM;
#if !defined(NDEBUG)
        TBOX_ASSERT(X_mastr_idx != X_slave_idx);
        TBOX_ASSERT(FF_mastr_idx != FF_slave_idx);
#endif

        Q[0] = X_node[X_slave_idx + 0] - X_node[X_mastr_idx + 0];
        Q[1] = X_node[X_slave_idx + 1] - X_node[X_mastr_idx + 1];
#if (NDIM == 3)
        Q[2] = X_node[X_slave_idx + 2] - X_node[X_mastr_idx + 2];
#endif

        Q0[0] = X0_node[X_slave_idx + 0] - X0_node[X_mastr_idx + 0];
        Q0[1] = X0_node[X_slave_idx + 1] - X0_node[X_mastr_idx + 1];
#if (NDIM == 3)
        Q0[2] = X0_node[X_slave_idx + 2] - X0_node[X_mastr_idx + 2];
#endif

        const double* bond_params = parameters[k];
        const double& vol_mastr = bond_params[2];
        const double& vol_slave = bond_params[3];
        const double& fail = bond_params[4];
        R0 = bond_params[1];
        W = force_inf_fcns[k](R0, delta);
        vol_frac = force_vol_frac_fcns[k](R0, horizon, delta);

        Eigen::Map<const IBTK::Vector> eig_Q(Q), eig_Q0(Q0);
        Eigen::Map<Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_FF_mastr(&FF_node[FF_mastr_idx]),
            eig_FF_slave(&FF_node[FF_slave_idx]);
        eig_FF_mastr.noalias() += fail * W * vol_frac * vol_slave * eig_Q * eig_Q0.transpose();
        eig_FF_slave.noalias() += fail * W * vol_frac * vol_mastr * eig_Q * eig_Q0.transpose();
    }

    X_data->restoreArrays();
    X0_data->restoreArrays();
    FF_data->restoreArrays();

    return;
} // computeDeformationGradientTensor

void
IBPDForceGen::computeLagrangianBondForceAndDamage(Pointer<LData> F_data,
                                                  Pointer<LData> D_data,
                                                  Pointer<LData> X_data,
                                                  Pointer<LData> X0_data,
                                                  Pointer<LData> FF_data,
                                                  Pointer<LData> B_data,
                                                  const Pointer<PatchHierarchy<NDIM> > hierarchy,
                                                  const int level_number,
                                                  const double /*data_time*/,
                                                  LDataManager* const l_data_manager)
{
    const auto num_bonds = static_cast<int>(d_bond_data[level_number].lag_mastr_node_idxs.size());
    if (num_bonds == 0) return;

    Pointer<PatchLevel<NDIM> > level = hierarchy->getPatchLevel(level_number);
    const IntVector<NDIM>& ratio = level->getRatio();
    Pointer<CartesianGridGeometry<NDIM> > grid_geom = level->getGridGeometry();
    const double* dx0 = grid_geom->getDx();
    double dx[NDIM];
    for (int d = 0; d < NDIM; ++d)
    {
        dx[d] = dx0[d] / ratio[d];
    }
    const double horizon = d_horizon * (*std::max_element(dx, dx + NDIM));
    const double delta = d_ds * (*std::min_element(dx, dx + NDIM));

    const Pointer<LMesh> mesh = l_data_manager->getLMesh(level_number);
    const std::vector<LNode*>& local_nodes = mesh->getLocalNodes();

    const int* const lag_mastr_node_idxs = &d_bond_data[level_number].lag_mastr_node_idxs[0];
    const int* const lag_slave_node_idxs = &d_bond_data[level_number].lag_slave_node_idxs[0];
    int* petsc_mastr_node_idxs = &d_bond_data[level_number].petsc_mastr_node_idxs[0];
    int* petsc_slave_node_idxs = &d_bond_data[level_number].petsc_slave_node_idxs[0];

    for (const auto& node : local_nodes)
    {
        const int local_idx = node->getLocalPETScIndex();
        const int lag_idx = node->getLagrangianIndex();

        for (int k = 0; k < num_bonds ; ++k)
        {
            if (lag_idx == lag_mastr_node_idxs[k])
            {
                petsc_mastr_node_idxs[k] = local_idx;
            }
            if (lag_idx == lag_slave_node_idxs[k])
            {
                petsc_slave_node_idxs[k] = local_idx;
            }
        }
    }

    double** const parameters = &d_bond_data[level_number].parameters[0];
    const BondForceDamageFcnPtr* const force_dmg_fcns = &d_bond_data[level_number].force_dmg_fcns[0];
    const BondInfluenceFcnPtr* const force_inf_fcns = &d_bond_data[level_number].force_inf_fcns[0];
    const BondVolFracFcnPtr* const force_vol_frac_fcns = &d_bond_data[level_number].force_vol_frac_fcns[0];
    double* const F_node = F_data->getGhostedLocalFormVecArray()->data();
    double* const D_node = D_data->getGhostedLocalFormVecArray()->data();
    const double* const X_node = X_data->getGhostedLocalFormVecArray()->data();
    const double* const X0_node = X0_data->getGhostedLocalFormVecArray()->data();
    const double* const FF_node = FF_data->getGhostedLocalFormVecArray()->data();
    const double* const B_node = B_data->getGhostedLocalFormVecArray()->data();

    static const int BLOCKSIZE = 16; // this parameter needs to be tuned
    int k, kblock, kunroll, X_F_mastr_idx, X_F_slave_idx, FF_B_mastr_idx, FF_B_slave_idx, dmg_mastr_idx, dmg_slave_idx;
    double Q[NDIM], R, R0, W, vol_frac;
    kblock = 0;
    for (; kblock < (num_bonds - 1) / BLOCKSIZE;
         ++kblock) // ensure that the last block is NOT handled by this first loop
    {
        PREFETCH_READ_NTA_BLOCK(lag_mastr_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        PREFETCH_READ_NTA_BLOCK(lag_slave_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        PREFETCH_READ_NTA_BLOCK(petsc_mastr_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        PREFETCH_READ_NTA_BLOCK(petsc_slave_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        PREFETCH_READ_NTA_BLOCK(parameters + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
        for (kunroll = 0; kunroll < BLOCKSIZE; ++kunroll)
        {
            k = kblock * BLOCKSIZE + kunroll;
            X_F_mastr_idx = petsc_mastr_node_idxs[k] * NDIM;
            X_F_slave_idx = petsc_slave_node_idxs[k] * NDIM;
            dmg_mastr_idx = petsc_mastr_node_idxs[k] * 2;
            dmg_slave_idx = petsc_slave_node_idxs[k] * 2;
            FF_B_mastr_idx = petsc_mastr_node_idxs[k] * NDIM * NDIM;
            FF_B_slave_idx = petsc_slave_node_idxs[k] * NDIM * NDIM;
#if !defined(NDEBUG)
            TBOX_ASSERT(X_F_mastr_idx != X_F_slave_idx);
            TBOX_ASSERT(dmg_mastr_idx != dmg_slave_idx);
            TBOX_ASSERT(FF_B_mastr_idx != FF_B_slave_idx);
#endif
            PREFETCH_READ_NTA_NDIM_BLOCK(F_node + NDIM * petsc_mastr_node_idxs[k + 1]);
            PREFETCH_READ_NTA_NDIM_BLOCK(F_node + NDIM * petsc_slave_node_idxs[k + 1]);
            PREFETCH_READ_NTA_NDIM_BLOCK(X_node + NDIM * petsc_mastr_node_idxs[k + 1]);
            PREFETCH_READ_NTA_NDIM_BLOCK(X_node + NDIM * petsc_slave_node_idxs[k + 1]);
            PREFETCH_READ_NTA_NDIM_BLOCK(X0_node + NDIM * petsc_mastr_node_idxs[k + 1]);
            PREFETCH_READ_NTA_NDIM_BLOCK(X0_node + NDIM * petsc_slave_node_idxs[k + 1]);
            PREFETCH_READ_NTA_BLOCK(FF_node + NDIM * NDIM * petsc_mastr_node_idxs[k + 1], NDIM * NDIM);
            PREFETCH_READ_NTA_BLOCK(FF_node + NDIM * NDIM * petsc_slave_node_idxs[k + 1], NDIM * NDIM);
            PREFETCH_READ_NTA_BLOCK(B_node + NDIM * NDIM * petsc_mastr_node_idxs[k + 1], NDIM * NDIM);
            PREFETCH_READ_NTA_BLOCK(B_node + NDIM * NDIM * petsc_slave_node_idxs[k + 1], NDIM * NDIM);
            PREFETCH_READ_NTA(parameters[k + 1]);

            Q[0] = X_node[X_F_slave_idx + 0] - X_node[X_F_mastr_idx + 0];
            Q[1] = X_node[X_F_slave_idx + 1] - X_node[X_F_mastr_idx + 1];
#if (NDIM == 3)
            Q[2] = X_node[X_F_slave_idx + 2] - X_node[X_F_mastr_idx + 2];
#endif

#if (NDIM == 2)
            R = sqrt(Q[0] * Q[0] + Q[1] * Q[1]);
#endif
#if (NDIM == 3)
            R = sqrt(Q[0] * Q[0] + Q[1] * Q[1] + Q[2] * Q[2]);
#endif

            if (UNLIKELY(R < std::numeric_limits<double>::epsilon())) continue;

            Eigen::Map<const IBTK::Vector> eig_X0_mastr(&X0_node[X_F_mastr_idx]), eig_X0_slave(&X0_node[X_F_slave_idx]);
            Eigen::Map<const IBTK::Vector> eig_X_mastr(&X_node[X_F_mastr_idx]), eig_X_slave(&X_node[X_F_slave_idx]);
            Eigen::Map<IBTK::Vector> eig_F_mastr(&F_node[X_F_mastr_idx]), eig_F_slave(&F_node[X_F_slave_idx]);
            Eigen::Map<const Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_B_mastr(&B_node[FF_B_mastr_idx]),
                eig_B_slave(&B_node[FF_B_slave_idx]);
            Eigen::Map<const Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_FF_mastr(
                &FF_node[FF_B_mastr_idx]),
                eig_FF_slave(&FF_node[FF_B_slave_idx]);

            R0 = parameters[k][1];
            W = force_inf_fcns[k](R0, delta);
            vol_frac = force_vol_frac_fcns[k](R0, horizon, delta);

            Eigen::Vector4d dmg = force_dmg_fcns[k](horizon,
                                                    delta,
                                                    W,
                                                    vol_frac,
                                                    parameters[k],
                                                    eig_X0_mastr,
                                                    eig_X0_slave,
                                                    eig_X_mastr,
                                                    eig_X_slave,
                                                    eig_FF_mastr,
                                                    eig_FF_slave,
                                                    eig_B_mastr,
                                                    eig_B_slave,
                                                    eig_F_mastr,
                                                    eig_F_slave,
                                                    lag_mastr_node_idxs[k],
                                                    lag_slave_node_idxs[k]);

            D_node[dmg_mastr_idx + 0] += dmg[0];
            D_node[dmg_mastr_idx + 1] += dmg[1];
            D_node[dmg_slave_idx + 0] += dmg[2];
            D_node[dmg_slave_idx + 1] += dmg[3];
        }
    }
    for (k = kblock * BLOCKSIZE; k < num_bonds; ++k)
    {
        X_F_mastr_idx = petsc_mastr_node_idxs[k] * NDIM;
        X_F_slave_idx = petsc_slave_node_idxs[k] * NDIM;
        dmg_mastr_idx = petsc_mastr_node_idxs[k] * 2;
        dmg_slave_idx = petsc_slave_node_idxs[k] * 2;
        FF_B_mastr_idx = petsc_mastr_node_idxs[k] * NDIM * NDIM;
        FF_B_slave_idx = petsc_slave_node_idxs[k] * NDIM * NDIM;
#if !defined(NDEBUG)
        TBOX_ASSERT(X_F_mastr_idx != X_F_slave_idx);
        TBOX_ASSERT(dmg_mastr_idx != dmg_slave_idx);
        TBOX_ASSERT(FF_B_mastr_idx != FF_B_slave_idx);
#endif
        Q[0] = X_node[X_F_slave_idx + 0] - X_node[X_F_mastr_idx + 0];
        Q[1] = X_node[X_F_slave_idx + 1] - X_node[X_F_mastr_idx + 1];
#if (NDIM == 3)
        Q[2] = X_node[X_F_slave_idx + 2] - X_node[X_F_mastr_idx + 2];
#endif

#if (NDIM == 2)
        R = sqrt(Q[0] * Q[0] + Q[1] * Q[1]);
#endif
#if (NDIM == 3)
        R = sqrt(Q[0] * Q[0] + Q[1] * Q[1] + Q[2] * Q[2]);
#endif

        if (UNLIKELY(R < std::numeric_limits<double>::epsilon())) continue;

        Eigen::Map<const IBTK::Vector> eig_X0_mastr(&X0_node[X_F_mastr_idx]), eig_X0_slave(&X0_node[X_F_slave_idx]);
        Eigen::Map<const IBTK::Vector> eig_X_mastr(&X0_node[X_F_mastr_idx]), eig_X_slave(&X0_node[X_F_slave_idx]);
        Eigen::Map<IBTK::Vector> eig_F_mastr(&F_node[X_F_mastr_idx]), eig_F_slave(&F_node[X_F_slave_idx]);
        Eigen::Map<const Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_B_mastr(&B_node[FF_B_mastr_idx]),
            eig_B_slave(&B_node[FF_B_slave_idx]);
        Eigen::Map<const Eigen::Matrix<double, NDIM, NDIM, Eigen::RowMajor> > eig_FF_mastr(&FF_node[FF_B_mastr_idx]),
            eig_FF_slave(&FF_node[FF_B_slave_idx]);

        R0 = parameters[k][1];
        W = force_inf_fcns[k](R0, delta);
        vol_frac = force_vol_frac_fcns[k](R0, horizon, delta);

        Eigen::Vector4d dmg = force_dmg_fcns[k](horizon,
                                                delta,
                                                W,
                                                vol_frac,
                                                parameters[k],
                                                eig_X0_mastr,
                                                eig_X0_slave,
                                                eig_X_mastr,
                                                eig_X_slave,
                                                eig_FF_mastr,
                                                eig_FF_slave,
                                                eig_B_mastr,
                                                eig_B_slave,
                                                eig_F_mastr,
                                                eig_F_slave,
                                                lag_mastr_node_idxs[k],
                                                lag_slave_node_idxs[k]);

        D_node[dmg_mastr_idx + 0] += dmg[0];
        D_node[dmg_mastr_idx + 1] += dmg[1];
        D_node[dmg_slave_idx + 0] += dmg[2];
        D_node[dmg_slave_idx + 1] += dmg[3];
    }

    F_data->restoreArrays();
    D_data->restoreArrays();
    B_data->restoreArrays();
    X_data->restoreArrays();
    X0_data->restoreArrays();

    return;
} // computeLagrangianBondForceAndDamage

void
IBPDForceGen::initializeTargetPointLevelData(std::set<int>& /*nonlocal_petsc_idx_set*/,
                                             const Pointer<PatchHierarchy<NDIM> > /*hierarchy*/,
                                             const int level_number,
                                             const double /*init_data_time*/,
                                             const bool /*initial_time*/,
                                             LDataManager* const l_data_manager)
{
    std::vector<int>& petsc_node_idxs = d_target_point_data[level_number].petsc_node_idxs;
    std::vector<int>& petsc_global_node_idxs = d_target_point_data[level_number].petsc_global_node_idxs;
    std::vector<const double*>& kappa = d_target_point_data[level_number].kappa;
    std::vector<const double*>& eta = d_target_point_data[level_number].eta;
    std::vector<const Point*>& X0 = d_target_point_data[level_number].X0;

    // The LMesh object provides the set of local Lagrangian nodes.
    const Pointer<LMesh> mesh = l_data_manager->getLMesh(level_number);
    const std::vector<LNode*>& local_nodes = mesh->getLocalNodes();

    // Determine how many target points are associated with the present MPI
    // process.
    unsigned int num_target_points = 0;
    for (const auto& node : local_nodes)
    {
        const IBTargetPointForceSpec* const force_spec = node->getNodeDataItem<IBTargetPointForceSpec>();
        if (force_spec) num_target_points += 1;
    }

    // Resize arrays for storing cached values used to compute target point
    // forces.
    petsc_node_idxs.resize(num_target_points);
    petsc_global_node_idxs.resize(num_target_points);
    kappa.resize(num_target_points);
    eta.resize(num_target_points);
    X0.resize(num_target_points);

    // Setup the data structures used to compute target point forces.
    int current_target_point = 0;
    for (const auto& node : local_nodes)
    {
        const IBTargetPointForceSpec* const force_spec = node->getNodeDataItem<IBTargetPointForceSpec>();
        if (!force_spec) continue;
        petsc_global_node_idxs[current_target_point] = petsc_node_idxs[current_target_point] =
            node->getGlobalPETScIndex();
        kappa[current_target_point] = &force_spec->getStiffness();
        eta[current_target_point] = &force_spec->getDamping();
        X0[current_target_point] = &force_spec->getTargetPointPosition();
        ++current_target_point;
    }

    return;
} // initializeTargetPointLevelData

void
IBPDForceGen::computeLagrangianTargetPointForce(Pointer<LData> F_data,
                                                Pointer<LData> X_data,
                                                Pointer<LData> X0_data,
                                                Pointer<LData> U_data,
                                                const Pointer<PatchHierarchy<NDIM> > /*hierarchy*/,
                                                const int level_number,
                                                const double /*data_time*/,
                                                LDataManager* const l_data_manager)
{
    const auto num_target_points = static_cast<int>(d_target_point_data[level_number].petsc_node_idxs.size());
    if (num_target_points == 0) return;
    int* petsc_node_idxs = &d_target_point_data[level_number].petsc_node_idxs[0];
    int* petsc_global_node_idxs = &d_target_point_data[level_number].petsc_global_node_idxs[0];
    const double** const kappa = &d_target_point_data[level_number].kappa[0];
    const double** const eta = &d_target_point_data[level_number].eta[0];
    const Point** const X0 = &d_target_point_data[level_number].X0[0];
    double* const F_node = F_data->getLocalFormVecArray()->data();
    const double* const X_node = X_data->getLocalFormVecArray()->data();
    const double* const U_node = U_data->getLocalFormVecArray()->data();
    const double* const X0_node = X0_data->getLocalFormVecArray()->data();

    static const int BLOCKSIZE = 16; // This parameter needs to be tuned.
    int k, kblock, kunroll, local_idx, lag_idx;
    double K, E;
    const double* X_target;

    const Pointer<LMesh> mesh = l_data_manager->getLMesh(level_number);
    const std::vector<LNode*>& local_nodes = mesh->getLocalNodes();

    int* lag_node_idxs = &d_bond_data[level_number].lag_mastr_node_idxs[0];

    for (const auto& node : local_nodes)
    {
        const int local_idx = node->getLocalPETScIndex();
        const int lag_idx = node->getLagrangianIndex();
        const int petsc_idx = node->getGlobalPETScIndex();

        for (k = 0; k < num_target_points; ++k)
        {
            X_target = X0[k]->data();
            Eigen::Map<const IBTK::Vector> eig_X_target(X_target);
            if (X0_node[local_idx * NDIM + 0] == eig_X_target(0) && X0_node[local_idx * NDIM + 1] == eig_X_target(1))
            {
                petsc_node_idxs[k] = local_idx;
                petsc_global_node_idxs[k] = petsc_idx;
            }
        }
    }

    // kblock = 0;
    // for (; kblock < (num_target_points - 1) / BLOCKSIZE;
    //      ++kblock) // ensure that the last block is NOT handled by this first loop
    // {
    //     PREFETCH_READ_NTA_BLOCK(petsc_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
    //     PREFETCH_READ_NTA_BLOCK(petsc_global_node_idxs + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
    //     PREFETCH_READ_NTA_BLOCK(kappa + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
    //     PREFETCH_READ_NTA_BLOCK(eta + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
    //     PREFETCH_READ_NTA_BLOCK(X0 + BLOCKSIZE * (kblock + 1), BLOCKSIZE);
    //     for (kunroll = 0; kunroll < BLOCKSIZE; ++kunroll)
    //     {
    //         k = kblock * BLOCKSIZE + kunroll;
    //         local_idx = NDIM * petsc_node_idxs[k];
    //         lag_idx = petsc_global_node_idxs[k];
    //         PREFETCH_READ_NTA_NDIM_BLOCK(F_node + NDIM * petsc_node_idxs[k + 1]);
    //         PREFETCH_READ_NTA_NDIM_BLOCK(X_node + NDIM * petsc_node_idxs[k + 1]);
    //         PREFETCH_READ_NTA(kappa[k + 1]);
    //         PREFETCH_READ_NTA(eta[k + 1]);
    //         PREFETCH_READ_NTA(X0[k + 1]);
    //         K = *kappa[k];
    //         E = *eta[k];
    //         X_target = X0[k]->data();

    //         Eigen::Map<const IBTK::Vector> eig_X(&X_node[local_idx]);
    //         Eigen::Map<const IBTK::Vector> eig_X_target(X_target);
    //         Eigen::Map<const IBTK::Vector> eig_U(&U_node[local_idx]);
    //         Eigen::Map<IBTK::Vector> eig_F(&F_node[local_idx]);

    //         d_target_point_force_fcn(eig_X, eig_X_target, eig_U, K, E, lag_idx, eig_F);
    //     }
    // }
    for (k = 0; k < num_target_points; ++k)
    {
        // std::cout << "petsc_node_idx = " << petsc_node_idxs[k] << std::endl;
        local_idx = NDIM * petsc_node_idxs[k];
        lag_idx = petsc_global_node_idxs[k];
        K = *kappa[k];
        E = *eta[k];
        X_target = X0[k]->data();

        Eigen::Map<const IBTK::Vector> eig_X(&X_node[local_idx]);
        Eigen::Map<const IBTK::Vector> eig_X_target(X_target);
        Eigen::Map<const IBTK::Vector> eig_U(&U_node[local_idx]);
        Eigen::Map<IBTK::Vector> eig_F(&F_node[local_idx]);

        d_target_point_force_fcn(eig_X, eig_X_target, eig_U, K, E, lag_idx, eig_F);
    }

    F_data->restoreArrays();
    X_data->restoreArrays();
    U_data->restoreArrays();
    return;
} // computeLagrangianTargetPointForce

/////////////////////////////// NAMESPACE ////////////////////////////////////

} // namespace IBAMR

//////////////////////////////////////////////////////////////////////////////